import{EMPTY as p,concatMap as d,from as B,pipe as f,tap as a}from"rxjs";import{bigIntMin as g,wait as k}from"@latticexyz/common/utils";import m from"debug";var u=m("mud:block-events-stream");async function*b({maxBlockRange:c=1000n,maxRetryCount:i=3,publicClient:l,...r}){let e=r.fromBlock,t=g(c,r.toBlock-e),n=0;for(;e<=r.toBlock;)try{let o=e+t;u("getting logs",{fromBlock:e,toBlock:o});let s=await l.getLogs({...r,fromBlock:e,toBlock:o,strict:!0});yield{fromBlock:e,toBlock:o,logs:s},e=o+1n,t=g(c,r.toBlock-e)}catch(o){if(u("error getting logs:",String(o)),!(o instanceof Error))throw o;if(o.message.includes("rate limit exceeded")&&n<i){let s=2*n;u(`too many requests, retrying in ${s}s`,o),await k(1e3*s),n+=1;continue}if(o.message.includes("block range exceeded")){if(t/=2n,t<=0n)throw new Error("can't reduce block range any further");u("block range exceeded, trying a smaller block range",o);continue}throw o}}function F({publicClient:c,address:i,events:l,maxBlockRange:r}){let e,t;return f(a(({endBlock:n,startBlock:o})=>{e??=o,t=n}),d(()=>e>t?p:(u("fetching logs for block range",{fromBlock:e,toBlock:t}),B(b({publicClient:c,address:i,events:l,fromBlock:e,toBlock:t,maxBlockRange:r})).pipe(a(({toBlock:n})=>{e=n+1n})))))}import{Observable as T}from"rxjs";function O({publicClient:c,blockTag:i}){return new T(function(r){return c.watchBlocks({blockTag:i,emitOnBegin:!0,onBlock:e=>r.next(e),onError:e=>r.error(e)})})}import{bigIntSort as x,isDefined as y}from"@latticexyz/common/utils";function D(c,i){let l=Array.from(new Set(c.map(t=>t.blockNumber)));l.sort(x);let r=l.map(t=>{let n=c.filter(o=>o.blockNumber===t);if(n.length&&(n.sort((o,s)=>o.logIndex<s.logIndex?-1:o.logIndex>s.logIndex?1:0),!!n.length))return{blockNumber:t,logs:n}}).filter(y),e=l.length>0?l[l.length-1]:null;return i!=null&&(e==null||i>e)&&r.push({blockNumber:i,logs:[]}),r}export{F as blockRangeToLogs,O as createBlockStream,b as fetchLogs,D as groupLogsByBlockNumber};
//# sourceMappingURL=index.js.map