{"version":3,"sources":["../../src/sqlite/buildTable.ts","../../src/sqlite/buildColumn.ts","../../src/sqlite/columnTypes.ts","../../src/sqlite/getTableName.ts","../../src/sqlite/getTables.ts","../../src/sqlite/internalTables.ts","../../src/sqlite/schemaVersion.ts","../../src/sqlite/sqliteStorage.ts","../../src/sqlite/sqliteTableToSql.ts","../../src/sqlite/debug.ts","../../src/sqlite/syncToSqlite.ts"],"sourcesContent":["import { SQLiteColumnBuilderBase, SQLiteTableWithColumns, sqliteTable } from \"drizzle-orm/sqlite-core\";\nimport { buildColumn } from \"./buildColumn\";\nimport { Address } from \"viem\";\nimport { getTableName } from \"./getTableName\";\nimport { KeySchema, ValueSchema } from \"@latticexyz/protocol-parser\";\n\nexport const metaColumns = {\n  __key: buildColumn(\"__key\", \"bytes\").primaryKey(),\n  __staticData: buildColumn(\"__staticData\", \"bytes\"),\n  __encodedLengths: buildColumn(\"__encodedLengths\", \"bytes\"),\n  __dynamicData: buildColumn(\"__dynamicData\", \"bytes\"),\n  __lastUpdatedBlockNumber: buildColumn(\"__lastUpdatedBlockNumber\", \"uint256\").notNull(),\n  // TODO: last updated block hash?\n  __isDeleted: buildColumn(\"__isDeleted\", \"bool\").notNull(),\n} as const satisfies Record<string, SQLiteColumnBuilderBase>;\n\ntype SQLiteTableFromSchema<TKeySchema extends KeySchema, TValueSchema extends ValueSchema> = SQLiteTableWithColumns<{\n  dialect: \"sqlite\";\n  name: string;\n  schema: string | undefined;\n  columns: {\n    // TODO: figure out column types\n    [metaColumn in keyof typeof metaColumns]: any;\n  } & {\n    // TODO: figure out column types\n    [keyColumn in keyof TKeySchema]: any;\n  } & {\n    // TODO: figure out column types\n    [valueColumn in keyof TValueSchema]: any;\n  };\n}>;\n\ntype CreateSqliteTableOptions<TKeySchema extends KeySchema, TValueSchema extends ValueSchema> = {\n  address: Address;\n  namespace: string;\n  name: string;\n  keySchema: TKeySchema;\n  valueSchema: TValueSchema;\n};\n\ntype CreateSqliteTableResult<TKeySchema extends KeySchema, TValueSchema extends ValueSchema> = SQLiteTableFromSchema<\n  TKeySchema,\n  TValueSchema\n>;\n\nexport function buildTable<TKeySchema extends KeySchema, TValueSchema extends ValueSchema>({\n  address,\n  namespace,\n  name,\n  keySchema,\n  valueSchema,\n}: CreateSqliteTableOptions<TKeySchema, TValueSchema>): CreateSqliteTableResult<TKeySchema, TValueSchema> {\n  const tableName = getTableName(address, namespace, name);\n\n  const keyColumns = Object.fromEntries(\n    Object.entries(keySchema).map(([name, type]) => [name, buildColumn(name, type).notNull()])\n  );\n\n  const valueColumns = Object.fromEntries(\n    Object.entries(valueSchema).map(([name, type]) => [name, buildColumn(name, type).notNull()])\n  );\n\n  // TODO: unique constraint on key columns?\n\n  // TODO: make sure there are no meta columns that overlap with key/value columns\n  // TODO: index meta columns?\n\n  const columns = {\n    ...keyColumns,\n    ...valueColumns,\n    ...metaColumns,\n  };\n\n  const table = sqliteTable(tableName, columns);\n\n  return table as SQLiteTableFromSchema<TKeySchema, TValueSchema>;\n}\n","import { blob, integer, text } from \"drizzle-orm/sqlite-core\";\nimport { SchemaAbiType } from \"@latticexyz/schema-type\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport { address, json } from \"./columnTypes\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function buildColumn(name: string, schemaAbiType: SchemaAbiType) {\n  switch (schemaAbiType) {\n    case \"bool\":\n      return integer(name, { mode: \"boolean\" });\n\n    case \"uint8\":\n    case \"uint16\":\n    case \"uint24\":\n    case \"uint32\":\n    case \"uint40\":\n    case \"uint48\":\n    case \"int8\":\n    case \"int16\":\n    case \"int24\":\n    case \"int32\":\n    case \"int40\":\n    case \"int48\":\n      return integer(name, { mode: \"number\" });\n\n    case \"uint56\":\n    case \"uint64\":\n    case \"uint72\":\n    case \"uint80\":\n    case \"uint88\":\n    case \"uint96\":\n    case \"uint104\":\n    case \"uint112\":\n    case \"uint120\":\n    case \"uint128\":\n    case \"uint136\":\n    case \"uint144\":\n    case \"uint152\":\n    case \"uint160\":\n    case \"uint168\":\n    case \"uint176\":\n    case \"uint184\":\n    case \"uint192\":\n    case \"uint200\":\n    case \"uint208\":\n    case \"uint216\":\n    case \"uint224\":\n    case \"uint232\":\n    case \"uint240\":\n    case \"uint248\":\n    case \"uint256\":\n    case \"int56\":\n    case \"int64\":\n    case \"int72\":\n    case \"int80\":\n    case \"int88\":\n    case \"int96\":\n    case \"int104\":\n    case \"int112\":\n    case \"int120\":\n    case \"int128\":\n    case \"int136\":\n    case \"int144\":\n    case \"int152\":\n    case \"int160\":\n    case \"int168\":\n    case \"int176\":\n    case \"int184\":\n    case \"int192\":\n    case \"int200\":\n    case \"int208\":\n    case \"int216\":\n    case \"int224\":\n    case \"int232\":\n    case \"int240\":\n    case \"int248\":\n    case \"int256\":\n      return blob(name, { mode: \"bigint\" });\n\n    case \"bytes1\":\n    case \"bytes2\":\n    case \"bytes3\":\n    case \"bytes4\":\n    case \"bytes5\":\n    case \"bytes6\":\n    case \"bytes7\":\n    case \"bytes8\":\n    case \"bytes9\":\n    case \"bytes10\":\n    case \"bytes11\":\n    case \"bytes12\":\n    case \"bytes13\":\n    case \"bytes14\":\n    case \"bytes15\":\n    case \"bytes16\":\n    case \"bytes17\":\n    case \"bytes18\":\n    case \"bytes19\":\n    case \"bytes20\":\n    case \"bytes21\":\n    case \"bytes22\":\n    case \"bytes23\":\n    case \"bytes24\":\n    case \"bytes25\":\n    case \"bytes26\":\n    case \"bytes27\":\n    case \"bytes28\":\n    case \"bytes29\":\n    case \"bytes30\":\n    case \"bytes31\":\n    case \"bytes32\":\n    case \"bytes\":\n      return text(name);\n\n    case \"address\":\n      return address(name);\n\n    case \"uint8[]\":\n    case \"uint16[]\":\n    case \"uint24[]\":\n    case \"uint32[]\":\n    case \"uint40[]\":\n    case \"uint48[]\":\n    case \"uint56[]\":\n    case \"uint64[]\":\n    case \"uint72[]\":\n    case \"uint80[]\":\n    case \"uint88[]\":\n    case \"uint96[]\":\n    case \"uint104[]\":\n    case \"uint112[]\":\n    case \"uint120[]\":\n    case \"uint128[]\":\n    case \"uint136[]\":\n    case \"uint144[]\":\n    case \"uint152[]\":\n    case \"uint160[]\":\n    case \"uint168[]\":\n    case \"uint176[]\":\n    case \"uint184[]\":\n    case \"uint192[]\":\n    case \"uint200[]\":\n    case \"uint208[]\":\n    case \"uint216[]\":\n    case \"uint224[]\":\n    case \"uint232[]\":\n    case \"uint240[]\":\n    case \"uint248[]\":\n    case \"uint256[]\":\n    case \"int8[]\":\n    case \"int16[]\":\n    case \"int24[]\":\n    case \"int32[]\":\n    case \"int40[]\":\n    case \"int48[]\":\n    case \"int56[]\":\n    case \"int64[]\":\n    case \"int72[]\":\n    case \"int80[]\":\n    case \"int88[]\":\n    case \"int96[]\":\n    case \"int104[]\":\n    case \"int112[]\":\n    case \"int120[]\":\n    case \"int128[]\":\n    case \"int136[]\":\n    case \"int144[]\":\n    case \"int152[]\":\n    case \"int160[]\":\n    case \"int168[]\":\n    case \"int176[]\":\n    case \"int184[]\":\n    case \"int192[]\":\n    case \"int200[]\":\n    case \"int208[]\":\n    case \"int216[]\":\n    case \"int224[]\":\n    case \"int232[]\":\n    case \"int240[]\":\n    case \"int248[]\":\n    case \"int256[]\":\n    case \"bytes1[]\":\n    case \"bytes2[]\":\n    case \"bytes3[]\":\n    case \"bytes4[]\":\n    case \"bytes5[]\":\n    case \"bytes6[]\":\n    case \"bytes7[]\":\n    case \"bytes8[]\":\n    case \"bytes9[]\":\n    case \"bytes10[]\":\n    case \"bytes11[]\":\n    case \"bytes12[]\":\n    case \"bytes13[]\":\n    case \"bytes14[]\":\n    case \"bytes15[]\":\n    case \"bytes16[]\":\n    case \"bytes17[]\":\n    case \"bytes18[]\":\n    case \"bytes19[]\":\n    case \"bytes20[]\":\n    case \"bytes21[]\":\n    case \"bytes22[]\":\n    case \"bytes23[]\":\n    case \"bytes24[]\":\n    case \"bytes25[]\":\n    case \"bytes26[]\":\n    case \"bytes27[]\":\n    case \"bytes28[]\":\n    case \"bytes29[]\":\n    case \"bytes30[]\":\n    case \"bytes31[]\":\n    case \"bytes32[]\":\n    case \"bool[]\":\n      return json(name);\n\n    // TODO: normalize like address column type\n    case \"address[]\":\n      return json(name);\n\n    case \"string\":\n      return text(name);\n\n    default:\n      assertExhaustive(schemaAbiType, `Missing SQLite column type for schema ABI type ${schemaAbiType}`);\n  }\n}\n","import { customType } from \"drizzle-orm/sqlite-core\";\nimport superjson from \"superjson\";\nimport { Address, Hex, getAddress } from \"viem\";\n\n// TODO: migrate these to same patterns in postgres/columnTypes\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport const json = <TData>(name: string) =>\n  customType<{ data: TData; driverData: string }>({\n    dataType() {\n      return \"text\";\n    },\n    toDriver(data: TData): string {\n      return superjson.stringify(data);\n    },\n    fromDriver(driverData: string): TData {\n      return superjson.parse(driverData);\n    },\n  })(name);\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport const address = (name: string) =>\n  customType<{ data: Address; driverData: string }>({\n    dataType() {\n      return \"text\";\n    },\n    toDriver(data: Address): string {\n      return data.toLowerCase();\n    },\n    fromDriver(driverData: string): Address {\n      return getAddress(driverData);\n    },\n  })(name);\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport const asHex = (name: string) =>\n  customType<{ data: Hex; driverData: Hex }>({\n    dataType() {\n      return \"string\";\n    },\n  })(name);\n","import { getAddress } from \"viem\";\n\nexport function getTableName(address: string, namespace: string, tableName: string): string {\n  return `${getAddress(address)}__${namespace}__${tableName}`;\n}\n","import { BaseSQLiteDatabase } from \"drizzle-orm/sqlite-core\";\nimport { inArray } from \"drizzle-orm\";\nimport { Table } from \"../common\";\nimport { getTableName } from \"./getTableName\";\nimport { mudStoreTables } from \"./internalTables\";\n\nexport function getTables(\n  db: BaseSQLiteDatabase<\"sync\", void>,\n  conditions: Pick<Table, \"address\" | \"namespace\" | \"name\">[] = []\n): Table[] {\n  const ids = Array.from(\n    new Set(conditions.map((condition) => getTableName(condition.address, condition.namespace, condition.name)))\n  );\n  const tables = db\n    .select()\n    .from(mudStoreTables)\n    .where(ids.length ? inArray(mudStoreTables.id, ids) : undefined)\n    .all();\n\n  return tables;\n}\n","import { blob, integer, sqliteTable, text } from \"drizzle-orm/sqlite-core\";\nimport { address, asHex, json } from \"./columnTypes\";\nimport { KeySchema, ValueSchema } from \"@latticexyz/protocol-parser\";\n\nexport const chainState = sqliteTable(\"__chainState\", {\n  schemaVersion: integer(\"schema_version\").notNull().primaryKey(),\n  chainId: integer(\"chain_id\").notNull().primaryKey(),\n  lastUpdatedBlockNumber: blob(\"last_updated_block_number\", { mode: \"bigint\" }),\n  // TODO: last block hash?\n  lastError: text(\"last_error\"),\n});\n\nexport const mudStoreTables = sqliteTable(\"__mudStoreTables\", {\n  schemaVersion: integer(\"schema_version\").primaryKey(),\n  id: text(\"id\").notNull().primaryKey(),\n  address: address(\"address\").notNull(),\n  tableId: asHex(\"table_id\").notNull(),\n  namespace: text(\"namespace\").notNull(),\n  name: text(\"name\").notNull(),\n  keySchema: json<KeySchema>(\"key_schema\").notNull(),\n  valueSchema: json<ValueSchema>(\"value_schema\").notNull(),\n  lastUpdatedBlockNumber: blob(\"last_updated_block_number\", { mode: \"bigint\" }),\n  // TODO: last block hash?\n  lastError: text(\"last_error\"),\n});\n","// When this is incremented, it forces all indexers to reindex from scratch the next time they start up.\n// Only use this when the schemas change, until we get proper schema migrations.\nexport const schemaVersion = 1;\n","import { Hex, PublicClient, concatHex, getAddress, size } from \"viem\";\nimport { BaseSQLiteDatabase } from \"drizzle-orm/sqlite-core\";\nimport { and, eq, sql } from \"drizzle-orm\";\nimport { sqliteTableToSql } from \"./sqliteTableToSql\";\nimport { buildTable } from \"./buildTable\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { debug } from \"./debug\";\nimport { getTableName } from \"./getTableName\";\nimport { chainState, mudStoreTables } from \"./internalTables\";\nimport { getTables } from \"./getTables\";\nimport { schemaVersion } from \"./schemaVersion\";\nimport { StorageAdapter } from \"../common\";\nimport { isTableRegistrationLog } from \"../isTableRegistrationLog\";\nimport { logToTable } from \"../logToTable\";\nimport { hexToResource, spliceHex } from \"@latticexyz/common\";\nimport { decodeKey, decodeValueArgs } from \"@latticexyz/protocol-parser\";\n\n// TODO: upgrade drizzle and use async sqlite interface for consistency\n\nexport async function sqliteStorage<TConfig extends StoreConfig = StoreConfig>({\n  database,\n  publicClient,\n}: {\n  database: BaseSQLiteDatabase<\"sync\", void>;\n  publicClient: PublicClient;\n  config?: TConfig;\n}): Promise<StorageAdapter> {\n  const chainId = publicClient.chain?.id ?? (await publicClient.getChainId());\n\n  // TODO: should these run lazily before first `registerTables`?\n  database.run(sql.raw(sqliteTableToSql(chainState)));\n  database.run(sql.raw(sqliteTableToSql(mudStoreTables)));\n\n  return async function sqliteStorageAdapter({ blockNumber, logs }) {\n    // Find table registration logs and create new tables\n    const newTables = logs.filter(isTableRegistrationLog).map(logToTable);\n    await database.transaction(async (tx) => {\n      for (const table of newTables) {\n        debug(`creating table ${table.namespace}:${table.name} for world ${chainId}:${table.address}`);\n\n        const sqliteTable = buildTable(table);\n\n        tx.run(sql.raw(sqliteTableToSql(sqliteTable)));\n\n        tx.insert(mudStoreTables)\n          .values({\n            schemaVersion,\n            id: getTableName(table.address, table.namespace, table.name),\n            ...table,\n            lastUpdatedBlockNumber: blockNumber,\n          })\n          .onConflictDoNothing()\n          .run();\n      }\n    });\n\n    const tables = getTables(\n      database,\n      Array.from(\n        new Set(\n          logs.map((log) =>\n            JSON.stringify({\n              address: getAddress(log.address),\n              ...hexToResource(log.args.tableId),\n            })\n          )\n        )\n      ).map((json) => JSON.parse(json))\n    );\n\n    await database.transaction(async (tx) => {\n      for (const { address, namespace, name } of tables) {\n        tx.update(mudStoreTables)\n          .set({ lastUpdatedBlockNumber: blockNumber })\n          .where(\n            and(\n              eq(mudStoreTables.address, address),\n              eq(mudStoreTables.namespace, namespace),\n              eq(mudStoreTables.name, name)\n            )\n          )\n          .run();\n      }\n\n      for (const log of logs) {\n        const table = tables.find(\n          (table) => table.address === getAddress(log.address) && table.tableId === log.args.tableId\n        );\n        if (!table) {\n          const tableId = hexToResource(log.args.tableId);\n          debug(`table ${tableId.namespace}:${tableId.name} not found, skipping log`, log);\n          continue;\n        }\n\n        const sqlTable = buildTable(table);\n        const uniqueKey = concatHex(log.args.keyTuple as Hex[]);\n        const key = decodeKey(table.keySchema, log.args.keyTuple);\n\n        if (log.eventName === \"Store_SetRecord\") {\n          const value = decodeValueArgs(table.valueSchema, log.args);\n          debug(\"upserting record\", {\n            namespace: table.namespace,\n            name: table.name,\n            key,\n            value,\n          });\n          tx.insert(sqlTable)\n            .values({\n              __key: uniqueKey,\n              __staticData: log.args.staticData,\n              __encodedLengths: log.args.encodedLengths,\n              __dynamicData: log.args.dynamicData,\n              __lastUpdatedBlockNumber: blockNumber,\n              __isDeleted: false,\n              ...key,\n              ...value,\n            })\n            .onConflictDoUpdate({\n              target: sqlTable.__key,\n              set: {\n                __staticData: log.args.staticData,\n                __encodedLengths: log.args.encodedLengths,\n                __dynamicData: log.args.dynamicData,\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: false,\n                ...value,\n              },\n            })\n            .run();\n        } else if (log.eventName === \"Store_SpliceStaticData\") {\n          // TODO: verify that this returns what we expect (doesn't error/undefined on no record)\n          const previousValue = (await tx.select().from(sqlTable).where(eq(sqlTable.__key, uniqueKey)).execute())[0];\n          const previousStaticData = (previousValue?.__staticData as Hex) ?? \"0x\";\n          const newStaticData = spliceHex(previousStaticData, log.args.start, size(log.args.data), log.args.data);\n          const newValue = decodeValueArgs(table.valueSchema, {\n            staticData: newStaticData,\n            encodedLengths: (previousValue?.__encodedLengths as Hex) ?? \"0x\",\n            dynamicData: (previousValue?.__dynamicData as Hex) ?? \"0x\",\n          });\n          debug(\"upserting record via splice static\", {\n            namespace: table.namespace,\n            name: table.name,\n            key,\n            previousStaticData,\n            newStaticData,\n            previousValue,\n            newValue,\n          });\n          tx.insert(sqlTable)\n            .values({\n              __key: uniqueKey,\n              __staticData: newStaticData,\n              __lastUpdatedBlockNumber: blockNumber,\n              __isDeleted: false,\n              ...key,\n              ...newValue,\n            })\n            .onConflictDoUpdate({\n              target: sqlTable.__key,\n              set: {\n                __staticData: newStaticData,\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: false,\n                ...newValue,\n              },\n            })\n            .run();\n        } else if (log.eventName === \"Store_SpliceDynamicData\") {\n          const previousValue = (await tx.select().from(sqlTable).where(eq(sqlTable.__key, uniqueKey)).execute())[0];\n          const previousDynamicData = (previousValue?.__dynamicData as Hex) ?? \"0x\";\n          const newDynamicData = spliceHex(previousDynamicData, log.args.start, log.args.deleteCount, log.args.data);\n          const newValue = decodeValueArgs(table.valueSchema, {\n            staticData: (previousValue?.__staticData as Hex) ?? \"0x\",\n            // TODO: handle unchanged encoded lengths\n            encodedLengths: log.args.encodedLengths,\n            dynamicData: newDynamicData,\n          });\n          debug(\"upserting record via splice dynamic\", {\n            namespace: table.namespace,\n            name: table.name,\n            key,\n            previousDynamicData,\n            newDynamicData,\n            previousValue,\n            newValue,\n          });\n          tx.insert(sqlTable)\n            .values({\n              __key: uniqueKey,\n              // TODO: handle unchanged encoded lengths\n              __encodedLengths: log.args.encodedLengths,\n              __dynamicData: newDynamicData,\n              __lastUpdatedBlockNumber: blockNumber,\n              __isDeleted: false,\n              ...key,\n              ...newValue,\n            })\n            .onConflictDoUpdate({\n              target: sqlTable.__key,\n              set: {\n                // TODO: handle unchanged encoded lengths\n                __encodedLengths: log.args.encodedLengths,\n                __dynamicData: newDynamicData,\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: false,\n                ...newValue,\n              },\n            })\n            .run();\n        } else if (log.eventName === \"Store_DeleteRecord\") {\n          // TODO: should we upsert so we at least have a DB record of when a thing was created/deleted within the same block?\n          debug(\"deleting record\", {\n            namespace: table.namespace,\n            name: table.name,\n            key,\n          });\n          tx.update(sqlTable)\n            .set({\n              __lastUpdatedBlockNumber: blockNumber,\n              __isDeleted: true,\n            })\n            .where(eq(sqlTable.__key, uniqueKey))\n            .run();\n        }\n      }\n\n      tx.insert(chainState)\n        .values({\n          schemaVersion,\n          chainId,\n          lastUpdatedBlockNumber: blockNumber,\n        })\n        .onConflictDoUpdate({\n          target: [chainState.schemaVersion, chainState.chainId],\n          set: {\n            lastUpdatedBlockNumber: blockNumber,\n          },\n        })\n        .run();\n    });\n  };\n}\n","import { AnySQLiteColumn, SQLiteTableWithColumns } from \"drizzle-orm/sqlite-core\";\nimport { ColumnDataType, DummyDriver, Kysely, SqliteAdapter, SqliteIntrospector, SqliteQueryCompiler } from \"kysely\";\nimport { getTableColumns, getTableName } from \"drizzle-orm\";\n\nconst db = new Kysely<any>({\n  dialect: {\n    createAdapter: (): SqliteAdapter => new SqliteAdapter(),\n    createDriver: (): DummyDriver => new DummyDriver(),\n    createIntrospector: (db: Kysely<unknown>): SqliteIntrospector => new SqliteIntrospector(db),\n    createQueryCompiler: (): SqliteQueryCompiler => new SqliteQueryCompiler(),\n  },\n});\n\nexport function sqliteTableToSql(table: SQLiteTableWithColumns<any>): string {\n  const tableName = getTableName(table);\n\n  // TODO: should we allow this to fail (remove ifNotExists) so we can catch issues with our logic that creates tables?\n  let query = db.schema.createTable(tableName).ifNotExists();\n\n  const columns = Object.values(getTableColumns(table)) as AnySQLiteColumn[];\n  for (const column of columns) {\n    query = query.addColumn(column.name, column.getSQLType() as ColumnDataType, (col) => {\n      if (column.notNull) {\n        col = col.notNull();\n      }\n      if (column.hasDefault && typeof column.default !== \"undefined\") {\n        col = col.defaultTo(column.default);\n      }\n      return col;\n    });\n  }\n\n  const primaryKeys = columns.filter((column) => column.primary).map((column) => column.name);\n  if (primaryKeys.length) {\n    query = query.addPrimaryKeyConstraint(`${tableName}__primaryKey`, primaryKeys as any);\n  }\n\n  const { sql } = query.compile();\n  return sql;\n}\n","import { debug as parentDebug } from \"../debug\";\n\nexport const debug = parentDebug.extend(\"sqlite\");\n","import { StoreConfig } from \"@latticexyz/store\";\nimport { BaseSQLiteDatabase } from \"drizzle-orm/sqlite-core\";\nimport { SyncOptions, SyncResult } from \"../common\";\nimport { sqliteStorage } from \"./sqliteStorage\";\nimport { createStoreSync } from \"../createStoreSync\";\n\ntype SyncToSqliteOptions<TConfig extends StoreConfig = StoreConfig> = SyncOptions<TConfig> & {\n  /**\n   * [SQLite database object from Drizzle][0].\n   *\n   * [0]: https://orm.drizzle.team/docs/installation-and-db-connection/sqlite/better-sqlite3\n   */\n  database: BaseSQLiteDatabase<\"sync\", any>;\n  startSync?: boolean;\n};\n\ntype SyncToSqliteResult = SyncResult & {\n  stopSync: () => void;\n};\n\n/**\n * Creates an indexer to process and store blockchain events.\n *\n * @param {SyncToSqliteOptions} options See `SyncToSqliteOptions`.\n * @returns A function to unsubscribe from the block stream, effectively stopping the indexer.\n */\nexport async function syncToSqlite<TConfig extends StoreConfig = StoreConfig>({\n  config,\n  database,\n  publicClient,\n  startSync = true,\n  ...syncOptions\n}: SyncToSqliteOptions<TConfig>): Promise<SyncToSqliteResult> {\n  const storeSync = await createStoreSync({\n    storageAdapter: await sqliteStorage({ database, publicClient, config }),\n    config,\n    publicClient,\n    ...syncOptions,\n  });\n\n  const sub = startSync ? storeSync.storedBlockLogs$.subscribe() : null;\n  const stopSync = (): void => {\n    sub?.unsubscribe();\n  };\n\n  return {\n    ...storeSync,\n    stopSync,\n  };\n}\n"],"mappings":"6HAAA,OAA0D,eAAAA,MAAmB,0BCA7E,OAAS,QAAAC,EAAM,WAAAC,EAAS,QAAAC,MAAY,0BAEpC,OAAS,oBAAAC,MAAwB,2BCFjC,OAAS,cAAAC,MAAkB,0BAC3B,OAAOC,MAAe,YACtB,OAAuB,cAAAC,MAAkB,OAKlC,IAAMC,EAAeC,GAC1BJ,EAAgD,CAC9C,UAAW,CACT,MAAO,MACT,EACA,SAASK,EAAqB,CAC5B,OAAOJ,EAAU,UAAUI,CAAI,CACjC,EACA,WAAWC,EAA2B,CACpC,OAAOL,EAAU,MAAMK,CAAU,CACnC,CACF,CAAC,EAAEF,CAAI,EAGIG,EAAWH,GACtBJ,EAAkD,CAChD,UAAW,CACT,MAAO,MACT,EACA,SAASK,EAAuB,CAC9B,OAAOA,EAAK,YAAY,CAC1B,EACA,WAAWC,EAA6B,CACtC,OAAOJ,EAAWI,CAAU,CAC9B,CACF,CAAC,EAAEF,CAAI,EAGII,EAASJ,GACpBJ,EAA2C,CACzC,UAAW,CACT,MAAO,QACT,CACF,CAAC,EAAEI,CAAI,EDlCF,SAASK,EAAYC,EAAcC,EAA8B,CACtE,OAAQA,EAAe,CACrB,IAAK,OACH,OAAOC,EAAQF,EAAM,CAAE,KAAM,SAAU,CAAC,EAE1C,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,OACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACH,OAAOE,EAAQF,EAAM,CAAE,KAAM,QAAS,CAAC,EAEzC,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,QACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACH,OAAOG,EAAKH,EAAM,CAAE,KAAM,QAAS,CAAC,EAEtC,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,SACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,QACH,OAAOI,EAAKJ,CAAI,EAElB,IAAK,UACH,OAAOK,EAAQL,CAAI,EAErB,IAAK,UACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,YACL,IAAK,SACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,UACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WACL,IAAK,WA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","names":["sqliteTable","blob","integer","text","assertExhaustive","customType","superjson","getAddress","json","name","data","driverData","address","asHex","buildColumn","name","schemaAbiType","integer","blob","text","address","json","assertExhaustive","getAddress","getTableName","address","namespace","tableName","metaColumns","buildColumn","buildTable","address","namespace","name","keySchema","valueSchema","tableName","getTableName","keyColumns","type","valueColumns","columns","sqliteTable","inArray","blob","integer","sqliteTable","text","chainState","sqliteTable","integer","blob","text","mudStoreTables","address","asHex","json","getTables","db","conditions","ids","condition","getTableName","mudStoreTables","inArray","schemaVersion","concatHex","getAddress","size","and","eq","sql","DummyDriver","Kysely","SqliteAdapter","SqliteIntrospector","SqliteQueryCompiler","getTableColumns","getTableName","db","sqliteTableToSql","table","tableName","query","columns","column","col","primaryKeys","sql","debug","hexToResource","spliceHex","decodeKey","decodeValueArgs","sqliteStorage","database","publicClient","chainId","sql","sqliteTableToSql","chainState","mudStoreTables","blockNumber","logs","newTables","isTableRegistrationLog","logToTable","tx","table","debug","sqliteTable","buildTable","getTableName","tables","getTables","log","getAddress","json","address","namespace","name","and","eq","tableId","sqlTable","uniqueKey","concatHex","key","value","previousValue","previousStaticData","newStaticData","size","newValue","previousDynamicData","newDynamicData","syncToSqlite","config","database","publicClient","startSync","syncOptions","storeSync","createStoreSync","sqliteStorage","sub"]}