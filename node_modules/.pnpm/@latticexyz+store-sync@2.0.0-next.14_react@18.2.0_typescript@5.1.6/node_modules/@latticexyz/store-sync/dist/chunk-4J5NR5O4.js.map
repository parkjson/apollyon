{"version":3,"sources":["../src/isTableRegistrationLog.ts","../src/logToTable.ts"],"sourcesContent":["import { StorageAdapterLog, storeTables } from \"./common\";\n\nexport function isTableRegistrationLog(\n  log: StorageAdapterLog\n): log is StorageAdapterLog & { eventName: \"Store_SetRecord\" } {\n  return log.eventName === \"Store_SetRecord\" && log.args.tableId === storeTables.Tables.tableId;\n}\n","import { hexToSchema, decodeValue, ValueSchema } from \"@latticexyz/protocol-parser\";\nimport { Hex, concatHex, decodeAbiParameters, parseAbiParameters } from \"viem\";\nimport { StorageAdapterLog, Table, schemasTable } from \"./common\";\nimport { hexToResource } from \"@latticexyz/common\";\n\n// TODO: add tableToLog\n\nexport function logToTable(log: StorageAdapterLog & { eventName: \"Store_SetRecord\" }): Table {\n  const [tableId, ...otherKeys] = log.args.keyTuple;\n  if (otherKeys.length) {\n    console.warn(\"registerSchema event is expected to have only one key in key tuple, but got multiple\", log);\n  }\n\n  const table = hexToResource(tableId);\n\n  const value = decodeValue(\n    // TODO: remove cast when we have strong types for user types\n    schemasTable.valueSchema as ValueSchema,\n    concatHex([log.args.staticData, log.args.encodedLengths, log.args.dynamicData])\n  );\n\n  // TODO: remove cast when we have strong types for user types\n  const keySchema = hexToSchema(value.keySchema as Hex);\n\n  // TODO: remove cast when we have strong types for user types\n  const valueSchema = hexToSchema(value.valueSchema as Hex);\n\n  // TODO: remove cast when we have strong types for user types\n  const keyNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), value.abiEncodedKeyNames as Hex)[0];\n\n  // TODO: remove cast when we have strong types for user types\n  const fieldNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), value.abiEncodedFieldNames as Hex)[0];\n\n  const valueAbiTypes = [...valueSchema.staticFields, ...valueSchema.dynamicFields];\n\n  return {\n    address: log.address,\n    tableId,\n    namespace: table.namespace,\n    name: table.name,\n    keySchema: Object.fromEntries(keySchema.staticFields.map((abiType, i) => [keyNames[i], abiType])),\n    valueSchema: Object.fromEntries(valueAbiTypes.map((abiType, i) => [fieldNames[i], abiType])),\n  };\n}\n"],"mappings":"+CAEO,SAASA,EACdC,EAC6D,CAC7D,OAAOA,EAAI,YAAc,mBAAqBA,EAAI,KAAK,UAAYC,EAAY,OAAO,OACxF,CCNA,OAAS,eAAAC,EAAa,eAAAC,MAAgC,8BACtD,OAAc,aAAAC,EAAW,uBAAAC,EAAqB,sBAAAC,MAA0B,OAExE,OAAS,iBAAAC,MAAqB,qBAIvB,SAASC,EAAWC,EAAkE,CAC3F,GAAM,CAACC,EAAS,GAAGC,CAAS,EAAIF,EAAI,KAAK,SACrCE,EAAU,QACZ,QAAQ,KAAK,uFAAwFF,CAAG,EAG1G,IAAMG,EAAQL,EAAcG,CAAO,EAE7BG,EAAQC,EAEZC,EAAa,YACbC,EAAU,CAACP,EAAI,KAAK,WAAYA,EAAI,KAAK,eAAgBA,EAAI,KAAK,WAAW,CAAC,CAChF,EAGMQ,EAAYC,EAAYL,EAAM,SAAgB,EAG9CM,EAAcD,EAAYL,EAAM,WAAkB,EAGlDO,EAAWC,EAAoBC,EAAmB,UAAU,EAAGT,EAAM,kBAAyB,EAAE,CAAC,EAGjGU,EAAaF,EAAoBC,EAAmB,UAAU,EAAGT,EAAM,oBAA2B,EAAE,CAAC,EAErGW,EAAgB,CAAC,GAAGL,EAAY,aAAc,GAAGA,EAAY,aAAa,EAEhF,MAAO,CACL,QAASV,EAAI,QACb,QAAAC,EACA,UAAWE,EAAM,UACjB,KAAMA,EAAM,KACZ,UAAW,OAAO,YAAYK,EAAU,aAAa,IAAI,CAACQ,EAASC,IAAM,CAACN,EAASM,CAAC,EAAGD,CAAO,CAAC,CAAC,EAChG,YAAa,OAAO,YAAYD,EAAc,IAAI,CAACC,EAASC,IAAM,CAACH,EAAWG,CAAC,EAAGD,CAAO,CAAC,CAAC,CAC7F,CACF","names":["isTableRegistrationLog","log","storeTables","hexToSchema","decodeValue","concatHex","decodeAbiParameters","parseAbiParameters","hexToResource","logToTable","log","tableId","otherKeys","table","value","decodeValue","schemasTable","concatHex","keySchema","hexToSchema","valueSchema","keyNames","decodeAbiParameters","parseAbiParameters","fieldNames","valueAbiTypes","abiType","i"]}