{"version":3,"sources":["../../src/postgres/buildTable.ts","../../src/postgres/buildColumn.ts","../../src/postgres/columnTypes.ts","../../src/postgres/cleanDatabase.ts","../../src/postgres/buildInternalTables.ts","../../src/postgres/getTables.ts","../../src/postgres/debug.ts","../../src/postgres/pgDialect.ts","../../src/postgres/schemaVersion.ts","../../src/postgres/postgresStorage.ts","../../src/postgres/setupTables.ts","../../src/postgres/getTableKey.ts","../../src/postgres/syncToPostgres.ts"],"sourcesContent":["import { PgColumnBuilderBase, PgTableWithColumns, pgSchema } from \"drizzle-orm/pg-core\";\nimport { buildColumn } from \"./buildColumn\";\nimport { Address, getAddress } from \"viem\";\nimport { transformSchemaName } from \"./transformSchemaName\";\nimport { KeySchema, ValueSchema } from \"@latticexyz/protocol-parser\";\n\n// TODO: convert camel case to snake case for DB storage?\nexport const metaColumns = {\n  __key: buildColumn(\"__key\", \"bytes\").primaryKey(),\n  __staticData: buildColumn(\"__staticData\", \"bytes\"),\n  __encodedLengths: buildColumn(\"__encodedLengths\", \"bytes\"),\n  __dynamicData: buildColumn(\"__dynamicData\", \"bytes\"),\n  __lastUpdatedBlockNumber: buildColumn(\"__lastUpdatedBlockNumber\", \"uint256\").notNull(),\n  // TODO: last updated block hash?\n  __isDeleted: buildColumn(\"__isDeleted\", \"bool\").notNull(),\n} as const satisfies Record<string, PgColumnBuilderBase>;\n\ntype PgTableFromSchema<TKeySchema extends KeySchema, TValueSchema extends ValueSchema> = PgTableWithColumns<{\n  dialect: \"pg\";\n  name: string;\n  schema: string;\n  columns: {\n    // TODO: figure out column types\n    [metaColumn in keyof typeof metaColumns]: any;\n  } & {\n    // TODO: figure out column types\n    [keyColumn in keyof TKeySchema]: any;\n  } & {\n    // TODO: figure out column types\n    [valueColumn in keyof TValueSchema]: any;\n  };\n}>;\n\ntype BuildTableOptions<TKeySchema extends KeySchema, TValueSchema extends ValueSchema> = {\n  address: Address;\n  namespace: string;\n  name: string;\n  keySchema: TKeySchema;\n  valueSchema: TValueSchema;\n};\n\ntype BuildTableResult<TKeySchema extends KeySchema, TValueSchema extends ValueSchema> = PgTableFromSchema<\n  TKeySchema,\n  TValueSchema\n>;\n\nexport function buildTable<TKeySchema extends KeySchema, TValueSchema extends ValueSchema>({\n  address,\n  namespace,\n  name,\n  keySchema,\n  valueSchema,\n}: BuildTableOptions<TKeySchema, TValueSchema>): BuildTableResult<TKeySchema, TValueSchema> {\n  const schemaName = transformSchemaName(`${getAddress(address)}__${namespace}`);\n\n  const keyColumns = Object.fromEntries(\n    Object.entries(keySchema).map(([name, type]) => [name, buildColumn(name, type).notNull()])\n  );\n\n  const valueColumns = Object.fromEntries(\n    Object.entries(valueSchema).map(([name, type]) => [name, buildColumn(name, type).notNull()])\n  );\n\n  // TODO: make sure there are no meta columns that overlap with key/value columns\n  // TODO: index meta columns?\n\n  const columns = {\n    ...keyColumns,\n    ...valueColumns,\n    ...metaColumns,\n  };\n\n  const table = pgSchema(schemaName).table(name, columns);\n\n  return table as PgTableFromSchema<TKeySchema, TValueSchema>;\n}\n","import { boolean, text } from \"drizzle-orm/pg-core\";\nimport { SchemaAbiType } from \"@latticexyz/schema-type\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport { asAddress, asBigInt, asHex, asJson, asNumber } from \"./columnTypes\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function buildColumn(name: string, schemaAbiType: SchemaAbiType) {\n  switch (schemaAbiType) {\n    case \"bool\":\n      return boolean(name);\n\n    case \"uint8\":\n    case \"uint16\":\n    case \"int8\":\n    case \"int16\":\n      // smallint = 2 bytes (https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-INT)\n      return asNumber(name, \"smallint\");\n\n    case \"uint24\":\n    case \"uint32\":\n    case \"int24\":\n    case \"int32\":\n      // integer = 4 bytes (https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-INT)\n      return asNumber(name, \"integer\");\n\n    case \"uint40\":\n    case \"uint48\":\n    case \"int40\":\n    case \"int48\":\n      // bigint = 8 bytes (https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-INT)\n      return asNumber(name, \"bigint\");\n\n    case \"uint56\":\n    case \"uint64\":\n    case \"int56\":\n    case \"int64\":\n      // bigint = 8 bytes (https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-INT)\n      return asBigInt(name, \"bigint\");\n\n    case \"uint72\":\n    case \"uint80\":\n    case \"uint88\":\n    case \"uint96\":\n    case \"uint104\":\n    case \"uint112\":\n    case \"uint120\":\n    case \"uint128\":\n    case \"uint136\":\n    case \"uint144\":\n    case \"uint152\":\n    case \"uint160\":\n    case \"uint168\":\n    case \"uint176\":\n    case \"uint184\":\n    case \"uint192\":\n    case \"uint200\":\n    case \"uint208\":\n    case \"uint216\":\n    case \"uint224\":\n    case \"uint232\":\n    case \"uint240\":\n    case \"uint248\":\n    case \"uint256\":\n    case \"int72\":\n    case \"int80\":\n    case \"int88\":\n    case \"int96\":\n    case \"int104\":\n    case \"int112\":\n    case \"int120\":\n    case \"int128\":\n    case \"int136\":\n    case \"int144\":\n    case \"int152\":\n    case \"int160\":\n    case \"int168\":\n    case \"int176\":\n    case \"int184\":\n    case \"int192\":\n    case \"int200\":\n    case \"int208\":\n    case \"int216\":\n    case \"int224\":\n    case \"int232\":\n    case \"int240\":\n    case \"int248\":\n    case \"int256\":\n      // variable length (https://www.postgresql.org/docs/current/datatype-numeric.html#DATATYPE-NUMERIC-DECIMAL)\n      // we could refine this to the specific length for each type, but maybe not worth it\n      return asBigInt(name, \"numeric\");\n\n    case \"bytes1\":\n    case \"bytes2\":\n    case \"bytes3\":\n    case \"bytes4\":\n    case \"bytes5\":\n    case \"bytes6\":\n    case \"bytes7\":\n    case \"bytes8\":\n    case \"bytes9\":\n    case \"bytes10\":\n    case \"bytes11\":\n    case \"bytes12\":\n    case \"bytes13\":\n    case \"bytes14\":\n    case \"bytes15\":\n    case \"bytes16\":\n    case \"bytes17\":\n    case \"bytes18\":\n    case \"bytes19\":\n    case \"bytes20\":\n    case \"bytes21\":\n    case \"bytes22\":\n    case \"bytes23\":\n    case \"bytes24\":\n    case \"bytes25\":\n    case \"bytes26\":\n    case \"bytes27\":\n    case \"bytes28\":\n    case \"bytes29\":\n    case \"bytes30\":\n    case \"bytes31\":\n    case \"bytes32\":\n    case \"bytes\":\n      return asHex(name);\n\n    case \"address\":\n      return asAddress(name);\n\n    case \"uint8[]\":\n    case \"uint16[]\":\n    case \"uint24[]\":\n    case \"uint32[]\":\n    case \"uint40[]\":\n    case \"uint48[]\":\n    case \"uint56[]\":\n    case \"uint64[]\":\n    case \"uint72[]\":\n    case \"uint80[]\":\n    case \"uint88[]\":\n    case \"uint96[]\":\n    case \"uint104[]\":\n    case \"uint112[]\":\n    case \"uint120[]\":\n    case \"uint128[]\":\n    case \"uint136[]\":\n    case \"uint144[]\":\n    case \"uint152[]\":\n    case \"uint160[]\":\n    case \"uint168[]\":\n    case \"uint176[]\":\n    case \"uint184[]\":\n    case \"uint192[]\":\n    case \"uint200[]\":\n    case \"uint208[]\":\n    case \"uint216[]\":\n    case \"uint224[]\":\n    case \"uint232[]\":\n    case \"uint240[]\":\n    case \"uint248[]\":\n    case \"uint256[]\":\n    case \"int8[]\":\n    case \"int16[]\":\n    case \"int24[]\":\n    case \"int32[]\":\n    case \"int40[]\":\n    case \"int48[]\":\n    case \"int56[]\":\n    case \"int64[]\":\n    case \"int72[]\":\n    case \"int80[]\":\n    case \"int88[]\":\n    case \"int96[]\":\n    case \"int104[]\":\n    case \"int112[]\":\n    case \"int120[]\":\n    case \"int128[]\":\n    case \"int136[]\":\n    case \"int144[]\":\n    case \"int152[]\":\n    case \"int160[]\":\n    case \"int168[]\":\n    case \"int176[]\":\n    case \"int184[]\":\n    case \"int192[]\":\n    case \"int200[]\":\n    case \"int208[]\":\n    case \"int216[]\":\n    case \"int224[]\":\n    case \"int232[]\":\n    case \"int240[]\":\n    case \"int248[]\":\n    case \"int256[]\":\n    case \"bytes1[]\":\n    case \"bytes2[]\":\n    case \"bytes3[]\":\n    case \"bytes4[]\":\n    case \"bytes5[]\":\n    case \"bytes6[]\":\n    case \"bytes7[]\":\n    case \"bytes8[]\":\n    case \"bytes9[]\":\n    case \"bytes10[]\":\n    case \"bytes11[]\":\n    case \"bytes12[]\":\n    case \"bytes13[]\":\n    case \"bytes14[]\":\n    case \"bytes15[]\":\n    case \"bytes16[]\":\n    case \"bytes17[]\":\n    case \"bytes18[]\":\n    case \"bytes19[]\":\n    case \"bytes20[]\":\n    case \"bytes21[]\":\n    case \"bytes22[]\":\n    case \"bytes23[]\":\n    case \"bytes24[]\":\n    case \"bytes25[]\":\n    case \"bytes26[]\":\n    case \"bytes27[]\":\n    case \"bytes28[]\":\n    case \"bytes29[]\":\n    case \"bytes30[]\":\n    case \"bytes31[]\":\n    case \"bytes32[]\":\n    case \"bool[]\":\n      return asJson(name);\n\n    // TODO: normalize like address column type\n    case \"address[]\":\n      return asJson(name);\n\n    case \"string\":\n      return text(name);\n\n    default:\n      assertExhaustive(schemaAbiType, `Missing column type for schema ABI type ${schemaAbiType}`);\n  }\n}\n","import { customType } from \"drizzle-orm/pg-core\";\nimport superjson from \"superjson\";\nimport { Address, ByteArray, bytesToHex, getAddress, Hex, hexToBytes } from \"viem\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport const asJson = <TData>(name: string) =>\n  customType<{ data: TData; driverData: string }>({\n    dataType() {\n      // TODO: move to json column type? if we do, we'll prob wanna choose something other than superjson since it adds one level of depth (json/meta keys)\n      return \"text\";\n    },\n    toDriver(data: TData): string {\n      return superjson.stringify(data);\n    },\n    fromDriver(driverData: string): TData {\n      return superjson.parse(driverData);\n    },\n  })(name);\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport const asNumber = (name: string, columnType: string) =>\n  customType<{ data: number; driverData: string }>({\n    dataType() {\n      return columnType;\n    },\n    toDriver(data: number): string {\n      return String(data);\n    },\n    fromDriver(driverData: string): number {\n      return Number(driverData);\n    },\n  })(name);\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport const asBigInt = (name: string, columnType: string) =>\n  customType<{ data: bigint; driverData: string }>({\n    dataType() {\n      return columnType;\n    },\n    toDriver(data: bigint): string {\n      return String(data);\n    },\n    fromDriver(driverData: string): bigint {\n      return BigInt(driverData);\n    },\n  })(name);\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport const asHex = (name: string) =>\n  customType<{ data: Hex; driverData: ByteArray }>({\n    dataType() {\n      return \"bytea\";\n    },\n    toDriver(data: Hex): ByteArray {\n      return hexToBytes(data);\n    },\n    fromDriver(driverData: ByteArray): Hex {\n      return bytesToHex(driverData);\n    },\n  })(name);\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport const asAddress = (name: string) =>\n  customType<{ data: Address; driverData: ByteArray }>({\n    dataType() {\n      return \"bytea\";\n    },\n    toDriver(data: Address): ByteArray {\n      return hexToBytes(data);\n    },\n    fromDriver(driverData: ByteArray): Address {\n      return getAddress(bytesToHex(driverData));\n    },\n  })(name);\n","import { PgDatabase, getTableConfig } from \"drizzle-orm/pg-core\";\nimport { buildInternalTables } from \"./buildInternalTables\";\nimport { getTables } from \"./getTables\";\nimport { buildTable } from \"./buildTable\";\nimport { isDefined } from \"@latticexyz/common/utils\";\nimport { debug } from \"./debug\";\nimport { sql } from \"drizzle-orm\";\nimport { pgDialect } from \"./pgDialect\";\n\n// This intentionally just cleans up known schemas/tables/rows. We could drop the database but that's scary.\n\nexport async function cleanDatabase(db: PgDatabase<any>): Promise<void> {\n  const internalTables = buildInternalTables();\n  // TODO: check if internalTables schema matches, delete if not\n\n  const tables = (await getTables(db)).map(buildTable);\n\n  const schemaNames = [...new Set(tables.map((table) => getTableConfig(table).schema))].filter(isDefined);\n\n  for (const schemaName of schemaNames) {\n    try {\n      debug(`dropping namespace ${schemaName} and all of its tables`);\n      await db.execute(sql.raw(pgDialect.schema.dropSchema(schemaName).ifExists().cascade().compile().sql));\n    } catch (error) {\n      debug(`failed to drop namespace ${schemaName}`, error);\n    }\n  }\n\n  for (const internalTable of Object.values(internalTables)) {\n    const tableConfig = getTableConfig(internalTable);\n    debug(`deleting all rows from ${tableConfig.schema}.${tableConfig.name}`);\n    await db.delete(internalTable);\n  }\n}\n","import { integer, pgSchema, text } from \"drizzle-orm/pg-core\";\nimport { transformSchemaName } from \"./transformSchemaName\";\nimport { asAddress, asBigInt, asHex, asJson, asNumber } from \"./columnTypes\";\nimport { KeySchema, ValueSchema } from \"@latticexyz/protocol-parser\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function buildInternalTables() {\n  const schema = pgSchema(transformSchemaName(\"__mud_internal\"));\n  return {\n    chain: schema.table(\"chain\", {\n      // TODO: change schema version to varchar/text?\n      schemaVersion: integer(\"schema_version\").notNull().primaryKey(),\n      chainId: asNumber(\"chain_id\", \"bigint\").notNull().primaryKey(),\n      lastUpdatedBlockNumber: asBigInt(\"last_updated_block_number\", \"numeric\"),\n      // TODO: last block hash?\n      lastError: text(\"last_error\"),\n    }),\n    tables: schema.table(\"tables\", {\n      schemaVersion: integer(\"schema_version\").primaryKey(),\n      key: text(\"key\").notNull().primaryKey(),\n      address: asAddress(\"address\").notNull(),\n      tableId: asHex(\"table_id\").notNull(),\n      namespace: text(\"namespace\").notNull(),\n      name: text(\"name\").notNull(),\n      keySchema: asJson<KeySchema>(\"key_schema\").notNull(),\n      valueSchema: asJson<ValueSchema>(\"value_schema\").notNull(),\n      lastUpdatedBlockNumber: asBigInt(\"last_updated_block_number\", \"numeric\"),\n      // TODO: last block hash?\n      lastError: text(\"last_error\"),\n    }),\n  };\n}\n","import { PgDatabase } from \"drizzle-orm/pg-core\";\nimport { inArray } from \"drizzle-orm\";\nimport { Table } from \"../common\";\nimport { buildInternalTables } from \"./buildInternalTables\";\n\nexport async function getTables(db: PgDatabase<any>, keys: string[] = []): Promise<Table[]> {\n  const internalTables = buildInternalTables();\n\n  const tables = await db\n    .select()\n    .from(internalTables.tables)\n    .where(keys.length ? inArray(internalTables.tables.key, [...new Set(keys)]) : undefined);\n\n  return tables;\n}\n","import { debug as parentDebug } from \"../debug\";\n\nexport const debug = parentDebug.extend(\"postgres\");\n","import { DummyDriver, Kysely, PostgresAdapter, PostgresIntrospector, PostgresQueryCompiler } from \"kysely\";\n\nexport const pgDialect = new Kysely({\n  dialect: {\n    createAdapter: (): PostgresAdapter => new PostgresAdapter(),\n    createDriver: (): DummyDriver => new DummyDriver(),\n    createIntrospector: (db: Kysely<unknown>): PostgresIntrospector => new PostgresIntrospector(db),\n    createQueryCompiler: (): PostgresQueryCompiler => new PostgresQueryCompiler(),\n  },\n});\n","// When this is incremented, it forces all indexers to reindex from scratch the next time they start up.\n// Only use this when the schemas change, until we get proper schema migrations.\n// TODO: instead of this, detect schema changes and drop/recreate tables as needed\nexport const schemaVersion = 1;\n","import { Hex, PublicClient, concatHex, size } from \"viem\";\nimport { PgDatabase, QueryResultHKT } from \"drizzle-orm/pg-core\";\nimport { eq, inArray } from \"drizzle-orm\";\nimport { buildTable } from \"./buildTable\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { debug } from \"./debug\";\nimport { buildInternalTables } from \"./buildInternalTables\";\nimport { getTables } from \"./getTables\";\nimport { schemaVersion } from \"./schemaVersion\";\nimport { hexToResource, spliceHex } from \"@latticexyz/common\";\nimport { setupTables } from \"./setupTables\";\nimport { getTableKey } from \"./getTableKey\";\nimport { StorageAdapter, StorageAdapterBlock } from \"../common\";\nimport { isTableRegistrationLog } from \"../isTableRegistrationLog\";\nimport { logToTable } from \"../logToTable\";\nimport { decodeKey, decodeValueArgs } from \"@latticexyz/protocol-parser\";\n\n// Currently assumes one DB per chain ID\n\nexport type PostgresStorageAdapter = {\n  storageAdapter: StorageAdapter;\n  internalTables: ReturnType<typeof buildInternalTables>;\n  cleanUp: () => Promise<void>;\n};\n\nexport async function postgresStorage<TConfig extends StoreConfig = StoreConfig>({\n  database,\n  publicClient,\n}: {\n  database: PgDatabase<QueryResultHKT>;\n  publicClient: PublicClient;\n  config?: TConfig;\n}): Promise<PostgresStorageAdapter> {\n  const cleanUp: (() => Promise<void>)[] = [];\n\n  const chainId = publicClient.chain?.id ?? (await publicClient.getChainId());\n\n  const internalTables = buildInternalTables();\n  cleanUp.push(await setupTables(database, Object.values(internalTables)));\n\n  async function postgresStorageAdapter({ blockNumber, logs }: StorageAdapterBlock): Promise<void> {\n    const newTables = logs.filter(isTableRegistrationLog).map(logToTable);\n    const newSqlTables = newTables.map(buildTable);\n\n    cleanUp.push(await setupTables(database, newSqlTables));\n\n    await database.transaction(async (tx) => {\n      for (const table of newTables) {\n        await tx\n          .insert(internalTables.tables)\n          .values({\n            schemaVersion,\n            key: getTableKey(table),\n            ...table,\n            lastUpdatedBlockNumber: blockNumber,\n          })\n          .onConflictDoNothing()\n          .execute();\n      }\n    });\n\n    const tables = await getTables(\n      database,\n      logs.map((log) => getTableKey({ address: log.address, tableId: log.args.tableId }))\n    );\n\n    // This is currently parallelized per world (each world has its own database).\n    // This may need to change if we decide to put multiple worlds into one DB (e.g. a namespace per world, but all under one DB).\n    // If so, we'll probably want to wrap the entire block worth of operations in a transaction.\n\n    await database.transaction(async (tx) => {\n      const tablesWithOperations = tables.filter((table) =>\n        logs.some((log) => getTableKey({ address: log.address, tableId: log.args.tableId }) === getTableKey(table))\n      );\n      if (tablesWithOperations.length) {\n        await tx\n          .update(internalTables.tables)\n          .set({ lastUpdatedBlockNumber: blockNumber })\n          .where(inArray(internalTables.tables.key, [...new Set(tablesWithOperations.map(getTableKey))]))\n          .execute();\n      }\n\n      for (const log of logs) {\n        const table = tables.find(\n          (table) => getTableKey(table) === getTableKey({ address: log.address, tableId: log.args.tableId })\n        );\n        if (!table) {\n          const { namespace, name } = hexToResource(log.args.tableId);\n          debug(`table ${namespace}:${name} not found, skipping log`, log);\n          continue;\n        }\n\n        const sqlTable = buildTable(table);\n        const uniqueKey = concatHex(log.args.keyTuple as Hex[]);\n        const key = decodeKey(table.keySchema, log.args.keyTuple);\n\n        debug(log.eventName, log);\n\n        if (log.eventName === \"Store_SetRecord\") {\n          const value = decodeValueArgs(table.valueSchema, log.args);\n          debug(\"upserting record\", {\n            namespace: table.namespace,\n            name: table.name,\n            key,\n            value,\n          });\n          await tx\n            .insert(sqlTable)\n            .values({\n              __key: uniqueKey,\n              __staticData: log.args.staticData,\n              __encodedLengths: log.args.encodedLengths,\n              __dynamicData: log.args.dynamicData,\n              __lastUpdatedBlockNumber: blockNumber,\n              __isDeleted: false,\n              ...key,\n              ...value,\n            })\n            .onConflictDoUpdate({\n              target: sqlTable.__key,\n              set: {\n                __staticData: log.args.staticData,\n                __encodedLengths: log.args.encodedLengths,\n                __dynamicData: log.args.dynamicData,\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: false,\n                ...value,\n              },\n            })\n            .execute();\n        } else if (log.eventName === \"Store_SpliceStaticData\") {\n          // TODO: verify that this returns what we expect (doesn't error/undefined on no record)\n          const previousValue = (await tx.select().from(sqlTable).where(eq(sqlTable.__key, uniqueKey)).execute())[0];\n          const previousStaticData = (previousValue?.__staticData as Hex) ?? \"0x\";\n          const newStaticData = spliceHex(previousStaticData, log.args.start, size(log.args.data), log.args.data);\n          const newValue = decodeValueArgs(table.valueSchema, {\n            staticData: newStaticData,\n            encodedLengths: (previousValue?.__encodedLengths as Hex) ?? \"0x\",\n            dynamicData: (previousValue?.__dynamicData as Hex) ?? \"0x\",\n          });\n          debug(\"upserting record via splice static\", {\n            namespace: table.namespace,\n            name: table.name,\n            key,\n            previousStaticData,\n            newStaticData,\n            previousValue,\n            newValue,\n          });\n          await tx\n            .insert(sqlTable)\n            .values({\n              __key: uniqueKey,\n              __staticData: newStaticData,\n              __lastUpdatedBlockNumber: blockNumber,\n              __isDeleted: false,\n              ...key,\n              ...newValue,\n            })\n            .onConflictDoUpdate({\n              target: sqlTable.__key,\n              set: {\n                __staticData: newStaticData,\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: false,\n                ...newValue,\n              },\n            })\n            .execute();\n        } else if (log.eventName === \"Store_SpliceDynamicData\") {\n          // TODO: verify that this returns what we expect (doesn't error/undefined on no record)\n          const previousValue = (await tx.select().from(sqlTable).where(eq(sqlTable.__key, uniqueKey)).execute())[0];\n          const previousDynamicData = (previousValue?.__dynamicData as Hex) ?? \"0x\";\n          const newDynamicData = spliceHex(previousDynamicData, log.args.start, log.args.deleteCount, log.args.data);\n          const newValue = decodeValueArgs(table.valueSchema, {\n            staticData: (previousValue?.__staticData as Hex) ?? \"0x\",\n            // TODO: handle unchanged encoded lengths\n            encodedLengths: log.args.encodedLengths,\n            dynamicData: newDynamicData,\n          });\n          debug(\"upserting record via splice dynamic\", {\n            namespace: table.namespace,\n            name: table.name,\n            key,\n            previousDynamicData,\n            newDynamicData,\n            previousValue,\n            newValue,\n          });\n          await tx\n            .insert(sqlTable)\n            .values({\n              __key: uniqueKey,\n              // TODO: handle unchanged encoded lengths\n              __encodedLengths: log.args.encodedLengths,\n              __dynamicData: newDynamicData,\n              __lastUpdatedBlockNumber: blockNumber,\n              __isDeleted: false,\n              ...key,\n              ...newValue,\n            })\n            .onConflictDoUpdate({\n              target: sqlTable.__key,\n              set: {\n                // TODO: handle unchanged encoded lengths\n                __encodedLengths: log.args.encodedLengths,\n                __dynamicData: newDynamicData,\n                __lastUpdatedBlockNumber: blockNumber,\n                __isDeleted: false,\n                ...newValue,\n              },\n            })\n            .execute();\n        } else if (log.eventName === \"Store_DeleteRecord\") {\n          // TODO: should we upsert so we at least have a DB record of when a thing was created/deleted within the same block?\n          debug(\"deleting record\", {\n            namespace: table.namespace,\n            name: table.name,\n            key,\n          });\n          await tx\n            .update(sqlTable)\n            .set({\n              __lastUpdatedBlockNumber: blockNumber,\n              __isDeleted: true,\n            })\n            .where(eq(sqlTable.__key, uniqueKey))\n            .execute();\n        }\n      }\n\n      await tx\n        .insert(internalTables.chain)\n        .values({\n          schemaVersion,\n          chainId,\n          lastUpdatedBlockNumber: blockNumber,\n        })\n        .onConflictDoUpdate({\n          target: [internalTables.chain.schemaVersion, internalTables.chain.chainId],\n          set: {\n            lastUpdatedBlockNumber: blockNumber,\n          },\n        })\n        .execute();\n    });\n  }\n\n  return {\n    storageAdapter: postgresStorageAdapter,\n    internalTables,\n    cleanUp: async (): Promise<void> => {\n      for (const fn of cleanUp) {\n        await fn();\n      }\n    },\n  };\n}\n","import { AnyPgColumn, PgTableWithColumns, PgDatabase, getTableConfig } from \"drizzle-orm/pg-core\";\nimport { getTableColumns, sql } from \"drizzle-orm\";\nimport { ColumnDataType } from \"kysely\";\nimport { isDefined } from \"@latticexyz/common/utils\";\nimport { debug } from \"./debug\";\nimport { pgDialect } from \"./pgDialect\";\n\nexport async function setupTables(\n  db: PgDatabase<any>,\n  tables: PgTableWithColumns<any>[]\n): Promise<() => Promise<void>> {\n  // TODO: add table to internal tables here\n  // TODO: look up table schema and check if it matches expected schema, drop if not\n\n  const schemaNames = [...new Set(tables.map((table) => getTableConfig(table).schema).filter(isDefined))];\n\n  await db.transaction(async (tx) => {\n    for (const schemaName of schemaNames) {\n      debug(`creating namespace ${schemaName}`);\n      await tx.execute(sql.raw(pgDialect.schema.createSchema(schemaName).ifNotExists().compile().sql));\n    }\n\n    for (const table of tables) {\n      const tableConfig = getTableConfig(table);\n      const scopedDb = tableConfig.schema ? pgDialect.withSchema(tableConfig.schema) : pgDialect;\n\n      let query = scopedDb.schema.createTable(tableConfig.name).ifNotExists();\n\n      const columns = Object.values(getTableColumns(table)) as AnyPgColumn[];\n      for (const column of columns) {\n        query = query.addColumn(column.name, column.getSQLType() as ColumnDataType, (col) => {\n          if (column.notNull) {\n            col = col.notNull();\n          }\n          if (column.hasDefault && typeof column.default !== \"undefined\") {\n            col = col.defaultTo(column.default);\n          }\n          return col;\n        });\n      }\n\n      const primaryKeys = columns.filter((column) => column.primary).map((column) => column.name);\n      if (primaryKeys.length) {\n        query = query.addPrimaryKeyConstraint(`${tableConfig.name}__pk`, primaryKeys as any);\n      }\n\n      debug(`creating table ${tableConfig.name} in namespace ${tableConfig.schema}`);\n      await tx.execute(sql.raw(query.compile().sql));\n    }\n  });\n\n  return async () => {\n    for (const schemaName of schemaNames) {\n      try {\n        debug(`dropping namespace ${schemaName} and all of its tables`);\n        await db.execute(sql.raw(pgDialect.schema.dropSchema(schemaName).ifExists().cascade().compile().sql));\n      } catch (error) {\n        debug(`failed to drop namespace ${schemaName}`, error);\n      }\n    }\n  };\n}\n","import { getAddress } from \"viem\";\nimport { Table } from \"../common\";\nimport { hexToResource } from \"@latticexyz/common\";\n\nexport function getTableKey({ address, tableId }: Pick<Table, \"address\" | \"tableId\">): string {\n  const { namespace, name } = hexToResource(tableId);\n  return `${getAddress(address)}:${namespace}:${name}`;\n}\n","import { StoreConfig } from \"@latticexyz/store\";\nimport { PgDatabase } from \"drizzle-orm/pg-core\";\nimport { SyncOptions, SyncResult } from \"../common\";\nimport { postgresStorage } from \"./postgresStorage\";\nimport { createStoreSync } from \"../createStoreSync\";\n\ntype SyncToPostgresOptions<TConfig extends StoreConfig = StoreConfig> = SyncOptions<TConfig> & {\n  /**\n   * [Postgres database object from Drizzle][0].\n   *\n   * [0]: https://orm.drizzle.team/docs/installation-and-db-connection/postgresql/postgresjs\n   */\n  database: PgDatabase<any>;\n  startSync?: boolean;\n};\n\ntype SyncToPostgresResult = SyncResult & {\n  stopSync: () => void;\n};\n\n/**\n * Creates an indexer to process and store blockchain events.\n *\n * @param {CreateIndexerOptions} options See `CreateIndexerOptions`.\n * @returns A function to unsubscribe from the block stream, effectively stopping the indexer.\n */\nexport async function syncToPostgres<TConfig extends StoreConfig = StoreConfig>({\n  config,\n  database,\n  publicClient,\n  startSync = true,\n  ...syncOptions\n}: SyncToPostgresOptions<TConfig>): Promise<SyncToPostgresResult> {\n  const { storageAdapter } = await postgresStorage({ database, publicClient, config });\n  const storeSync = await createStoreSync({\n    storageAdapter,\n    config,\n    publicClient,\n    ...syncOptions,\n  });\n\n  const sub = startSync ? storeSync.storedBlockLogs$.subscribe() : null;\n  const stopSync = (): void => {\n    sub?.unsubscribe();\n  };\n\n  return {\n    ...storeSync,\n    stopSync,\n  };\n}\n"],"mappings":"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","names":["pgSchema","boolean","text","assertExhaustive","customType","superjson","bytesToHex","getAddress","hexToBytes","asJson","name","data","driverData","asNumber","columnType","asBigInt","asHex","asAddress","buildColumn","name","schemaAbiType","boolean","asNumber","asBigInt","asHex","asAddress","asJson","text","assertExhaustive","getAddress","metaColumns","buildColumn","buildTable","address","namespace","name","keySchema","valueSchema","schemaName","getAddress","keyColumns","type","valueColumns","columns","pgSchema","getTableConfig","integer","pgSchema","text","buildInternalTables","schema","pgSchema","integer","asNumber","asBigInt","text","asAddress","asHex","asJson","inArray","getTables","db","keys","internalTables","buildInternalTables","inArray","isDefined","debug","sql","DummyDriver","Kysely","PostgresAdapter","PostgresIntrospector","PostgresQueryCompiler","pgDialect","db","cleanDatabase","db","internalTables","buildInternalTables","tables","getTables","buildTable","schemaNames","table","getTableConfig","isDefined","schemaName","debug","sql","pgDialect","error","internalTable","tableConfig","schemaVersion","concatHex","size","eq","inArray","hexToResource","spliceHex","getTableConfig","getTableColumns","sql","isDefined","setupTables","db","tables","schemaNames","table","getTableConfig","isDefined","tx","schemaName","debug","sql","pgDialect","tableConfig","query","columns","getTableColumns","column","col","primaryKeys","error","getAddress","hexToResource","getTableKey","address","tableId","namespace","name","decodeKey","decodeValueArgs","postgresStorage","database","publicClient","cleanUp","chainId","internalTables","buildInternalTables","setupTables","postgresStorageAdapter","blockNumber","logs","newTables","isTableRegistrationLog","logToTable","newSqlTables","buildTable","tx","table","getTableKey","tables","getTables","log","tablesWithOperations","inArray","namespace","name","hexToResource","debug","sqlTable","uniqueKey","concatHex","key","value","previousValue","eq","previousStaticData","newStaticData","spliceHex","size","newValue","previousDynamicData","newDynamicData","fn","syncToPostgres","config","database","publicClient","startSync","syncOptions","storageAdapter","postgresStorage","storeSync","createStoreSync","sub"]}