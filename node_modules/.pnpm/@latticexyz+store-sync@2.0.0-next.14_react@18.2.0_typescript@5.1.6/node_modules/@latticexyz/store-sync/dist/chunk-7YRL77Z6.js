import{b as E}from"./chunk-5D4GTPIW.js";import{resolveConfig as $}from"@latticexyz/store";import G from"@latticexyz/store/mud.config";import J from"@latticexyz/world/mud.config";import{mapObject as _}from"@latticexyz/common/utils";function T(a){return _(a,n=>n.type)}var k=$(G).tables,Ie=$(J).tables,He=k.Tables.tableId,Oe={...k.Tables,keySchema:T(k.Tables.keySchema),valueSchema:T(k.Tables.valueSchema)};var F=(i=>(i.INITIALIZE="initialize",i.SNAPSHOT="snapshot",i.RPC="rpc",i.LIVE="live",i))(F||{});import{resourceToHex as V}from"@latticexyz/common";import x from"@latticexyz/store/mud.config";import B from"@latticexyz/world/mud.config";var Q=Object.keys(x.tables).map(a=>V({type:x.tables[a].offchainOnly?"offchainTable":"table",namespace:x.namespace,name:a})),X=Object.keys(B.tables).map(a=>V({type:B.tables[a].offchainOnly?"offchainTable":"table",namespace:B.namespace,name:a})),W=[...Q,...X];import{storeEventsAbi as ee}from"@latticexyz/store";import{TransactionReceiptNotFoundError as te}from"viem";import{createBlockStream as oe,blockRangeToLogs as re,groupLogsByBlockNumber as ae}from"@latticexyz/block-logs-stream";import{filter as N,map as S,tap as b,mergeMap as se,from as ne,concat as le,concatMap as A,share as j,firstValueFrom as ce,defer as ie,of as pe,catchError as me,shareReplay as d,combineLatest as ge,scan as be,identity as de}from"rxjs";import Y from"debug";var M=Y("mud:store-sync");import{chunk as fe,isDefined as ue}from"@latticexyz/common/utils";import{encodeKey as ke,encodeValueArgs as Se}from"@latticexyz/protocol-parser";var l=M.extend("createStoreSync"),ye=W.map(a=>({tableId:a}));async function Xe({storageAdapter:a,onProgress:n,publicClient:m,address:v,filters:i=[],tableIds:C=[],startBlock:L=0n,maxBlockRange:D,initialState:I,indexerUrl:y}){let h=i.length||C.length?[...i,...C.map(e=>({tableId:e})),...ye]:[],H=ie(async()=>{if(I)return I;if(!y)return;l("fetching initial state from indexer",y),n?.({step:"snapshot",percentage:0,latestBlockNumber:0n,lastBlockNumberProcessed:0n,message:"Fetching snapshot from indexer"});let e=E({url:y}),t=m.chain?.id??await m.getChainId(),r=await e.findAll.query({chainId:t,address:v,filters:h});return n?.({step:"snapshot",percentage:100,latestBlockNumber:0n,lastBlockNumberProcessed:0n,message:"Fetched snapshot from indexer"}),r}).pipe(me(e=>(l("error fetching initial state from indexer",e),n?.({step:"snapshot",percentage:100,latestBlockNumber:0n,lastBlockNumberProcessed:L,message:"Failed to fetch snapshot from indexer"}),pe(void 0))),d(1)),K=H.pipe(S(e=>e?.blockNumber??L),b(e=>l("starting sync from block",e))),z=H.pipe(N(e=>e!=null&&e.blockNumber!=null&&e.tables.length>0),A(async({blockNumber:e,tables:t})=>{l("hydrating from initial state to block",e),n?.({step:"snapshot",percentage:0,latestBlockNumber:0n,lastBlockNumberProcessed:e,message:"Hydrating from snapshot"});let r=t.flatMap(s=>s.records.map(g=>({eventName:"Store_SetRecord",address:s.address,args:{tableId:s.tableId,keyTuple:ke(s.keySchema,g.key),...Se(s.valueSchema,g.value)}}))),c=Math.max(100,Math.floor(r.length/50)),o=Array.from(fe(r,c));for(let[s,g]of o.entries())await a({blockNumber:e,logs:g}),n?.({step:"snapshot",percentage:(s+g.length)/o.length*100,latestBlockNumber:0n,lastBlockNumberProcessed:e,message:"Hydrating from snapshot"});return n?.({step:"snapshot",percentage:100,latestBlockNumber:0n,lastBlockNumberProcessed:e,message:"Hydrated from snapshot"}),{blockNumber:e,logs:r}}),d(1)),O=oe({publicClient:m,blockTag:"latest"}).pipe(d(1)),P=O.pipe(S(e=>e.number),b(e=>{l("latest block number",e)}),d(1)),f=null,p=null,R=ge([K,P]).pipe(S(([e,t])=>({startBlock:e,endBlock:t})),b(e=>{f=e.startBlock,p=e.endBlock}),re({publicClient:m,address:v,events:ee,maxBlockRange:D}),S(({toBlock:e,logs:t})=>{if(!h.length)return{toBlock:e,logs:t};let r=t.filter(c=>h.some(o=>o.tableId===c.args.tableId&&(o.key0==null||o.key0===c.args.keyTuple[0])&&(o.key1==null||o.key1===c.args.keyTuple[1])));return{toBlock:e,logs:r}}),se(({toBlock:e,logs:t})=>ne(ae(t,e))),j()),u=null,w=le(z,R.pipe(A(async e=>(await a(e),e)),b(({blockNumber:e,logs:t})=>{if(l("stored",t.length,"logs for block",e),u=e,f!=null&&p!=null)if(e<p){let r=p-f,c=u-f;n?.({step:"rpc",percentage:Number(c*1000n/r)/10,latestBlockNumber:p,lastBlockNumberProcessed:u,message:"Hydrating from RPC"})}else n?.({step:"live",percentage:100,latestBlockNumber:p,lastBlockNumberProcessed:u,message:"All caught up!"})}))).pipe(j()),q=10,U=w.pipe(be((e,t)=>[t,...e].slice(0,q),[]),N(e=>e.length>0),d(1));async function Z(e){l("waiting for tx",e);let t=U.pipe(A(async r=>{if(r.flatMap(o=>o.logs.map(s=>s.transactionHash).filter(ue)).includes(e))return!0;try{let o=r[0];l("fetching tx receipt for block",o.blockNumber);let s=await m.getTransactionReceipt({hash:e});return o.blockNumber>=s.blockNumber}catch(o){if(o instanceof te)return!1;throw o}}),b(r=>l("has tx?",e,r)));await ce(t.pipe(N(de)))}return{latestBlock$:O,latestBlockNumber$:P,blockLogs$:R,storedBlockLogs$:w,waitForTransaction:Z}}export{T as a,k as b,Ie as c,He as d,Oe as e,M as f,F as g,Q as h,W as i,Xe as j};
//# sourceMappingURL=chunk-7YRL77Z6.js.map