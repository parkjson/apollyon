{"version":3,"sources":["../../src/zustand/createStorageAdapter.ts","../../src/zustand/debug.ts","../../src/zustand/getId.ts","../../src/zustand/createStore.ts","../../src/zustand/logToTable.ts","../../src/zustand/syncToZustand.ts"],"sourcesContent":["import { Tables } from \"@latticexyz/store\";\nimport { StorageAdapter } from \"../common\";\nimport { RawRecord } from \"./common\";\nimport { ZustandStore } from \"./createStore\";\nimport { hexToResource, spliceHex } from \"@latticexyz/common\";\nimport { debug } from \"./debug\";\nimport { getId } from \"./getId\";\nimport { size } from \"viem\";\nimport { decodeKey, decodeValueArgs } from \"@latticexyz/protocol-parser\";\nimport { flattenSchema } from \"../flattenSchema\";\nimport { isDefined } from \"@latticexyz/common/utils\";\n\nexport type CreateStorageAdapterOptions<tables extends Tables> = {\n  store: ZustandStore<tables>;\n};\n\nexport function createStorageAdapter<tables extends Tables>({\n  store,\n}: CreateStorageAdapterOptions<tables>): StorageAdapter {\n  return async function zustandStorageAdapter({ blockNumber, logs }) {\n    // TODO: clean this up so that we do one store write per block\n\n    const updatedIds: string[] = [];\n    const deletedIds: string[] = [];\n\n    for (const log of logs) {\n      const table = store.getState().tables[log.args.tableId];\n      if (!table) {\n        const { namespace, name } = hexToResource(log.args.tableId);\n        debug(`skipping update for unknown table: ${namespace}:${name} (${log.args.tableId}) at ${log.address}`);\n        console.log(store.getState().tables, log.args.tableId);\n        continue;\n      }\n\n      const id = getId(log.args);\n\n      if (log.eventName === \"Store_SetRecord\") {\n        debug(\"setting record\", {\n          namespace: table.namespace,\n          name: table.name,\n          id,\n          log,\n        });\n        updatedIds.push(id);\n        store.setState({\n          rawRecords: {\n            ...store.getState().rawRecords,\n            [id]: {\n              id,\n              tableId: log.args.tableId,\n              keyTuple: log.args.keyTuple,\n              staticData: log.args.staticData,\n              encodedLengths: log.args.encodedLengths,\n              dynamicData: log.args.dynamicData,\n            },\n          },\n        });\n      } else if (log.eventName === \"Store_SpliceStaticData\") {\n        debug(\"splicing static data\", {\n          namespace: table.namespace,\n          name: table.name,\n          id,\n          log,\n        });\n        updatedIds.push(id);\n        const previousRecord = (store.getState().rawRecords[id] as RawRecord | undefined) ?? {\n          id,\n          tableId: log.args.tableId,\n          keyTuple: log.args.keyTuple,\n          staticData: \"0x\",\n          encodedLengths: \"0x\",\n          dynamicData: \"0x\",\n        };\n        const staticData = spliceHex(previousRecord.staticData, log.args.start, size(log.args.data), log.args.data);\n        store.setState({\n          rawRecords: {\n            ...store.getState().rawRecords,\n            [id]: {\n              ...previousRecord,\n              staticData,\n            },\n          },\n        });\n      } else if (log.eventName === \"Store_SpliceDynamicData\") {\n        debug(\"splicing dynamic data\", {\n          namespace: table.namespace,\n          name: table.name,\n          id,\n          log,\n        });\n        updatedIds.push(id);\n        const previousRecord = (store.getState().rawRecords[id] as RawRecord | undefined) ?? {\n          id,\n          tableId: log.args.tableId,\n          keyTuple: log.args.keyTuple,\n          staticData: \"0x\",\n          encodedLengths: \"0x\",\n          dynamicData: \"0x\",\n        };\n        const encodedLengths = log.args.encodedLengths;\n        const dynamicData = spliceHex(previousRecord.dynamicData, log.args.start, log.args.deleteCount, log.args.data);\n        store.setState({\n          rawRecords: {\n            ...store.getState().rawRecords,\n            [id]: {\n              ...previousRecord,\n              encodedLengths,\n              dynamicData,\n            },\n          },\n        });\n      } else if (log.eventName === \"Store_DeleteRecord\") {\n        debug(\"deleting record\", {\n          namespace: table.namespace,\n          name: table.name,\n          id,\n          log,\n        });\n        deletedIds.push(id);\n        const { [id]: deletedRecord, ...rawRecords } = store.getState().rawRecords;\n        store.setState({ rawRecords });\n      }\n    }\n\n    if (!updatedIds.length && !deletedIds.length) return;\n\n    const records = {\n      ...Object.fromEntries(Object.entries(store.getState().records).filter(([id]) => !deletedIds.includes(id))),\n      ...Object.fromEntries(\n        updatedIds\n          .map((id) => {\n            const rawRecord = store.getState().rawRecords[id];\n            if (!rawRecord) {\n              console.warn(\"no raw record found for updated ID\", id);\n              return;\n            }\n            const table = store.getState().tables[rawRecord.tableId];\n            if (!table) {\n              console.warn(\"no table found for record\", rawRecord);\n              return;\n            }\n            // TODO: warn if no table\n            return [\n              id,\n              {\n                id,\n                table: store.getState().tables[rawRecord.tableId],\n                keyTuple: rawRecord.keyTuple,\n                key: decodeKey(flattenSchema(table.keySchema), rawRecord.keyTuple),\n                value: decodeValueArgs(flattenSchema(table.valueSchema), rawRecord),\n              },\n            ];\n          })\n          .filter(isDefined)\n      ),\n    };\n\n    store.setState({ records });\n  };\n}\n","import { debug as parentDebug } from \"../debug\";\n\nexport const debug = parentDebug.extend(\"zustand\");\n","import { Hex, concatHex } from \"viem\";\n\ntype GetIdOptions = {\n  readonly tableId: Hex;\n  readonly keyTuple: readonly Hex[];\n};\n\nexport function getId({ tableId, keyTuple }: GetIdOptions): string {\n  // TODO: pass in keyTuple directly once types are fixed (https://github.com/wagmi-dev/viem/pull/1417)\n  return `${tableId}:${concatHex([...keyTuple])}`;\n}\n","import { SchemaToPrimitives, Table, Tables } from \"@latticexyz/store\";\nimport { StoreApi, UseBoundStore, create } from \"zustand\";\nimport { RawRecord, TableRecord } from \"./common\";\nimport { Hex } from \"viem\";\nimport { encodeKey } from \"@latticexyz/protocol-parser\";\nimport { flattenSchema } from \"../flattenSchema\";\nimport { getId } from \"./getId\";\n\ntype TableRecords<table extends Table> = {\n  readonly [id: string]: TableRecord<table>;\n};\n\n// TODO: split this into distinct stores and combine (https://docs.pmnd.rs/zustand/guides/typescript#slices-pattern)?\n\nexport type ZustandState<tables extends Tables> = {\n  /** Tables derived from table registration store events */\n  readonly tables: {\n    readonly [tableId: Hex]: Table;\n  };\n  /** Raw records (bytes) derived from store events */\n  readonly rawRecords: {\n    readonly [id: string]: RawRecord;\n  };\n  /** Decoded table records derived from raw records */\n  readonly records: {\n    readonly [id: string]: TableRecord<tables[keyof tables]>;\n  };\n  readonly getRecords: <table extends Table>(table: table) => TableRecords<table>;\n  readonly getRecord: <table extends Table>(\n    table: table,\n    key: SchemaToPrimitives<table[\"keySchema\"]>\n  ) => TableRecord<table> | undefined;\n  readonly getValue: <table extends Table>(\n    table: table,\n    key: SchemaToPrimitives<table[\"keySchema\"]>\n  ) => TableRecord<table>[\"value\"] | undefined;\n};\n\nexport type ZustandStore<tables extends Tables> = UseBoundStore<StoreApi<ZustandState<tables>>>;\n\nexport type CreateStoreOptions<tables extends Tables> = {\n  tables: tables;\n};\n\nexport function createStore<tables extends Tables>(opts: CreateStoreOptions<tables>): ZustandStore<tables> {\n  return create<ZustandState<tables>>((set, get) => ({\n    tables: Object.fromEntries(Object.entries(opts.tables).map(([, table]) => [table.tableId, table])),\n    rawRecords: {},\n    records: {},\n    getRecords: <table extends Table>(table: table): TableRecords<table> => {\n      const records = get().records;\n      return Object.fromEntries(\n        Object.entries(records).filter(([id, record]) => record.table.tableId === table.tableId)\n      ) as unknown as TableRecords<table>;\n    },\n    getRecord: <table extends Table>(\n      table: table,\n      key: SchemaToPrimitives<table[\"keySchema\"]>\n    ): TableRecord<table> | undefined => {\n      const keyTuple = encodeKey(flattenSchema(table.keySchema), key);\n      const id = getId({ tableId: table.tableId, keyTuple });\n      return get().records[id] as unknown as TableRecord<table> | undefined;\n    },\n    getValue: <table extends Table>(\n      table: table,\n      key: SchemaToPrimitives<table[\"keySchema\"]>\n    ): TableRecord<table>[\"value\"] | undefined => {\n      return get().getRecord(table, key)?.value;\n    },\n  }));\n}\n","import { hexToResource } from \"@latticexyz/common\";\nimport { hexToSchema, decodeValue } from \"@latticexyz/protocol-parser\";\nimport { concatHex, decodeAbiParameters, parseAbiParameters } from \"viem\";\nimport { StorageAdapterLog, schemasTable } from \"../common\";\nimport { Table } from \"@latticexyz/store\";\n\nexport function logToTable(log: StorageAdapterLog & { eventName: \"Store_SetRecord\" }): Table {\n  const [tableId, ...otherKeys] = log.args.keyTuple;\n  if (otherKeys.length) {\n    console.warn(\"registerSchema event is expected to have only one key in key tuple, but got multiple\", log);\n  }\n\n  const table = hexToResource(tableId);\n\n  const value = decodeValue(\n    schemasTable.valueSchema,\n    concatHex([log.args.staticData, log.args.encodedLengths, log.args.dynamicData])\n  );\n\n  const keySchema = hexToSchema(value.keySchema);\n  const valueSchema = hexToSchema(value.valueSchema);\n\n  const keyNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), value.abiEncodedKeyNames)[0];\n  const fieldNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), value.abiEncodedFieldNames)[0];\n\n  const valueAbiTypes = [...valueSchema.staticFields, ...valueSchema.dynamicFields];\n\n  return {\n    tableId,\n    namespace: table.namespace,\n    name: table.name,\n    keySchema: Object.fromEntries(keySchema.staticFields.map((abiType, i) => [keyNames[i], { type: abiType }])),\n    valueSchema: Object.fromEntries(valueAbiTypes.map((abiType, i) => [fieldNames[i], { type: abiType }])),\n  };\n}\n","import { ResolvedStoreConfig, StoreConfig, Tables, resolveConfig } from \"@latticexyz/store\";\nimport { SyncOptions, SyncResult, storeTables, worldTables } from \"../common\";\nimport { createStoreSync } from \"../createStoreSync\";\nimport { ZustandStore } from \"./createStore\";\nimport { createStore } from \"./createStore\";\nimport { createStorageAdapter } from \"./createStorageAdapter\";\nimport { Address } from \"viem\";\n\ntype AllTables<\n  config extends StoreConfig,\n  extraTables extends Tables | undefined\n> = ResolvedStoreConfig<config>[\"tables\"] &\n  (extraTables extends Tables ? extraTables : Record<never, never>) &\n  typeof storeTables &\n  typeof worldTables;\n\ntype SyncToZustandOptions<config extends StoreConfig, extraTables extends Tables | undefined> = SyncOptions & {\n  // require address for now to keep the data model + retrieval simpler\n  address: Address;\n  config: config;\n  tables?: extraTables;\n  store?: ZustandStore<AllTables<config, extraTables>>;\n  startSync?: boolean;\n};\n\ntype SyncToZustandResult<config extends StoreConfig, extraTables extends Tables | undefined> = SyncResult & {\n  tables: AllTables<config, extraTables>;\n  useStore: ZustandStore<AllTables<config, extraTables>>;\n  stopSync: () => void;\n};\n\nexport async function syncToZustand<config extends StoreConfig, extraTables extends Tables | undefined>({\n  config,\n  tables: extraTables,\n  store,\n  startSync = true,\n  ...syncOptions\n}: SyncToZustandOptions<config, extraTables>): Promise<SyncToZustandResult<config, extraTables>> {\n  // TODO: migrate this once we redo config to return fully resolved tables (https://github.com/latticexyz/mud/issues/1668)\n  // TODO: move store/world tables into `resolveConfig`\n  const resolvedConfig = resolveConfig(config);\n  const tables = {\n    ...resolvedConfig.tables,\n    ...extraTables,\n    ...storeTables,\n    ...worldTables,\n  } as unknown as AllTables<config, extraTables>;\n\n  const useStore = store ?? createStore({ tables });\n  const storageAdapter = createStorageAdapter({ store: useStore });\n\n  const storeSync = await createStoreSync({\n    storageAdapter,\n    ...syncOptions,\n  });\n\n  const sub = startSync ? storeSync.storedBlockLogs$.subscribe() : null;\n  const stopSync = (): void => {\n    sub?.unsubscribe();\n  };\n\n  return {\n    ...storeSync,\n    tables,\n    useStore,\n    stopSync,\n  };\n}\n"],"mappings":"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","names":["hexToResource","spliceHex","debug","concatHex","getId","tableId","keyTuple","size","decodeKey","decodeValueArgs","isDefined","createStorageAdapter","store","blockNumber","logs","updatedIds","deletedIds","log","table","namespace","name","hexToResource","debug","id","getId","previousRecord","staticData","spliceHex","size","encodedLengths","dynamicData","deletedRecord","rawRecords","records","rawRecord","decodeKey","flattenSchema","decodeValueArgs","create","encodeKey","createStore","opts","create","set","get","table","records","id","record","key","keyTuple","encodeKey","flattenSchema","getId","hexToResource","hexToSchema","decodeValue","concatHex","decodeAbiParameters","parseAbiParameters","logToTable","log","tableId","otherKeys","table","hexToResource","value","decodeValue","schemasTable","concatHex","keySchema","hexToSchema","valueSchema","keyNames","decodeAbiParameters","parseAbiParameters","fieldNames","valueAbiTypes","abiType","i","resolveConfig","syncToZustand","config","extraTables","store","startSync","syncOptions","tables","resolveConfig","storeTables","worldTables","useStore","createStore","storageAdapter","createStorageAdapter","storeSync","createStoreSync","sub"]}