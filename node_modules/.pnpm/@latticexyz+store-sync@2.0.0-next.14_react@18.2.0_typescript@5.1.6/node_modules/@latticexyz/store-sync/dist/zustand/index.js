import{a as p,b as f,c as g,e as S,f as T,j as y}from"../chunk-7YRL77Z6.js";import"../chunk-5D4GTPIW.js";import{hexToResource as D,spliceHex as x}from"@latticexyz/common";var m=T.extend("zustand");import{concatHex as A}from"viem";function u({tableId:t,keyTuple:i}){return`${t}:${A([...i])}`}import{size as O}from"viem";import{decodeKey as C,decodeValueArgs as Z}from"@latticexyz/protocol-parser";import{isDefined as L}from"@latticexyz/common/utils";function R({store:t}){return async function({blockNumber:b,logs:s}){let o=[],c=[];for(let e of s){let r=t.getState().tables[e.args.tableId];if(!r){let{namespace:n,name:d}=D(e.args.tableId);m(`skipping update for unknown table: ${n}:${d} (${e.args.tableId}) at ${e.address}`),console.log(t.getState().tables,e.args.tableId);continue}let a=u(e.args);if(e.eventName==="Store_SetRecord")m("setting record",{namespace:r.namespace,name:r.name,id:a,log:e}),o.push(a),t.setState({rawRecords:{...t.getState().rawRecords,[a]:{id:a,tableId:e.args.tableId,keyTuple:e.args.keyTuple,staticData:e.args.staticData,encodedLengths:e.args.encodedLengths,dynamicData:e.args.dynamicData}}});else if(e.eventName==="Store_SpliceStaticData"){m("splicing static data",{namespace:r.namespace,name:r.name,id:a,log:e}),o.push(a);let n=t.getState().rawRecords[a]??{id:a,tableId:e.args.tableId,keyTuple:e.args.keyTuple,staticData:"0x",encodedLengths:"0x",dynamicData:"0x"},d=x(n.staticData,e.args.start,O(e.args.data),e.args.data);t.setState({rawRecords:{...t.getState().rawRecords,[a]:{...n,staticData:d}}})}else if(e.eventName==="Store_SpliceDynamicData"){m("splicing dynamic data",{namespace:r.namespace,name:r.name,id:a,log:e}),o.push(a);let n=t.getState().rawRecords[a]??{id:a,tableId:e.args.tableId,keyTuple:e.args.keyTuple,staticData:"0x",encodedLengths:"0x",dynamicData:"0x"},d=e.args.encodedLengths,I=x(n.dynamicData,e.args.start,e.args.deleteCount,e.args.data);t.setState({rawRecords:{...t.getState().rawRecords,[a]:{...n,encodedLengths:d,dynamicData:I}}})}else if(e.eventName==="Store_DeleteRecord"){m("deleting record",{namespace:r.namespace,name:r.name,id:a,log:e}),c.push(a);let{[a]:n,...d}=t.getState().rawRecords;t.setState({rawRecords:d})}}if(!o.length&&!c.length)return;let l={...Object.fromEntries(Object.entries(t.getState().records).filter(([e])=>!c.includes(e))),...Object.fromEntries(o.map(e=>{let r=t.getState().rawRecords[e];if(!r){console.warn("no raw record found for updated ID",e);return}let a=t.getState().tables[r.tableId];if(!a){console.warn("no table found for record",r);return}return[e,{id:e,table:t.getState().tables[r.tableId],keyTuple:r.keyTuple,key:C(p(a.keySchema),r.keyTuple),value:Z(p(a.valueSchema),r)}]}).filter(L))};t.setState({records:l})}}import{create as N}from"zustand";import{encodeKey as j}from"@latticexyz/protocol-parser";function h(t){return N((i,b)=>({tables:Object.fromEntries(Object.entries(t.tables).map(([,s])=>[s.tableId,s])),rawRecords:{},records:{},getRecords:s=>{let o=b().records;return Object.fromEntries(Object.entries(o).filter(([c,l])=>l.table.tableId===s.tableId))},getRecord:(s,o)=>{let c=j(p(s.keySchema),o),l=u({tableId:s.tableId,keyTuple:c});return b().records[l]},getValue:(s,o)=>b().getRecord(s,o)?.value}))}import{hexToResource as E}from"@latticexyz/common";import{hexToSchema as k,decodeValue as H}from"@latticexyz/protocol-parser";import{concatHex as P,decodeAbiParameters as v,parseAbiParameters as w}from"viem";function ie(t){let[i,...b]=t.args.keyTuple;b.length&&console.warn("registerSchema event is expected to have only one key in key tuple, but got multiple",t);let s=E(i),o=H(S.valueSchema,P([t.args.staticData,t.args.encodedLengths,t.args.dynamicData])),c=k(o.keySchema),l=k(o.valueSchema),e=v(w("string[]"),o.abiEncodedKeyNames)[0],r=v(w("string[]"),o.abiEncodedFieldNames)[0],a=[...l.staticFields,...l.dynamicFields];return{tableId:i,namespace:s.namespace,name:s.name,keySchema:Object.fromEntries(c.staticFields.map((n,d)=>[e[d],{type:n}])),valueSchema:Object.fromEntries(a.map((n,d)=>[r[d],{type:n}]))}}import{resolveConfig as $}from"@latticexyz/store";async function he({config:t,tables:i,store:b,startSync:s=!0,...o}){let l={...$(t).tables,...i,...f,...g},e=b??h({tables:l}),r=R({store:e}),a=await y({storageAdapter:r,...o}),n=s?a.storedBlockLogs$.subscribe():null;return{...a,tables:l,useStore:e,stopSync:()=>{n?.unsubscribe()}}}export{R as createStorageAdapter,h as createStore,u as getId,ie as logToTable,he as syncToZustand};
//# sourceMappingURL=index.js.map