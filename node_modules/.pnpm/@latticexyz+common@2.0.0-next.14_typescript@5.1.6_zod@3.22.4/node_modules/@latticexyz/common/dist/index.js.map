{"version":3,"sources":["../src/createBurnerAccount.ts","../src/createNonceManager.ts","../src/getNonceManagerId.ts","../src/getContract.ts","../src/writeContract.ts","../src/getNonceManager.ts","../src/getBurnerPrivateKey.ts","../src/hexToResource.ts","../src/resourceTypes.ts","../src/resourceToHex.ts","../src/readHex.ts","../src/sendTransaction.ts","../src/spliceHex.ts","../src/transportObserver.ts","../src/deprecated/createContract.ts","../src/deprecated/resourceIdToHex.ts","../src/deprecated/hexToResourceId.ts"],"sourcesContent":["import { Account, Hex } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\n\nexport function createBurnerAccount(privateKey: Hex): Account {\n  const account = privateKeyToAccount(privateKey);\n  // We may override account features here\n  return {\n    ...account,\n  };\n}\n","import { BaseError, BlockTag, Client, Hex, NonceTooHighError, NonceTooLowError } from \"viem\";\nimport { debug as parentDebug } from \"./debug\";\nimport { getNonceManagerId } from \"./getNonceManagerId\";\nimport { getTransactionCount } from \"viem/actions\";\nimport PQueue from \"p-queue\";\n\nconst debug = parentDebug.extend(\"createNonceManager\");\n\nexport type CreateNonceManagerOptions = {\n  client: Client;\n  address: Hex;\n  blockTag?: BlockTag;\n  broadcastChannelName?: string;\n};\n\nexport type CreateNonceManagerResult = {\n  hasNonce: () => boolean;\n  nextNonce: () => number;\n  resetNonce: () => Promise<void>;\n  shouldResetNonce: (error: unknown) => boolean;\n  mempoolQueue: PQueue;\n};\n\nexport function createNonceManager({\n  client,\n  address, // TODO: rename to account?\n  blockTag = \"pending\",\n  broadcastChannelName,\n}: CreateNonceManagerOptions): CreateNonceManagerResult {\n  const nonceRef = { current: -1 };\n  let channel: BroadcastChannel | null = null;\n\n  if (typeof BroadcastChannel !== \"undefined\") {\n    const channelName = broadcastChannelName\n      ? Promise.resolve(broadcastChannelName)\n      : getNonceManagerId({ client, address, blockTag });\n    channelName.then((name) => {\n      channel = new BroadcastChannel(name);\n      // TODO: emit some sort of \"connected\" event so other channels can broadcast current nonce\n      channel.addEventListener(\"message\", (event) => {\n        const nonce = JSON.parse(event.data);\n        debug(\"got nonce from broadcast channel\", nonce);\n        nonceRef.current = nonce;\n      });\n    });\n  }\n\n  function hasNonce(): boolean {\n    return nonceRef.current >= 0;\n  }\n\n  function nextNonce(): number {\n    if (!hasNonce()) throw new Error(\"call resetNonce before using nextNonce\");\n    const nonce = nonceRef.current++;\n    channel?.postMessage(JSON.stringify(nonceRef.current));\n    return nonce;\n  }\n\n  async function resetNonce(): Promise<void> {\n    const nonce = await getTransactionCount(client, { address, blockTag });\n    nonceRef.current = nonce;\n    channel?.postMessage(JSON.stringify(nonceRef.current));\n    debug(\"reset nonce to\", nonceRef.current);\n  }\n\n  function shouldResetNonce(error: unknown): boolean {\n    return (\n      error instanceof BaseError &&\n      error.walk((e) => e instanceof NonceTooLowError || e instanceof NonceTooHighError) != null\n    );\n  }\n\n  const mempoolQueue = new PQueue({ concurrency: 1 });\n\n  return {\n    hasNonce,\n    nextNonce,\n    resetNonce,\n    shouldResetNonce,\n    mempoolQueue,\n  };\n}\n","import { BlockTag, Client, Hex, getAddress } from \"viem\";\nimport { getChainId } from \"viem/actions\";\n\nexport async function getNonceManagerId({\n  client,\n  address,\n  blockTag,\n}: {\n  client: Client;\n  address: Hex;\n  blockTag: BlockTag;\n}): Promise<string> {\n  // TODO: improve this so we don't have to call getChainId every time\n  const chainId = client.chain?.id ?? (await getChainId(client));\n  return `mud:createNonceManager:${chainId}:${getAddress(address)}:${blockTag}`;\n}\n","import {\n  Abi,\n  Account,\n  Address,\n  Chain,\n  GetContractParameters,\n  GetContractReturnType,\n  Hex,\n  PublicClient,\n  Transport,\n  WalletClient,\n  WriteContractParameters,\n  getContract as viem_getContract,\n} from \"viem\";\nimport { UnionOmit } from \"./type-utils/common\";\nimport { writeContract } from \"./writeContract\";\n\n// copied from viem because this isn't exported\n// TODO: import from viem?\nfunction getFunctionParameters(values: [args?: readonly unknown[], options?: object]): {\n  args: readonly unknown[];\n  options: object;\n} {\n  const hasArgs = values.length && Array.isArray(values[0]);\n  const args = hasArgs ? values[0]! : [];\n  const options = (hasArgs ? values[1] : values[0]) ?? {};\n  return { args, options };\n}\n\nexport type ContractWrite = {\n  id: string;\n  request: WriteContractParameters;\n  result: Promise<Hex>;\n};\n\nexport type GetContractOptions<\n  TTransport extends Transport,\n  TAddress extends Address,\n  TAbi extends Abi,\n  TChain extends Chain,\n  TAccount extends Account,\n  TPublicClient extends PublicClient<TTransport, TChain>,\n  TWalletClient extends WalletClient<TTransport, TChain, TAccount>\n> = Required<GetContractParameters<TTransport, TChain, TAccount, TAbi, TPublicClient, TWalletClient, TAddress>> & {\n  onWrite?: (write: ContractWrite) => void;\n};\n\n// TODO: migrate away from this approach once we can hook into viem: https://github.com/wagmi-dev/viem/discussions/1230\n\nexport function getContract<\n  TTransport extends Transport,\n  TAddress extends Address,\n  TAbi extends Abi,\n  TChain extends Chain,\n  TAccount extends Account,\n  TPublicClient extends PublicClient<TTransport, TChain>,\n  TWalletClient extends WalletClient<TTransport, TChain, TAccount>\n>({\n  abi,\n  address,\n  publicClient,\n  walletClient,\n  onWrite,\n}: GetContractOptions<\n  TTransport,\n  TAddress,\n  TAbi,\n  TChain,\n  TAccount,\n  TPublicClient,\n  TWalletClient\n>): GetContractReturnType<TAbi, TPublicClient, TWalletClient, TAddress> {\n  const contract = viem_getContract<TTransport, TAddress, TAbi, TChain, TAccount, TPublicClient, TWalletClient>({\n    abi,\n    address,\n    publicClient,\n    walletClient,\n  }) as unknown as GetContractReturnType<Abi, PublicClient, WalletClient>;\n\n  if (contract.write) {\n    // Replace write calls with our own. Implemented ~the same as viem, but adds better handling of nonces (via queue + retries).\n    let nextWriteId = 0;\n    contract.write = new Proxy(\n      {},\n      {\n        get(_, functionName: string) {\n          return (\n            ...parameters: [\n              args?: readonly unknown[],\n              options?: UnionOmit<WriteContractParameters, \"abi\" | \"address\" | \"functionName\" | \"args\">\n            ]\n          ) => {\n            const { args, options } = getFunctionParameters(parameters);\n            const request = {\n              abi,\n              address,\n              functionName,\n              args,\n              ...options,\n              onWrite,\n            } as unknown as WriteContractParameters<TAbi, typeof functionName, TChain, TAccount>;\n            const result = writeContract(walletClient, request);\n\n            const id = `${walletClient.chain.id}:${walletClient.account.address}:${nextWriteId++}`;\n            onWrite?.({ id, request: request as WriteContractParameters, result });\n\n            return result;\n          };\n        },\n      }\n    );\n  }\n\n  return contract as unknown as GetContractReturnType<TAbi, TPublicClient, TWalletClient, TAddress>;\n}\n","import {\n  Abi,\n  Account,\n  Chain,\n  Client,\n  SimulateContractParameters,\n  Transport,\n  WriteContractParameters,\n  WriteContractReturnType,\n} from \"viem\";\nimport { simulateContract, writeContract as viem_writeContract } from \"viem/actions\";\nimport pRetry from \"p-retry\";\nimport { debug as parentDebug } from \"./debug\";\nimport { getNonceManager } from \"./getNonceManager\";\nimport { parseAccount } from \"viem/accounts\";\n\nconst debug = parentDebug.extend(\"writeContract\");\n\n// TODO: migrate away from this approach once we can hook into viem's nonce management: https://github.com/wagmi-dev/viem/discussions/1230\n\nexport async function writeContract<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TAbi extends Abi | readonly unknown[],\n  TFunctionName extends string,\n  TChainOverride extends Chain | undefined\n>(\n  client: Client<Transport, TChain, TAccount>,\n  request: WriteContractParameters<TAbi, TFunctionName, TChain, TAccount, TChainOverride>\n): Promise<WriteContractReturnType> {\n  const rawAccount = request.account ?? client.account;\n  if (!rawAccount) {\n    // TODO: replace with viem AccountNotFoundError once its exported\n    throw new Error(\"No account provided\");\n  }\n  const account = parseAccount(rawAccount);\n\n  const nonceManager = await getNonceManager({\n    client,\n    address: account.address,\n    blockTag: \"pending\",\n  });\n\n  async function prepareWrite(): Promise<\n    WriteContractParameters<TAbi, TFunctionName, TChain, TAccount, TChainOverride>\n  > {\n    if (request.gas) {\n      debug(\"gas provided, skipping simulate\", request.functionName, request.address);\n      return request;\n    }\n\n    debug(\"simulating\", request.functionName, \"at\", request.address);\n    const result = await simulateContract<TChain, TAbi, TFunctionName, TChainOverride>(client, {\n      ...request,\n      blockTag: \"pending\",\n      account,\n    } as unknown as SimulateContractParameters<TAbi, TFunctionName, TChain, TChainOverride>);\n\n    return result.request as unknown as WriteContractParameters<TAbi, TFunctionName, TChain, TAccount, TChainOverride>;\n  }\n\n  const preparedWrite = await prepareWrite();\n\n  return nonceManager.mempoolQueue.add(\n    () =>\n      pRetry(\n        async () => {\n          if (!nonceManager.hasNonce()) {\n            await nonceManager.resetNonce();\n          }\n\n          const nonce = nonceManager.nextNonce();\n          debug(\"calling\", preparedWrite.functionName, \"with nonce\", nonce, \"at\", preparedWrite.address);\n          return await viem_writeContract(client, { nonce, ...preparedWrite } as typeof preparedWrite);\n        },\n        {\n          retries: 3,\n          onFailedAttempt: async (error) => {\n            // On nonce errors, reset the nonce and retry\n            if (nonceManager.shouldResetNonce(error)) {\n              debug(\"got nonce error, retrying\", error.message);\n              await nonceManager.resetNonce();\n              return;\n            }\n            // TODO: prepareWrite again if there are gas errors?\n            throw error;\n          },\n        }\n      ),\n    { throwOnTimeout: true }\n  );\n}\n","import { CreateNonceManagerOptions, CreateNonceManagerResult, createNonceManager } from \"./createNonceManager\";\nimport { getNonceManagerId } from \"./getNonceManagerId\";\n\nconst nonceManagers = new Map<string, CreateNonceManagerResult>();\n\nexport async function getNonceManager({\n  client,\n  address, // TODO: rename to account?\n  blockTag = \"pending\",\n}: CreateNonceManagerOptions): Promise<CreateNonceManagerResult> {\n  const id = await getNonceManagerId({ client, address, blockTag });\n\n  const existingNonceManager = nonceManagers.get(id);\n  if (existingNonceManager) {\n    return existingNonceManager;\n  }\n\n  const nonceManager = createNonceManager({ client, address, blockTag });\n  nonceManagers.set(id, nonceManager);\n  return nonceManager;\n}\n","import { generatePrivateKey, privateKeyToAccount } from \"viem/accounts\";\nimport { isHex, Hex } from \"viem\";\n\nfunction assertPrivateKey(privateKey: string, cacheKey: string): asserts privateKey is Hex {\n  if (!isHex(privateKey)) {\n    console.error(\"Private key found in cache is not valid hex\", { privateKey, cacheKey });\n    throw new Error(`Private key found in cache (${cacheKey}) is not valid hex`);\n  }\n  // ensure we can extract address from private key\n  // this should throw on bad private keys\n  privateKeyToAccount(privateKey);\n}\n\nexport function getBurnerPrivateKey(cacheKey = \"mud:burnerWallet\"): Hex {\n  const cachedPrivateKey = localStorage.getItem(cacheKey);\n\n  if (cachedPrivateKey != null) {\n    assertPrivateKey(cachedPrivateKey, cacheKey);\n    return cachedPrivateKey;\n  }\n\n  const privateKey = generatePrivateKey();\n  console.log(\"New burner wallet created:\", privateKeyToAccount(privateKey));\n  localStorage.setItem(cacheKey, privateKey);\n  return privateKey;\n}\n","import { Hex, hexToString, sliceHex } from \"viem\";\nimport { Resource } from \"./common\";\nimport { ResourceType, resourceTypes } from \"./resourceTypes\";\nimport { resourceTypeIds } from \"./resourceToHex\";\nimport { ReverseMap } from \"./type-utils/common\";\n\nconst resourceTypeIdToType = Object.fromEntries(\n  Object.entries(resourceTypeIds).map(([key, value]) => [value, key])\n) as ReverseMap<typeof resourceTypeIds>;\n\nfunction getResourceType(resourceTypeId: string): ResourceType | undefined {\n  // TODO: replace Partial with `noUncheckedIndexedAccess`\n  const type = (resourceTypeIdToType as Partial<Record<string, ResourceType>>)[resourceTypeId];\n  if (resourceTypes.includes(type as ResourceType)) {\n    return type;\n  }\n}\n\nexport function hexToResource(hex: Hex): Resource {\n  const resourceTypeId = hexToString(sliceHex(hex, 0, 2)).replace(/\\0+$/, \"\");\n  const type = getResourceType(resourceTypeId);\n  const namespace = hexToString(sliceHex(hex, 2, 16)).replace(/\\0+$/, \"\");\n  const name = hexToString(sliceHex(hex, 16, 32)).replace(/\\0+$/, \"\");\n\n  if (!type) {\n    throw new Error(`Unknown type (${resourceTypeId}) for resource (${resourceTypeId}:${namespace}:${name})`);\n  }\n\n  return { resourceId: hex, type, namespace, name };\n}\n","export const resourceTypes = [\"table\", \"offchainTable\", \"namespace\", \"module\", \"system\"] as const;\n\nexport type ResourceType = (typeof resourceTypes)[number];\n","import { Hex, stringToHex, concatHex } from \"viem\";\nimport { Resource } from \"./common\";\nimport { ResourceType } from \"./resourceTypes\";\n\n/** @internal */\nexport const resourceTypeIds = {\n  // keep these in sync with storeResourceTypes.sol\n  table: \"tb\",\n  offchainTable: \"ot\",\n  // keep these in sync with worldResourceTypes.sol\n  namespace: \"ns\",\n  module: \"md\",\n  system: \"sy\",\n} as const satisfies Record<ResourceType, string>;\n\nexport function resourceToHex(resource: Omit<Resource, \"resourceId\">): Hex {\n  const typeId = resourceTypeIds[resource.type];\n  return concatHex([\n    stringToHex(typeId, { size: 2 }),\n    stringToHex(resource.namespace.slice(0, 14), { size: 14 }),\n    stringToHex(resource.name.slice(0, 16), { size: 16 }),\n  ]);\n}\n","import { Hex } from \"viem\";\n\n/**\n * Get the hex value at start/end positions. This will always return a valid hex string.\n *\n * If `start` is out of range, this returns `\"0x\"`.\n *\n * If `end` is specified and out of range, the result is right zero-padded to the desired length (`end - start`).\n */\nexport function readHex(data: Hex, start: number, end?: number): Hex {\n  return `0x${data\n    .replace(/^0x/, \"\")\n    .slice(start * 2, end != null ? end * 2 : undefined)\n    .padEnd(((end ?? start) - start) * 2, \"0\")}`;\n}\n","import {\n  Account,\n  CallParameters,\n  Chain,\n  Client,\n  SendTransactionParameters,\n  Transport,\n  WriteContractReturnType,\n} from \"viem\";\nimport { call, sendTransaction as viem_sendTransaction } from \"viem/actions\";\nimport pRetry from \"p-retry\";\nimport { debug as parentDebug } from \"./debug\";\nimport { getNonceManager } from \"./getNonceManager\";\nimport { parseAccount } from \"viem/accounts\";\n\nconst debug = parentDebug.extend(\"sendTransaction\");\n\n// TODO: migrate away from this approach once we can hook into viem's nonce management: https://github.com/wagmi-dev/viem/discussions/1230\n\nexport async function sendTransaction<\n  TChain extends Chain | undefined,\n  TAccount extends Account | undefined,\n  TChainOverride extends Chain | undefined\n>(\n  client: Client<Transport, TChain, TAccount>,\n  request: SendTransactionParameters<TChain, TAccount, TChainOverride>\n): Promise<WriteContractReturnType> {\n  const rawAccount = request.account ?? client.account;\n  if (!rawAccount) {\n    // TODO: replace with viem AccountNotFoundError once its exported\n    throw new Error(\"No account provided\");\n  }\n  const account = parseAccount(rawAccount);\n\n  const nonceManager = await getNonceManager({\n    client,\n    address: account.address,\n    blockTag: \"pending\",\n  });\n\n  async function prepare(): Promise<SendTransactionParameters<TChain, TAccount, TChainOverride>> {\n    if (request.gas) {\n      debug(\"gas provided, skipping simulate\", request.to);\n      return request;\n    }\n\n    debug(\"simulating tx to\", request.to);\n    await call(client, {\n      ...request,\n      blockTag: \"pending\",\n      account,\n    } as CallParameters<TChain>);\n\n    // TODO: estimate gas\n\n    return request;\n  }\n\n  const preparedRequest = await prepare();\n\n  return await nonceManager.mempoolQueue.add(\n    () =>\n      pRetry(\n        async () => {\n          if (!nonceManager.hasNonce()) {\n            await nonceManager.resetNonce();\n          }\n\n          const nonce = nonceManager.nextNonce();\n          debug(\"sending tx with nonce\", nonce, \"to\", preparedRequest.to);\n          return await viem_sendTransaction(client, { nonce, ...preparedRequest });\n        },\n        {\n          retries: 3,\n          onFailedAttempt: async (error) => {\n            // On nonce errors, reset the nonce and retry\n            if (nonceManager.shouldResetNonce(error)) {\n              debug(\"got nonce error, retrying\", error.message);\n              await nonceManager.resetNonce();\n              return;\n            }\n            // TODO: prepare again if there are gas errors?\n            throw error;\n          },\n        }\n      ),\n    { throwOnTimeout: true }\n  );\n}\n","import { Hex, concatHex } from \"viem\";\nimport { readHex } from \"./readHex\";\n\nexport function spliceHex(data: Hex, start: number, deleteCount = 0, newData: Hex = \"0x\"): Hex {\n  return concatHex([readHex(data, 0, start), newData, readHex(data, start + deleteCount)]);\n}\n","import { Hex, Transport, keccak256 } from \"viem\";\nimport { debug as parentDebug } from \"./debug\";\n\nconst debug = parentDebug.extend(\"transportObserver\");\n\nexport function transportObserver<TTransport extends Transport>(transport: TTransport): TTransport {\n  return ((opts) => {\n    const result = transport(opts);\n    const request: typeof result.request = async (req) => {\n      if (req.method === \"eth_sendRawTransaction\" && req.params instanceof Array) {\n        const txs = req.params.map((data: Hex) => keccak256(data));\n        debug(\"saw txs\", txs);\n        // TODO: pass these tx hashes into dev tools\n      }\n      // TODO: add support for `eth_sendTransaction`\n      return result.request(req);\n    };\n    return {\n      ...result,\n      request,\n    };\n  }) as TTransport;\n}\n","import { getContract } from \"../getContract\";\n\n/** @deprecated use `getContract` instead */\nexport const createContract = getContract;\n","import { resourceToHex } from \"../resourceToHex\";\n\n/** @deprecated use `resourceToHex` instead */\nexport const resourceIdToHex = resourceToHex;\n","import { hexToResource } from \"../hexToResource\";\n\n/** @deprecated use `hexToResource` instead */\nexport const hexToResourceId = hexToResource;\n"],"mappings":"wCACA,OAAS,uBAAAA,MAA2B,gBAE7B,SAASC,GAAoBC,EAA0B,CAG5D,MAAO,CACL,GAHcF,EAAoBE,CAAU,CAI9C,CACF,CCTA,OAAS,aAAAC,EAAkC,qBAAAC,EAAmB,oBAAAC,MAAwB,OCAtF,OAAgC,cAAAC,MAAkB,OAClD,OAAS,cAAAC,MAAkB,eAE3B,eAAsBC,EAAkB,CACtC,OAAAC,EACA,QAAAC,EACA,SAAAC,CACF,EAIoB,CAGlB,MAAO,0BADSF,EAAO,OAAO,IAAO,MAAMF,EAAWE,CAAM,KAChBH,EAAWI,CAAO,KAAKC,GACrE,CDZA,OAAS,uBAAAC,MAA2B,eACpC,OAAOC,MAAY,UAEnB,IAAMC,EAAQA,EAAY,OAAO,oBAAoB,EAiB9C,SAASC,EAAmB,CACjC,OAAAC,EACA,QAAAC,EACA,SAAAC,EAAW,UACX,qBAAAC,CACF,EAAwD,CACtD,IAAMC,EAAW,CAAE,QAAS,EAAG,EAC3BC,EAAmC,KAEnC,OAAO,iBAAqB,MACVF,EAChB,QAAQ,QAAQA,CAAoB,EACpCG,EAAkB,CAAE,OAAAN,EAAQ,QAAAC,EAAS,SAAAC,CAAS,CAAC,GACvC,KAAMK,GAAS,CACzBF,EAAU,IAAI,iBAAiBE,CAAI,EAEnCF,EAAQ,iBAAiB,UAAYG,GAAU,CAC7C,IAAMC,EAAQ,KAAK,MAAMD,EAAM,IAAI,EACnCV,EAAM,mCAAoCW,CAAK,EAC/CL,EAAS,QAAUK,CACrB,CAAC,CACH,CAAC,EAGH,SAASC,GAAoB,CAC3B,OAAON,EAAS,SAAW,CAC7B,CAEA,SAASO,GAAoB,CAC3B,GAAI,CAACD,EAAS,EAAG,MAAM,IAAI,MAAM,wCAAwC,EACzE,IAAMD,EAAQL,EAAS,UACvB,OAAAC,GAAS,YAAY,KAAK,UAAUD,EAAS,OAAO,CAAC,EAC9CK,CACT,CAEA,eAAeG,GAA4B,CACzC,IAAMH,EAAQ,MAAMb,EAAoBI,EAAQ,CAAE,QAAAC,EAAS,SAAAC,CAAS,CAAC,EACrEE,EAAS,QAAUK,EACnBJ,GAAS,YAAY,KAAK,UAAUD,EAAS,OAAO,CAAC,EACrDN,EAAM,iBAAkBM,EAAS,OAAO,CAC1C,CAEA,SAASS,EAAiBC,EAAyB,CACjD,OACEA,aAAiBC,GACjBD,EAAM,KAAME,GAAMA,aAAaC,GAAoBD,aAAaE,CAAiB,GAAK,IAE1F,CAEA,IAAMC,EAAe,IAAItB,EAAO,CAAE,YAAa,CAAE,CAAC,EAElD,MAAO,CACL,SAAAa,EACA,UAAAC,EACA,WAAAC,EACA,iBAAAC,EACA,aAAAM,CACF,CACF,CEjFA,OAYE,eAAeC,MACV,OCHP,OAAS,oBAAAC,EAAkB,iBAAiBC,MAA0B,eACtE,OAAOC,MAAY,UCRnB,IAAMC,EAAgB,IAAI,IAE1B,eAAsBC,EAAgB,CACpC,OAAAC,EACA,QAAAC,EACA,SAAAC,EAAW,SACb,EAAiE,CAC/D,IAAMC,EAAK,MAAMC,EAAkB,CAAE,OAAAJ,EAAQ,QAAAC,EAAS,SAAAC,CAAS,CAAC,EAE1DG,EAAuBP,EAAc,IAAIK,CAAE,EACjD,GAAIE,EACF,OAAOA,EAGT,IAAMC,EAAeC,EAAmB,CAAE,OAAAP,EAAQ,QAAAC,EAAS,SAAAC,CAAS,CAAC,EACrE,OAAAJ,EAAc,IAAIK,EAAIG,CAAY,EAC3BA,CACT,CDNA,OAAS,gBAAAE,MAAoB,gBAE7B,IAAMC,EAAQA,EAAY,OAAO,eAAe,EAIhD,eAAsBC,EAOpBC,EACAC,EACkC,CAClC,IAAMC,EAAaD,EAAQ,SAAWD,EAAO,QAC7C,GAAI,CAACE,EAEH,MAAM,IAAI,MAAM,qBAAqB,EAEvC,IAAMC,EAAUN,EAAaK,CAAU,EAEjCE,EAAe,MAAMC,EAAgB,CACzC,OAAAL,EACA,QAASG,EAAQ,QACjB,SAAU,SACZ,CAAC,EAED,eAAeG,GAEb,CACA,OAAIL,EAAQ,KACVH,EAAM,kCAAmCG,EAAQ,aAAcA,EAAQ,OAAO,EACvEA,IAGTH,EAAM,aAAcG,EAAQ,aAAc,KAAMA,EAAQ,OAAO,GAChD,MAAMM,EAA8DP,EAAQ,CACzF,GAAGC,EACH,SAAU,UACV,QAAAE,CACF,CAAuF,GAEzE,QAChB,CAEA,IAAMK,EAAgB,MAAMF,EAAa,EAEzC,OAAOF,EAAa,aAAa,IAC/B,IACEK,EACE,SAAY,CACLL,EAAa,SAAS,GACzB,MAAMA,EAAa,WAAW,EAGhC,IAAMM,EAAQN,EAAa,UAAU,EACrC,OAAAN,EAAM,UAAWU,EAAc,aAAc,aAAcE,EAAO,KAAMF,EAAc,OAAO,EACtF,MAAMG,EAAmBX,EAAQ,CAAE,MAAAU,EAAO,GAAGF,CAAc,CAAyB,CAC7F,EACA,CACE,QAAS,EACT,gBAAiB,MAAOI,GAAU,CAEhC,GAAIR,EAAa,iBAAiBQ,CAAK,EAAG,CACxCd,EAAM,4BAA6Bc,EAAM,OAAO,EAChD,MAAMR,EAAa,WAAW,EAC9B,OAGF,MAAMQ,CACR,CACF,CACF,EACF,CAAE,eAAgB,EAAK,CACzB,CACF,CDxEA,SAASC,EAAsBC,EAG7B,CACA,IAAMC,EAAUD,EAAO,QAAU,MAAM,QAAQA,EAAO,CAAC,CAAC,EAClDE,EAAOD,EAAUD,EAAO,CAAC,EAAK,CAAC,EAC/BG,GAAWF,EAAUD,EAAO,CAAC,EAAIA,EAAO,CAAC,IAAM,CAAC,EACtD,MAAO,CAAE,KAAAE,EAAM,QAAAC,CAAQ,CACzB,CAsBO,SAASC,EAQd,CACA,IAAAC,EACA,QAAAC,EACA,aAAAC,EACA,aAAAC,EACA,QAAAC,CACF,EAQwE,CACtE,IAAMC,EAAWC,EAA6F,CAC5G,IAAAN,EACA,QAAAC,EACA,aAAAC,EACA,aAAAC,CACF,CAAC,EAED,GAAIE,EAAS,MAAO,CAElB,IAAIE,EAAc,EAClBF,EAAS,MAAQ,IAAI,MACnB,CAAC,EACD,CACE,IAAIG,EAAGC,EAAsB,CAC3B,MAAO,IACFC,IAIA,CACH,GAAM,CAAE,KAAAb,EAAM,QAAAC,CAAQ,EAAIJ,EAAsBgB,CAAU,EACpDC,EAAU,CACd,IAAAX,EACA,QAAAC,EACA,aAAAQ,EACA,KAAAZ,EACA,GAAGC,EACH,QAAAM,CACF,EACMQ,EAASC,EAAcV,EAAcQ,CAAO,EAE5CG,EAAK,GAAGX,EAAa,MAAM,MAAMA,EAAa,QAAQ,WAAWI,MACvE,OAAAH,IAAU,CAAE,GAAAU,EAAI,QAASH,EAAoC,OAAAC,CAAO,CAAC,EAE9DA,CACT,CACF,CACF,CACF,EAGF,OAAOP,CACT,CGlHA,OAAS,sBAAAU,EAAoB,uBAAAC,MAA2B,gBACxD,OAAS,SAAAC,MAAkB,OAE3B,SAASC,EAAiBC,EAAoBC,EAA6C,CACzF,GAAI,CAACH,EAAME,CAAU,EACnB,cAAQ,MAAM,8CAA+C,CAAE,WAAAA,EAAY,SAAAC,CAAS,CAAC,EAC/E,IAAI,MAAM,+BAA+BA,qBAA4B,EAI7EJ,EAAoBG,CAAU,CAChC,CAEO,SAASE,GAAoBD,EAAW,mBAAyB,CACtE,IAAME,EAAmB,aAAa,QAAQF,CAAQ,EAEtD,GAAIE,GAAoB,KACtB,OAAAJ,EAAiBI,EAAkBF,CAAQ,EACpCE,EAGT,IAAMH,EAAaJ,EAAmB,EACtC,eAAQ,IAAI,6BAA8BC,EAAoBG,CAAU,CAAC,EACzE,aAAa,QAAQC,EAAUD,CAAU,EAClCA,CACT,CCzBA,OAAc,eAAAI,EAAa,YAAAC,MAAgB,OCApC,IAAMC,EAAgB,CAAC,QAAS,gBAAiB,YAAa,SAAU,QAAQ,ECAvF,OAAc,eAAAC,EAAa,aAAAC,MAAiB,OAKrC,IAAMC,EAAkB,CAE7B,MAAO,KACP,cAAe,KAEf,UAAW,KACX,OAAQ,KACR,OAAQ,IACV,EAEO,SAASC,EAAcC,EAA6C,CACzE,IAAMC,EAASH,EAAgBE,EAAS,IAAI,EAC5C,OAAOH,EAAU,CACfD,EAAYK,EAAQ,CAAE,KAAM,CAAE,CAAC,EAC/BL,EAAYI,EAAS,UAAU,MAAM,EAAG,EAAE,EAAG,CAAE,KAAM,EAAG,CAAC,EACzDJ,EAAYI,EAAS,KAAK,MAAM,EAAG,EAAE,EAAG,CAAE,KAAM,EAAG,CAAC,CACtD,CAAC,CACH,CFhBA,IAAME,EAAuB,OAAO,YAClC,OAAO,QAAQC,CAAe,EAAE,IAAI,CAAC,CAACC,EAAKC,CAAK,IAAM,CAACA,EAAOD,CAAG,CAAC,CACpE,EAEA,SAASE,EAAgBC,EAAkD,CAEzE,IAAMC,EAAQN,EAA+DK,CAAc,EAC3F,GAAIE,EAAc,SAASD,CAAoB,EAC7C,OAAOA,CAEX,CAEO,SAASE,EAAcC,EAAoB,CAChD,IAAMJ,EAAiBK,EAAYC,EAASF,EAAK,EAAG,CAAC,CAAC,EAAE,QAAQ,OAAQ,EAAE,EACpEH,EAAOF,EAAgBC,CAAc,EACrCO,EAAYF,EAAYC,EAASF,EAAK,EAAG,EAAE,CAAC,EAAE,QAAQ,OAAQ,EAAE,EAChEI,EAAOH,EAAYC,EAASF,EAAK,GAAI,EAAE,CAAC,EAAE,QAAQ,OAAQ,EAAE,EAElE,GAAI,CAACH,EACH,MAAM,IAAI,MAAM,iBAAiBD,oBAAiCA,KAAkBO,KAAaC,IAAO,EAG1G,MAAO,CAAE,WAAYJ,EAAK,KAAAH,EAAM,UAAAM,EAAW,KAAAC,CAAK,CAClD,CGpBO,SAASC,EAAQC,EAAWC,EAAeC,EAAmB,CACnE,MAAO,KAAKF,EACT,QAAQ,MAAO,EAAE,EACjB,MAAMC,EAAQ,EAAGC,GAAO,KAAOA,EAAM,EAAI,MAAS,EAClD,SAASA,GAAOD,GAASA,GAAS,EAAG,GAAG,GAC7C,CCLA,OAAS,QAAAE,GAAM,mBAAmBC,OAA4B,eAC9D,OAAOC,OAAY,UAGnB,OAAS,gBAAAC,OAAoB,gBAE7B,IAAMC,EAAQA,EAAY,OAAO,iBAAiB,EAIlD,eAAsBC,GAKpBC,EACAC,EACkC,CAClC,IAAMC,EAAaD,EAAQ,SAAWD,EAAO,QAC7C,GAAI,CAACE,EAEH,MAAM,IAAI,MAAM,qBAAqB,EAEvC,IAAMC,EAAUN,GAAaK,CAAU,EAEjCE,EAAe,MAAMC,EAAgB,CACzC,OAAAL,EACA,QAASG,EAAQ,QACjB,SAAU,SACZ,CAAC,EAED,eAAeG,GAAgF,CAC7F,OAAIL,EAAQ,KACVH,EAAM,kCAAmCG,EAAQ,EAAE,EAC5CA,IAGTH,EAAM,mBAAoBG,EAAQ,EAAE,EACpC,MAAMM,GAAKP,EAAQ,CACjB,GAAGC,EACH,SAAU,UACV,QAAAE,CACF,CAA2B,EAIpBF,EACT,CAEA,IAAMO,EAAkB,MAAMF,EAAQ,EAEtC,OAAO,MAAMF,EAAa,aAAa,IACrC,IACEK,GACE,SAAY,CACLL,EAAa,SAAS,GACzB,MAAMA,EAAa,WAAW,EAGhC,IAAMM,EAAQN,EAAa,UAAU,EACrC,OAAAN,EAAM,wBAAyBY,EAAO,KAAMF,EAAgB,EAAE,EACvD,MAAMG,GAAqBX,EAAQ,CAAE,MAAAU,EAAO,GAAGF,CAAgB,CAAC,CACzE,EACA,CACE,QAAS,EACT,gBAAiB,MAAOI,GAAU,CAEhC,GAAIR,EAAa,iBAAiBQ,CAAK,EAAG,CACxCd,EAAM,4BAA6Bc,EAAM,OAAO,EAChD,MAAMR,EAAa,WAAW,EAC9B,OAGF,MAAMQ,CACR,CACF,CACF,EACF,CAAE,eAAgB,EAAK,CACzB,CACF,CCxFA,OAAc,aAAAC,OAAiB,OAGxB,SAASC,GAAUC,EAAWC,EAAeC,EAAc,EAAGC,EAAe,KAAW,CAC7F,OAAOC,GAAU,CAACC,EAAQL,EAAM,EAAGC,CAAK,EAAGE,EAASE,EAAQL,EAAMC,EAAQC,CAAW,CAAC,CAAC,CACzF,CCLA,OAAyB,aAAAI,OAAiB,OAG1C,IAAMC,GAAQA,EAAY,OAAO,mBAAmB,EAE7C,SAASC,GAAgDC,EAAmC,CACjG,OAASC,GAAS,CAChB,IAAMC,EAASF,EAAUC,CAAI,EAU7B,MAAO,CACL,GAAGC,EACH,QAXqC,MAAOC,GAAQ,CACpD,GAAIA,EAAI,SAAW,0BAA4BA,EAAI,kBAAkB,MAAO,CAC1E,IAAMC,EAAMD,EAAI,OAAO,IAAKE,GAAcC,GAAUD,CAAI,CAAC,EACzDP,GAAM,UAAWM,CAAG,EAItB,OAAOF,EAAO,QAAQC,CAAG,CAC3B,CAIA,CACF,CACF,CCnBO,IAAMI,GAAiBC,ECAvB,IAAMC,GAAkBC,ECAxB,IAAMC,GAAkBC","names":["privateKeyToAccount","createBurnerAccount","privateKey","BaseError","NonceTooHighError","NonceTooLowError","getAddress","getChainId","getNonceManagerId","client","address","blockTag","getTransactionCount","PQueue","debug","createNonceManager","client","address","blockTag","broadcastChannelName","nonceRef","channel","getNonceManagerId","name","event","nonce","hasNonce","nextNonce","resetNonce","shouldResetNonce","error","BaseError","e","NonceTooLowError","NonceTooHighError","mempoolQueue","viem_getContract","simulateContract","viem_writeContract","pRetry","nonceManagers","getNonceManager","client","address","blockTag","id","getNonceManagerId","existingNonceManager","nonceManager","createNonceManager","parseAccount","debug","writeContract","client","request","rawAccount","account","nonceManager","getNonceManager","prepareWrite","simulateContract","preparedWrite","pRetry","nonce","viem_writeContract","error","getFunctionParameters","values","hasArgs","args","options","getContract","abi","address","publicClient","walletClient","onWrite","contract","viem_getContract","nextWriteId","_","functionName","parameters","request","result","writeContract","id","generatePrivateKey","privateKeyToAccount","isHex","assertPrivateKey","privateKey","cacheKey","getBurnerPrivateKey","cachedPrivateKey","hexToString","sliceHex","resourceTypes","stringToHex","concatHex","resourceTypeIds","resourceToHex","resource","typeId","resourceTypeIdToType","resourceTypeIds","key","value","getResourceType","resourceTypeId","type","resourceTypes","hexToResource","hex","hexToString","sliceHex","namespace","name","readHex","data","start","end","call","viem_sendTransaction","pRetry","parseAccount","debug","sendTransaction","client","request","rawAccount","account","nonceManager","getNonceManager","prepare","call","preparedRequest","pRetry","nonce","viem_sendTransaction","error","concatHex","spliceHex","data","start","deleteCount","newData","concatHex","readHex","keccak256","debug","transportObserver","transport","opts","result","req","txs","data","keccak256","createContract","getContract","resourceIdToHex","resourceToHex","hexToResourceId","hexToResource"]}