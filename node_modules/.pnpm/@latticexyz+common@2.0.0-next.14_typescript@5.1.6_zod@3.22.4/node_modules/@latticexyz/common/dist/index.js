import{a as u}from"./chunk-7WIPV3R3.js";import{privateKeyToAccount as $}from"viem/accounts";function me(t){return{...$(t)}}import{BaseError as B,NonceTooHighError as F,NonceTooLowError as G}from"viem";import{getAddress as E}from"viem";import{getChainId as S}from"viem/actions";async function T({client:t,address:e,blockTag:r}){return`mud:createNonceManager:${t.chain?.id??await S(t)}:${E(e)}:${r}`}import{getTransactionCount as Q}from"viem/actions";import _ from"p-queue";var P=u.extend("createNonceManager");function R({client:t,address:e,blockTag:r="pending",broadcastChannelName:o}){let n={current:-1},a=null;typeof BroadcastChannel<"u"&&(o?Promise.resolve(o):T({client:t,address:e,blockTag:r})).then(p=>{a=new BroadcastChannel(p),a.addEventListener("message",m=>{let d=JSON.parse(m.data);P("got nonce from broadcast channel",d),n.current=d})});function s(){return n.current>=0}function c(){if(!s())throw new Error("call resetNonce before using nextNonce");let i=n.current++;return a?.postMessage(JSON.stringify(n.current)),i}async function C(){let i=await Q(t,{address:e,blockTag:r});n.current=i,a?.postMessage(JSON.stringify(n.current)),P("reset nonce to",n.current)}function g(i){return i instanceof B&&i.walk(p=>p instanceof G||p instanceof F)!=null}let h=new _({concurrency:1});return{hasNonce:s,nextNonce:c,resetNonce:C,shouldResetNonce:g,mempoolQueue:h}}import{getContract as K}from"viem";import{simulateContract as j,writeContract as D}from"viem/actions";import z from"p-retry";var H=new Map;async function l({client:t,address:e,blockTag:r="pending"}){let o=await T({client:t,address:e,blockTag:r}),n=H.get(o);if(n)return n;let a=R({client:t,address:e,blockTag:r});return H.set(o,a),a}import{parseAccount as J}from"viem/accounts";var f=u.extend("writeContract");async function v(t,e){let r=e.account??t.account;if(!r)throw new Error("No account provided");let o=J(r),n=await l({client:t,address:o.address,blockTag:"pending"});async function a(){return e.gas?(f("gas provided, skipping simulate",e.functionName,e.address),e):(f("simulating",e.functionName,"at",e.address),(await j(t,{...e,blockTag:"pending",account:o})).request)}let s=await a();return n.mempoolQueue.add(()=>z(async()=>{n.hasNonce()||await n.resetNonce();let c=n.nextNonce();return f("calling",s.functionName,"with nonce",c,"at",s.address),await D(t,{nonce:c,...s})},{retries:3,onFailedAttempt:async c=>{if(n.shouldResetNonce(c)){f("got nonce error, retrying",c.message),await n.resetNonce();return}throw c}}),{throwOnTimeout:!0})}function U(t){let e=t.length&&Array.isArray(t[0]),r=e?t[0]:[],o=(e?t[1]:t[0])??{};return{args:r,options:o}}function W({abi:t,address:e,publicClient:r,walletClient:o,onWrite:n}){let a=K({abi:t,address:e,publicClient:r,walletClient:o});if(a.write){let s=0;a.write=new Proxy({},{get(c,C){return(...g)=>{let{args:h,options:i}=U(g),p={abi:t,address:e,functionName:C,args:h,...i,onWrite:n},m=v(o,p),d=`${o.chain.id}:${o.account.address}:${s++}`;return n?.({id:d,request:p,result:m}),m}}})}return a}import{generatePrivateKey as L,privateKeyToAccount as M}from"viem/accounts";import{isHex as V}from"viem";function X(t,e){if(!V(t))throw console.error("Private key found in cache is not valid hex",{privateKey:t,cacheKey:e}),new Error(`Private key found in cache (${e}) is not valid hex`);M(t)}function nt(t="mud:burnerWallet"){let e=localStorage.getItem(t);if(e!=null)return X(e,t),e;let r=L();return console.log("New burner wallet created:",M(r)),localStorage.setItem(t,r),r}import{hexToString as A,sliceHex as w}from"viem";var k=["table","offchainTable","namespace","module","system"];import{stringToHex as y,concatHex as Y}from"viem";var b={table:"tb",offchainTable:"ot",namespace:"ns",module:"md",system:"sy"};function O(t){let e=b[t.type];return Y([y(e,{size:2}),y(t.namespace.slice(0,14),{size:14}),y(t.name.slice(0,16),{size:16})])}var Z=Object.fromEntries(Object.entries(b).map(([t,e])=>[e,t]));function q(t){let e=Z[t];if(k.includes(e))return e}function I(t){let e=A(w(t,0,2)).replace(/\0+$/,""),r=q(e),o=A(w(t,2,16)).replace(/\0+$/,""),n=A(w(t,16,32)).replace(/\0+$/,"");if(!r)throw new Error(`Unknown type (${e}) for resource (${e}:${o}:${n})`);return{resourceId:t,type:r,namespace:o,name:n}}function N(t,e,r){return`0x${t.replace(/^0x/,"").slice(e*2,r!=null?r*2:void 0).padEnd(((r??e)-e)*2,"0")}`}import{call as ee,sendTransaction as te}from"viem/actions";import ne from"p-retry";import{parseAccount as re}from"viem/accounts";var x=u.extend("sendTransaction");async function yt(t,e){let r=e.account??t.account;if(!r)throw new Error("No account provided");let o=re(r),n=await l({client:t,address:o.address,blockTag:"pending"});async function a(){return e.gas?(x("gas provided, skipping simulate",e.to),e):(x("simulating tx to",e.to),await ee(t,{...e,blockTag:"pending",account:o}),e)}let s=await a();return await n.mempoolQueue.add(()=>ne(async()=>{n.hasNonce()||await n.resetNonce();let c=n.nextNonce();return x("sending tx with nonce",c,"to",s.to),await te(t,{nonce:c,...s})},{retries:3,onFailedAttempt:async c=>{if(n.shouldResetNonce(c)){x("got nonce error, retrying",c.message),await n.resetNonce();return}throw c}}),{throwOnTimeout:!0})}import{concatHex as oe}from"viem";function Pt(t,e,r=0,o="0x"){return oe([N(t,0,e),o,N(t,e+r)])}import{keccak256 as ae}from"viem";var ce=u.extend("transportObserver");function kt(t){return e=>{let r=t(e);return{...r,request:async n=>{if(n.method==="eth_sendRawTransaction"&&n.params instanceof Array){let a=n.params.map(s=>ae(s));ce("saw txs",a)}return r.request(n)}}}}var se=W;var ie=O;var ue=I;export{me as createBurnerAccount,se as createContract,R as createNonceManager,nt as getBurnerPrivateKey,W as getContract,l as getNonceManager,T as getNonceManagerId,I as hexToResource,ue as hexToResourceId,N as readHex,ie as resourceIdToHex,O as resourceToHex,b as resourceTypeIds,k as resourceTypes,yt as sendTransaction,Pt as spliceHex,kt as transportObserver,v as writeContract};
//# sourceMappingURL=index.js.map