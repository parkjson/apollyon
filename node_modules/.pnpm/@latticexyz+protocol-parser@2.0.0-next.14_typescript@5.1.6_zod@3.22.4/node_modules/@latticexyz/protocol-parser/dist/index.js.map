{"version":3,"sources":["../src/abiTypesToSchema.ts","../src/decodeDynamicField.ts","../src/decodeStaticField.ts","../src/errors.ts","../src/decodeField.ts","../src/decodeKeyTuple.ts","../src/decodeKey.ts","../src/decodeRecord.ts","../src/hexToPackedCounter.ts","../src/staticDataLength.ts","../src/decodeValue.ts","../src/decodeValueArgs.ts","../src/encodeField.ts","../src/encodeKey.ts","../src/encodeKeyTuple.ts","../src/encodeRecord.ts","../src/encodeValue.ts","../src/encodeValueArgs.ts","../src/encodeLengths.ts","../src/fieldLayoutToHex.ts","../src/hexToSchema.ts","../src/hexToTableSchema.ts","../src/keySchemaToHex.ts","../src/schemaToHex.ts","../src/schemaIndexToAbiType.ts","../src/valueSchemaToFieldLayoutHex.ts","../src/valueSchemaToHex.ts"],"sourcesContent":["import { DynamicAbiType, SchemaAbiType, StaticAbiType, isDynamicAbiType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\nexport function abiTypesToSchema(abiTypes: SchemaAbiType[]): Schema {\n  const staticFields: StaticAbiType[] = [];\n  const dynamicFields: DynamicAbiType[] = [];\n  for (const abiType of abiTypes) {\n    if (isDynamicAbiType(abiType)) dynamicFields.push(abiType);\n    else staticFields.push(abiType);\n  }\n  return { staticFields, dynamicFields };\n}\n","import { Hex, hexToString, sliceHex } from \"viem\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport {\n  DynamicAbiType,\n  DynamicAbiTypeToPrimitiveType,\n  arrayAbiTypeToStaticAbiType,\n  staticAbiTypeToByteLength,\n} from \"@latticexyz/schema-type\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { InvalidHexLengthError, InvalidHexLengthForArrayFieldError } from \"./errors\";\n\n// TODO: require size/length for dynamic fields, because hex might be longer (sometimes we just move the length pointer of arrays without updating the value)\n//       this means the error should probably change from \"invalid length\" to \"too short\", which viem has that we could reuse?\n\nexport function decodeDynamicField<\n  TAbiType extends DynamicAbiType,\n  TPrimitiveType extends DynamicAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  if (abiType === \"bytes\") {\n    return data as TPrimitiveType;\n  }\n  if (abiType === \"string\") {\n    return hexToString(data) as TPrimitiveType;\n  }\n\n  if (data.length > 3 && data.length % 2 !== 0) {\n    throw new InvalidHexLengthError(data);\n  }\n\n  const dataSize = (data.length - 2) / 2;\n\n  switch (abiType) {\n    case \"uint8[]\":\n    case \"uint16[]\":\n    case \"uint24[]\":\n    case \"uint32[]\":\n    case \"uint40[]\":\n    case \"uint48[]\":\n    case \"uint56[]\":\n    case \"uint64[]\":\n    case \"uint72[]\":\n    case \"uint80[]\":\n    case \"uint88[]\":\n    case \"uint96[]\":\n    case \"uint104[]\":\n    case \"uint112[]\":\n    case \"uint120[]\":\n    case \"uint128[]\":\n    case \"uint136[]\":\n    case \"uint144[]\":\n    case \"uint152[]\":\n    case \"uint160[]\":\n    case \"uint168[]\":\n    case \"uint176[]\":\n    case \"uint184[]\":\n    case \"uint192[]\":\n    case \"uint200[]\":\n    case \"uint208[]\":\n    case \"uint216[]\":\n    case \"uint224[]\":\n    case \"uint232[]\":\n    case \"uint240[]\":\n    case \"uint248[]\":\n    case \"uint256[]\":\n    case \"int8[]\":\n    case \"int16[]\":\n    case \"int24[]\":\n    case \"int32[]\":\n    case \"int40[]\":\n    case \"int48[]\":\n    case \"int56[]\":\n    case \"int64[]\":\n    case \"int72[]\":\n    case \"int80[]\":\n    case \"int88[]\":\n    case \"int96[]\":\n    case \"int104[]\":\n    case \"int112[]\":\n    case \"int120[]\":\n    case \"int128[]\":\n    case \"int136[]\":\n    case \"int144[]\":\n    case \"int152[]\":\n    case \"int160[]\":\n    case \"int168[]\":\n    case \"int176[]\":\n    case \"int184[]\":\n    case \"int192[]\":\n    case \"int200[]\":\n    case \"int208[]\":\n    case \"int216[]\":\n    case \"int224[]\":\n    case \"int232[]\":\n    case \"int240[]\":\n    case \"int248[]\":\n    case \"int256[]\":\n    case \"bytes1[]\":\n    case \"bytes2[]\":\n    case \"bytes3[]\":\n    case \"bytes4[]\":\n    case \"bytes5[]\":\n    case \"bytes6[]\":\n    case \"bytes7[]\":\n    case \"bytes8[]\":\n    case \"bytes9[]\":\n    case \"bytes10[]\":\n    case \"bytes11[]\":\n    case \"bytes12[]\":\n    case \"bytes13[]\":\n    case \"bytes14[]\":\n    case \"bytes15[]\":\n    case \"bytes16[]\":\n    case \"bytes17[]\":\n    case \"bytes18[]\":\n    case \"bytes19[]\":\n    case \"bytes20[]\":\n    case \"bytes21[]\":\n    case \"bytes22[]\":\n    case \"bytes23[]\":\n    case \"bytes24[]\":\n    case \"bytes25[]\":\n    case \"bytes26[]\":\n    case \"bytes27[]\":\n    case \"bytes28[]\":\n    case \"bytes29[]\":\n    case \"bytes30[]\":\n    case \"bytes31[]\":\n    case \"bytes32[]\":\n    case \"bool[]\":\n    case \"address[]\": {\n      const staticAbiType = arrayAbiTypeToStaticAbiType(abiType);\n      const itemByteLength = staticAbiTypeToByteLength[staticAbiType];\n      if (dataSize % itemByteLength !== 0) {\n        throw new InvalidHexLengthForArrayFieldError(staticAbiType, data);\n      }\n      const items = new Array(dataSize / itemByteLength).fill(undefined).map((_, i) => {\n        const itemData = sliceHex(data, i * itemByteLength, (i + 1) * itemByteLength);\n        return decodeStaticField(staticAbiType, itemData);\n      });\n      return items as TPrimitiveType;\n    }\n  }\n\n  return assertExhaustive(abiType, `Unsupported dynamic ABI type: ${abiType}`);\n}\n","import { Hex, getAddress, hexToBigInt, hexToBool } from \"viem\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport {\n  StaticAbiType,\n  StaticAbiTypeToPrimitiveType,\n  staticAbiTypeToByteLength,\n  staticAbiTypeToDefaultValue,\n} from \"@latticexyz/schema-type\";\nimport { InvalidHexLengthError, InvalidHexLengthForStaticFieldError } from \"./errors\";\n\nexport function decodeStaticField<\n  TAbiType extends StaticAbiType,\n  TPrimitiveType extends StaticAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  if (data.length > 3 && data.length % 2 !== 0) {\n    throw new InvalidHexLengthError(data);\n  }\n\n  const dataSize = (data.length - 2) / 2;\n  if (dataSize !== staticAbiTypeToByteLength[abiType]) {\n    throw new InvalidHexLengthForStaticFieldError(abiType, data);\n  }\n\n  switch (abiType) {\n    case \"uint8\":\n    case \"uint16\":\n    case \"uint24\":\n    case \"uint32\":\n    case \"uint40\":\n    case \"uint48\":\n    case \"uint56\":\n    case \"uint64\":\n    case \"uint72\":\n    case \"uint80\":\n    case \"uint88\":\n    case \"uint96\":\n    case \"uint104\":\n    case \"uint112\":\n    case \"uint120\":\n    case \"uint128\":\n    case \"uint136\":\n    case \"uint144\":\n    case \"uint152\":\n    case \"uint160\":\n    case \"uint168\":\n    case \"uint176\":\n    case \"uint184\":\n    case \"uint192\":\n    case \"uint200\":\n    case \"uint208\":\n    case \"uint216\":\n    case \"uint224\":\n    case \"uint232\":\n    case \"uint240\":\n    case \"uint248\":\n    case \"uint256\":\n    case \"int8\":\n    case \"int16\":\n    case \"int24\":\n    case \"int32\":\n    case \"int40\":\n    case \"int48\":\n    case \"int56\":\n    case \"int64\":\n    case \"int72\":\n    case \"int80\":\n    case \"int88\":\n    case \"int96\":\n    case \"int104\":\n    case \"int112\":\n    case \"int120\":\n    case \"int128\":\n    case \"int136\":\n    case \"int144\":\n    case \"int152\":\n    case \"int160\":\n    case \"int168\":\n    case \"int176\":\n    case \"int184\":\n    case \"int192\":\n    case \"int200\":\n    case \"int208\":\n    case \"int216\":\n    case \"int224\":\n    case \"int232\":\n    case \"int240\":\n    case \"int248\":\n    case \"int256\": {\n      const value = hexToBigInt(data, { signed: abiType.startsWith(\"int\") });\n      const defaultValueType = typeof staticAbiTypeToDefaultValue[abiType];\n      if (defaultValueType === \"number\") {\n        return Number(value) as TPrimitiveType;\n      }\n      if (defaultValueType === \"bigint\") {\n        return value as TPrimitiveType;\n      }\n      throw new Error(`Unexpected default value type (${defaultValueType}) for ABI type (${abiType})`);\n    }\n\n    case \"bytes1\":\n    case \"bytes2\":\n    case \"bytes3\":\n    case \"bytes4\":\n    case \"bytes5\":\n    case \"bytes6\":\n    case \"bytes7\":\n    case \"bytes8\":\n    case \"bytes9\":\n    case \"bytes10\":\n    case \"bytes11\":\n    case \"bytes12\":\n    case \"bytes13\":\n    case \"bytes14\":\n    case \"bytes15\":\n    case \"bytes16\":\n    case \"bytes17\":\n    case \"bytes18\":\n    case \"bytes19\":\n    case \"bytes20\":\n    case \"bytes21\":\n    case \"bytes22\":\n    case \"bytes23\":\n    case \"bytes24\":\n    case \"bytes25\":\n    case \"bytes26\":\n    case \"bytes27\":\n    case \"bytes28\":\n    case \"bytes29\":\n    case \"bytes30\":\n    case \"bytes31\":\n    case \"bytes32\": {\n      return data as TPrimitiveType;\n    }\n\n    case \"bool\": {\n      return hexToBool(data) as TPrimitiveType;\n    }\n\n    case \"address\": {\n      return getAddress(data) as TPrimitiveType;\n    }\n  }\n\n  return assertExhaustive(abiType, `Unsupported static ABI type: ${abiType}`);\n}\n","import { Hex } from \"viem\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { StaticAbiType, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\n\nexport class InvalidHexLengthError extends MUDError {\n  override name = \"InvalidHexValueError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" is an odd length (${value.length - 2}). It must be an even length.`);\n  }\n}\n\nexport class InvalidHexLengthForSchemaError extends MUDError {\n  override name = \"InvalidHexLengthForSchemaError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" has length of ${value.length - 2}, but expected length of 64 for a schema.`);\n  }\n}\n\nexport class InvalidHexLengthForPackedCounterError extends MUDError {\n  override name = \"InvalidHexLengthForPackedCounterError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" has length of ${value.length - 2}, but expected length of 64 for a packed counter.`);\n  }\n}\n\nexport class InvalidHexLengthForStaticFieldError extends MUDError {\n  override name = \"InvalidHexLengthForStaticFieldError\";\n  constructor(abiType: StaticAbiType, value: Hex) {\n    super(\n      `Hex value \"${value}\" has length of ${value.length - 2}, but expected length of ${\n        staticAbiTypeToByteLength[abiType] * 2\n      } for ${abiType} type.`\n    );\n  }\n}\n\nexport class InvalidHexLengthForArrayFieldError extends MUDError {\n  override name = \"InvalidHexLengthForArrayFieldError\";\n  constructor(abiType: StaticAbiType, value: Hex) {\n    super(\n      `Hex value \"${value}\" has length of ${value.length - 2}, but expected a multiple of ${\n        staticAbiTypeToByteLength[abiType] * 2\n      } for ${abiType}[] type.`\n    );\n  }\n}\n\nexport class SchemaStaticLengthMismatchError extends MUDError {\n  override name = \"SchemaStaticLengthMismatchError\";\n  constructor(schemaData: Hex, definedLength: number, summedLength: number) {\n    super(\n      `Schema \"${schemaData}\" static data length (${definedLength}) did not match the summed length of all static fields (${summedLength}). ` +\n        `Is \\`staticAbiTypeToByteLength\\` up to date with Solidity schema types?`\n    );\n  }\n}\n\nexport class PackedCounterLengthMismatchError extends MUDError {\n  override name = \"PackedCounterLengthMismatchError\";\n  constructor(packedCounterData: Hex, definedLength: bigint, summedLength: bigint) {\n    super(\n      `PackedCounter \"${packedCounterData}\" total bytes length (${definedLength}) did not match the summed length of all field byte lengths (${summedLength}).`\n    );\n  }\n}\n","import { Hex } from \"viem\";\nimport { SchemaAbiType, SchemaAbiTypeToPrimitiveType, isDynamicAbiType } from \"@latticexyz/schema-type\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { decodeStaticField } from \"./decodeStaticField\";\n\nexport function decodeField<\n  TAbiType extends SchemaAbiType,\n  TPrimitiveType extends SchemaAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  return (\n    isDynamicAbiType(abiType) ? decodeDynamicField(abiType, data) : decodeStaticField(abiType, data)\n  ) as TPrimitiveType;\n}\n","import { Hex, decodeAbiParameters } from \"viem\";\nimport { StaticPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\n// key tuples are encoded in the same way as abi.encode, so we can decode them with viem\n\n/** @deprecated use `decodeKey` instead */\nexport function decodeKeyTuple(keySchema: Schema, keyTuple: readonly Hex[]): StaticPrimitiveType[] {\n  if (keySchema.staticFields.length !== keyTuple.length) {\n    throw new Error(\n      `key tuple length ${keyTuple.length} does not match key schema length ${keySchema.staticFields.length}`\n    );\n  }\n  return keyTuple.map(\n    (key, index) => decodeAbiParameters([{ type: keySchema.staticFields[index] }], key)[0] as StaticPrimitiveType\n  );\n}\n","import { Hex } from \"viem\";\nimport { SchemaToPrimitives, KeySchema } from \"./common\";\nimport { decodeKeyTuple } from \"./decodeKeyTuple\";\n\nexport function decodeKey<TSchema extends KeySchema>(\n  keySchema: TSchema,\n  data: readonly Hex[]\n): SchemaToPrimitives<TSchema> {\n  // TODO: refactor and move all decodeKeyTuple logic into this method so we can delete decodeKeyTuple\n  const keyValues = decodeKeyTuple({ staticFields: Object.values(keySchema), dynamicFields: [] }, data);\n\n  return Object.fromEntries(\n    Object.keys(keySchema).map((name, i) => [name, keyValues[i]])\n  ) as SchemaToPrimitives<TSchema>;\n}\n","import {\n  StaticPrimitiveType,\n  DynamicPrimitiveType,\n  staticAbiTypeToByteLength,\n  dynamicAbiTypeToDefaultValue,\n} from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { hexToPackedCounter } from \"./hexToPackedCounter\";\nimport { staticDataLength } from \"./staticDataLength\";\nimport { readHex } from \"@latticexyz/common\";\n\n/** @deprecated use `decodeValue` instead */\nexport function decodeRecord(valueSchema: Schema, data: Hex): readonly (StaticPrimitiveType | DynamicPrimitiveType)[] {\n  const values: (StaticPrimitiveType | DynamicPrimitiveType)[] = [];\n\n  let bytesOffset = 0;\n  valueSchema.staticFields.forEach((fieldType) => {\n    const fieldByteLength = staticAbiTypeToByteLength[fieldType];\n    const value = decodeStaticField(fieldType, readHex(data, bytesOffset, bytesOffset + fieldByteLength));\n    bytesOffset += fieldByteLength;\n    values.push(value);\n  });\n\n  // Warn user if static data length doesn't match the value schema, because data corruption might be possible.\n  const schemaStaticDataLength = staticDataLength(valueSchema.staticFields);\n  const actualStaticDataLength = bytesOffset;\n  if (actualStaticDataLength !== schemaStaticDataLength) {\n    console.warn(\n      \"Decoded static data length does not match value schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?\",\n      {\n        expectedLength: schemaStaticDataLength,\n        actualLength: actualStaticDataLength,\n        bytesOffset,\n      }\n    );\n  }\n\n  if (valueSchema.dynamicFields.length > 0) {\n    const dataLayout = hexToPackedCounter(readHex(data, bytesOffset, bytesOffset + 32));\n    bytesOffset += 32;\n\n    valueSchema.dynamicFields.forEach((fieldType, i) => {\n      const dataLength = dataLayout.fieldByteLengths[i];\n      if (dataLength > 0) {\n        const value = decodeDynamicField(fieldType, readHex(data, bytesOffset, bytesOffset + dataLength));\n        bytesOffset += dataLength;\n        values.push(value);\n      } else {\n        values.push(dynamicAbiTypeToDefaultValue[fieldType]);\n      }\n    });\n\n    // Warn user if dynamic data length doesn't match the dynamic data length, because data corruption might be possible.\n    const actualDynamicDataLength = bytesOffset - 32 - actualStaticDataLength;\n    // TODO: refactor this so we don't break for bytes offsets >UINT40\n    if (BigInt(actualDynamicDataLength) !== dataLayout.totalByteLength) {\n      console.warn(\n        \"Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?\",\n        {\n          expectedLength: dataLayout.totalByteLength,\n          actualLength: actualDynamicDataLength,\n          bytesOffset,\n        }\n      );\n    }\n  }\n\n  return values;\n}\n","import { Hex } from \"viem\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { InvalidHexLengthForPackedCounterError, PackedCounterLengthMismatchError } from \"./errors\";\nimport { readHex } from \"@latticexyz/common\";\n\n// Keep this logic in sync with PackedCounter.sol\n\n// - Last 7 bytes (uint56) are used for the total byte length of the dynamic data\n// - The next 5 byte (uint40) sections are used for the byte length of each field, indexed from right to left\n\n// We use byte lengths rather than item counts so that, on chain, we can slice without having to get the value schema first (and thus the field lengths of each dynamic type)\n\nexport function hexToPackedCounter(data: Hex): {\n  totalByteLength: bigint;\n  fieldByteLengths: readonly number[];\n} {\n  if (data.length !== 66) {\n    throw new InvalidHexLengthForPackedCounterError(data);\n  }\n\n  const totalByteLength = decodeStaticField(\"uint56\", readHex(data, 32 - 7, 32));\n  // TODO: use value schema to make sure we only parse as many as we need (rather than zeroes at the end)?\n  const reversedFieldByteLengths = decodeDynamicField(\"uint40[]\", readHex(data, 0, 32 - 7));\n  // Reverse the lengths\n  const fieldByteLengths = Object.freeze([...reversedFieldByteLengths].reverse());\n\n  const summedLength = BigInt(fieldByteLengths.reduce((total, length) => total + length, 0));\n  if (summedLength !== totalByteLength) {\n    throw new PackedCounterLengthMismatchError(data, totalByteLength, summedLength);\n  }\n\n  return { totalByteLength, fieldByteLengths };\n}\n","import { StaticAbiType, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\n\nexport function staticDataLength(staticFields: readonly StaticAbiType[]): number {\n  return staticFields.reduce((length, fieldType) => length + staticAbiTypeToByteLength[fieldType], 0);\n}\n","import { isStaticAbiType, isDynamicAbiType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { SchemaToPrimitives, ValueSchema } from \"./common\";\nimport { decodeRecord } from \"./decodeRecord\";\n\nexport function decodeValue<TSchema extends ValueSchema>(valueSchema: TSchema, data: Hex): SchemaToPrimitives<TSchema> {\n  const staticFields = Object.values(valueSchema).filter(isStaticAbiType);\n  const dynamicFields = Object.values(valueSchema).filter(isDynamicAbiType);\n\n  // TODO: refactor and move all decodeRecord logic into this method so we can delete decodeRecord\n  const valueTuple = decodeRecord({ staticFields, dynamicFields }, data);\n\n  return Object.fromEntries(\n    Object.keys(valueSchema).map((name, i) => [name, valueTuple[i]])\n  ) as SchemaToPrimitives<TSchema>;\n}\n","import { concatHex } from \"viem\";\nimport { isStaticAbiType } from \"@latticexyz/schema-type\";\nimport { SchemaToPrimitives, ValueArgs, ValueSchema } from \"./common\";\nimport { decodeValue } from \"./decodeValue\";\nimport { staticDataLength } from \"./staticDataLength\";\nimport { readHex } from \"@latticexyz/common\";\n\nexport function decodeValueArgs<TSchema extends ValueSchema>(\n  valueSchema: TSchema,\n  { staticData, encodedLengths, dynamicData }: ValueArgs\n): SchemaToPrimitives<TSchema> {\n  return decodeValue(\n    valueSchema,\n    concatHex([\n      readHex(staticData, 0, staticDataLength(Object.values(valueSchema).filter(isStaticAbiType))),\n      encodedLengths,\n      dynamicData,\n    ])\n  );\n}\n","import { SchemaAbiType, arrayAbiTypeToStaticAbiType, isArrayAbiType } from \"@latticexyz/schema-type\";\nimport { AbiParameterToPrimitiveType } from \"abitype\";\nimport { Hex, encodePacked } from \"viem\";\n\nexport function encodeField<TSchemaAbiType extends SchemaAbiType>(\n  fieldType: TSchemaAbiType,\n  value: AbiParameterToPrimitiveType<{ type: TSchemaAbiType }>\n): Hex {\n  if (isArrayAbiType(fieldType) && Array.isArray(value)) {\n    const staticFieldType = arrayAbiTypeToStaticAbiType(fieldType);\n    // TODO: we can remove conditional once this is fixed: https://github.com/wagmi-dev/viem/pull/1147\n    return value.length === 0\n      ? \"0x\"\n      : encodePacked(\n          value.map(() => staticFieldType),\n          value\n        );\n  }\n  return encodePacked([fieldType], [value]);\n}\n","import { isStaticAbiType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { SchemaToPrimitives, KeySchema } from \"./common\";\nimport { encodeKeyTuple } from \"./encodeKeyTuple\";\n\nexport function encodeKey<TSchema extends KeySchema>(keySchema: TSchema, key: SchemaToPrimitives<TSchema>): Hex[] {\n  const staticFields = Object.values(keySchema).filter(isStaticAbiType);\n  // TODO: refactor and move all encodeKeyTuple logic into this method so we can delete encodeKeyTuple\n  return encodeKeyTuple({ staticFields, dynamicFields: [] }, Object.values(key));\n}\n","import { StaticPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Hex, encodeAbiParameters } from \"viem\";\nimport { Schema } from \"./common\";\n\n/** @deprecated use `encodeKey` instead */\nexport function encodeKeyTuple(keySchema: Schema, keyTuple: StaticPrimitiveType[]): Hex[] {\n  return keyTuple.map((key, index) => encodeAbiParameters([{ type: keySchema.staticFields[index] }], [key]));\n}\n","import { StaticPrimitiveType, DynamicPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { encodeField } from \"./encodeField\";\nimport { Schema } from \"./common\";\n\n/** @deprecated use `encodeValue` instead */\nexport function encodeRecord(\n  valueSchema: Schema,\n  values: readonly (StaticPrimitiveType | DynamicPrimitiveType)[]\n): Hex {\n  const staticValues = values.slice(0, valueSchema.staticFields.length) as readonly StaticPrimitiveType[];\n  const dynamicValues = values.slice(valueSchema.staticFields.length) as readonly DynamicPrimitiveType[];\n\n  const staticData = staticValues\n    .map((value, i) => encodeField(valueSchema.staticFields[i], value).replace(/^0x/, \"\"))\n    .join(\"\");\n\n  if (valueSchema.dynamicFields.length === 0) return `0x${staticData}`;\n\n  const dynamicDataItems = dynamicValues.map((value, i) =>\n    encodeField(valueSchema.dynamicFields[i], value).replace(/^0x/, \"\")\n  );\n\n  const dynamicFieldByteLengths = dynamicDataItems.map((value) => value.length / 2).reverse();\n  const dynamicTotalByteLength = dynamicFieldByteLengths.reduce((total, length) => total + BigInt(length), 0n);\n\n  const dynamicData = dynamicDataItems.join(\"\");\n\n  const packedCounter = `${dynamicFieldByteLengths\n    .map((length) => encodeField(\"uint40\", length).replace(/^0x/, \"\"))\n    .join(\"\")}${encodeField(\"uint56\", dynamicTotalByteLength).replace(/^0x/, \"\")}`.padStart(64, \"0\");\n\n  return `0x${staticData}${packedCounter}${dynamicData}`;\n}\n","import { Hex, concatHex } from \"viem\";\nimport { SchemaToPrimitives, ValueSchema } from \"./common\";\nimport { encodeValueArgs } from \"./encodeValueArgs\";\n\nexport function encodeValue<TSchema extends ValueSchema>(\n  valueSchema: TSchema,\n  value: SchemaToPrimitives<TSchema>\n): Hex {\n  const { staticData, encodedLengths, dynamicData } = encodeValueArgs(valueSchema, value);\n  return concatHex([staticData, encodedLengths, dynamicData]);\n}\n","import {\n  StaticPrimitiveType,\n  DynamicPrimitiveType,\n  isStaticAbiType,\n  isDynamicAbiType,\n  StaticAbiType,\n  DynamicAbiType,\n} from \"@latticexyz/schema-type\";\nimport { concatHex } from \"viem\";\nimport { encodeField } from \"./encodeField\";\nimport { SchemaToPrimitives, ValueArgs, ValueSchema } from \"./common\";\nimport { encodeLengths } from \"./encodeLengths\";\n\nexport function encodeValueArgs<TSchema extends ValueSchema>(\n  valueSchema: TSchema,\n  value: SchemaToPrimitives<TSchema>\n): ValueArgs {\n  const valueSchemaEntries = Object.entries(valueSchema);\n  const staticFields = valueSchemaEntries.filter(([, type]) => isStaticAbiType(type)) as [string, StaticAbiType][];\n  const dynamicFields = valueSchemaEntries.filter(([, type]) => isDynamicAbiType(type)) as [string, DynamicAbiType][];\n  // TODO: validate <=5 dynamic fields\n  // TODO: validate <=28 total fields\n\n  const encodedStaticValues = staticFields.map(([name, type]) => encodeField(type, value[name] as StaticPrimitiveType));\n  const encodedDynamicValues = dynamicFields.map(([name, type]) =>\n    encodeField(type, value[name] as DynamicPrimitiveType)\n  );\n\n  const encodedLengths = encodeLengths(encodedDynamicValues);\n\n  return {\n    staticData: concatHex(encodedStaticValues),\n    encodedLengths,\n    dynamicData: concatHex(encodedDynamicValues),\n  };\n}\n","import { Hex, concatHex, padHex, size } from \"viem\";\nimport { encodeField } from \"./encodeField\";\n\nexport function encodeLengths(values: Hex[]): Hex {\n  const byteLengths = values.map(size).reverse();\n  const totalByteLength = byteLengths.reduce((total, length) => total + BigInt(length), 0n);\n\n  return padHex(\n    concatHex([...byteLengths.map((length) => encodeField(\"uint40\", length)), encodeField(\"uint56\", totalByteLength)]),\n    { size: 32, dir: \"left\" }\n  );\n}\n","import { Hex } from \"viem\";\nimport { FieldLayout } from \"./common\";\n\n/** @deprecated use `valueSchemaToFieldLayoutHex` instead */\nexport function fieldLayoutToHex(fieldLayout: FieldLayout): Hex {\n  const staticDataLength = fieldLayout.staticFieldLengths.reduce((totalLength, length) => totalLength + length, 0);\n  return `0x${[\n    staticDataLength.toString(16).padStart(4, \"0\"),\n    fieldLayout.staticFieldLengths.length.toString(16).padStart(2, \"0\"),\n    fieldLayout.numDynamicFields.toString(16).padStart(2, \"0\"),\n    ...fieldLayout.staticFieldLengths.map((schemaType) => schemaType.toString(16).padStart(2, \"0\")),\n  ]\n    .join(\"\")\n    .padEnd(64, \"0\")}`;\n}\n","import { StaticAbiType, DynamicAbiType, schemaAbiTypes, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\nimport { Hex, hexToNumber, sliceHex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { InvalidHexLengthForSchemaError, SchemaStaticLengthMismatchError } from \"./errors\";\n\nexport function hexToSchema(data: Hex): Schema {\n  if (data.length !== 66) {\n    throw new InvalidHexLengthForSchemaError(data);\n  }\n\n  const staticDataLength = hexToNumber(sliceHex(data, 0, 2));\n  const numStaticFields = hexToNumber(sliceHex(data, 2, 3));\n  const numDynamicFields = hexToNumber(sliceHex(data, 3, 4));\n  const staticFields: StaticAbiType[] = [];\n  const dynamicFields: DynamicAbiType[] = [];\n\n  for (let i = 4; i < 4 + numStaticFields; i++) {\n    const schemaTypeIndex = hexToNumber(sliceHex(data, i, i + 1));\n    staticFields.push(schemaAbiTypes[schemaTypeIndex] as StaticAbiType);\n  }\n  for (let i = 4 + numStaticFields; i < 4 + numStaticFields + numDynamicFields; i++) {\n    const schemaTypeIndex = hexToNumber(sliceHex(data, i, i + 1));\n    dynamicFields.push(schemaAbiTypes[schemaTypeIndex] as DynamicAbiType);\n  }\n\n  // validate static data length\n  const actualStaticDataLength = staticFields.reduce((acc, fieldType) => acc + staticAbiTypeToByteLength[fieldType], 0);\n  if (actualStaticDataLength !== staticDataLength) {\n    console.warn(\n      `Schema \"${data}\" static data length (${staticDataLength}) did not match the summed length of all static fields (${actualStaticDataLength}). ` +\n        `Is \\`staticAbiTypeToByteLength\\` up to date with Solidity schema types?`\n    );\n    throw new SchemaStaticLengthMismatchError(data, staticDataLength, actualStaticDataLength);\n  }\n\n  return { staticFields, dynamicFields };\n}\n","import { Hex, sliceHex } from \"viem\";\nimport { TableSchema } from \"./common\";\nimport { hexToSchema } from \"./hexToSchema\";\n\nexport function hexToTableSchema(data: Hex): TableSchema {\n  const valueSchema = hexToSchema(sliceHex(data, 0, 32));\n  const keySchema = hexToSchema(sliceHex(data, 32, 64));\n  return {\n    keySchema,\n    valueSchema,\n  };\n}\n","import { isStaticAbiType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { KeySchema } from \"./common\";\nimport { schemaToHex } from \"./schemaToHex\";\n\nexport function keySchemaToHex(keySchema: KeySchema): Hex {\n  return schemaToHex({ staticFields: Object.values(keySchema).filter(isStaticAbiType), dynamicFields: [] });\n}\n","import { schemaAbiTypes } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { staticDataLength } from \"./staticDataLength\";\n\n/** @deprecated use `keySchemaToHex` or `valueSchemaToHex` instead */\nexport function schemaToHex(schema: Schema): Hex {\n  const staticSchemaTypes = schema.staticFields.map((abiType) => schemaAbiTypes.indexOf(abiType));\n  const dynamicSchemaTypes = schema.dynamicFields.map((abiType) => schemaAbiTypes.indexOf(abiType));\n  return `0x${[\n    staticDataLength(schema.staticFields).toString(16).padStart(4, \"0\"),\n    schema.staticFields.length.toString(16).padStart(2, \"0\"),\n    schema.dynamicFields.length.toString(16).padStart(2, \"0\"),\n    ...staticSchemaTypes.map((schemaType) => schemaType.toString(16).padStart(2, \"0\")),\n    ...dynamicSchemaTypes.map((schemaType) => schemaType.toString(16).padStart(2, \"0\")),\n  ]\n    .join(\"\")\n    .padEnd(64, \"0\")}`;\n}\n","import { SchemaAbiType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\nexport function schemaIndexToAbiType(schema: Schema, schemaIndex: number): SchemaAbiType {\n  if (schemaIndex < schema.staticFields.length) {\n    return schema.staticFields[schemaIndex];\n  }\n  return schema.dynamicFields[schemaIndex - schema.staticFields.length];\n}\n","import { Hex } from \"viem\";\nimport { ValueSchema } from \"./common\";\nimport { isDynamicAbiType, isStaticAbiType, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\n\n// TODO: add tests once we have corresponding tests for FieldLayout.sol (bytes32 -> FieldLayout and vice versa)\nexport function valueSchemaToFieldLayoutHex(valueSchema: ValueSchema): Hex {\n  const staticFields = Object.values(valueSchema).filter(isStaticAbiType);\n  const dynamicFields = Object.values(valueSchema).filter(isDynamicAbiType);\n\n  const staticFieldLengths = staticFields.map((fieldType) => staticAbiTypeToByteLength[fieldType]);\n  const staticDataLength = staticFieldLengths.reduce((dataLength, fieldLength) => dataLength + fieldLength, 0);\n\n  return `0x${[\n    staticDataLength.toString(16).padStart(4, \"0\"),\n    staticFields.length.toString(16).padStart(2, \"0\"),\n    dynamicFields.length.toString(16).padStart(2, \"0\"),\n    ...staticFieldLengths.map((fieldLength) => fieldLength.toString(16).padStart(2, \"0\")),\n  ]\n    .join(\"\")\n    .padEnd(64, \"0\")}`;\n}\n","import { isDynamicAbiType, isStaticAbiType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { ValueSchema } from \"./common\";\nimport { schemaToHex } from \"./schemaToHex\";\n\nexport function valueSchemaToHex(valueSchema: ValueSchema): Hex {\n  return schemaToHex({\n    staticFields: Object.values(valueSchema).filter(isStaticAbiType),\n    dynamicFields: Object.values(valueSchema).filter(isDynamicAbiType),\n  });\n}\n"],"mappings":"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","names":["isDynamicAbiType","abiTypesToSchema","abiTypes","staticFields","dynamicFields","abiType","hexToString","sliceHex","assertExhaustive","arrayAbiTypeToStaticAbiType","staticAbiTypeToByteLength","getAddress","hexToBigInt","hexToBool","assertExhaustive","staticAbiTypeToByteLength","staticAbiTypeToDefaultValue","MUDError","staticAbiTypeToByteLength","InvalidHexLengthError","value","InvalidHexLengthForSchemaError","InvalidHexLengthForPackedCounterError","InvalidHexLengthForStaticFieldError","abiType","InvalidHexLengthForArrayFieldError","SchemaStaticLengthMismatchError","schemaData","definedLength","summedLength","PackedCounterLengthMismatchError","packedCounterData","decodeStaticField","abiType","data","InvalidHexLengthError","staticAbiTypeToByteLength","InvalidHexLengthForStaticFieldError","value","hexToBigInt","defaultValueType","staticAbiTypeToDefaultValue","hexToBool","getAddress","assertExhaustive","decodeDynamicField","abiType","data","hexToString","InvalidHexLengthError","dataSize","staticAbiType","arrayAbiTypeToStaticAbiType","itemByteLength","staticAbiTypeToByteLength","InvalidHexLengthForArrayFieldError","_","i","itemData","sliceHex","decodeStaticField","assertExhaustive","isDynamicAbiType","decodeField","abiType","data","isDynamicAbiType","decodeDynamicField","decodeStaticField","decodeAbiParameters","decodeKeyTuple","keySchema","keyTuple","key","index","decodeKey","keySchema","data","keyValues","decodeKeyTuple","name","i","staticAbiTypeToByteLength","dynamicAbiTypeToDefaultValue","readHex","hexToPackedCounter","data","InvalidHexLengthForPackedCounterError","totalByteLength","decodeStaticField","reversedFieldByteLengths","decodeDynamicField","fieldByteLengths","summedLength","total","length","PackedCounterLengthMismatchError","staticAbiTypeToByteLength","staticDataLength","staticFields","length","fieldType","readHex","decodeRecord","valueSchema","data","values","bytesOffset","fieldType","fieldByteLength","staticAbiTypeToByteLength","value","decodeStaticField","schemaStaticDataLength","staticDataLength","actualStaticDataLength","dataLayout","hexToPackedCounter","i","dataLength","decodeDynamicField","dynamicAbiTypeToDefaultValue","actualDynamicDataLength","isStaticAbiType","isDynamicAbiType","decodeValue","valueSchema","data","staticFields","isStaticAbiType","dynamicFields","isDynamicAbiType","valueTuple","decodeRecord","name","i","concatHex","isStaticAbiType","readHex","decodeValueArgs","valueSchema","staticData","encodedLengths","dynamicData","decodeValue","concatHex","staticDataLength","isStaticAbiType","arrayAbiTypeToStaticAbiType","isArrayAbiType","encodePacked","encodeField","fieldType","value","staticFieldType","isStaticAbiType","encodeAbiParameters","encodeKeyTuple","keySchema","keyTuple","key","index","encodeKey","keySchema","key","staticFields","isStaticAbiType","encodeKeyTuple","encodeRecord","valueSchema","values","staticValues","dynamicValues","staticData","value","i","encodeField","dynamicDataItems","dynamicFieldByteLengths","dynamicTotalByteLength","total","length","dynamicData","packedCounter","concatHex","isStaticAbiType","isDynamicAbiType","concatHex","concatHex","padHex","size","encodeLengths","values","byteLengths","size","totalByteLength","total","length","padHex","concatHex","encodeField","encodeValueArgs","valueSchema","value","valueSchemaEntries","staticFields","type","isStaticAbiType","dynamicFields","isDynamicAbiType","encodedStaticValues","name","encodeField","encodedDynamicValues","encodedLengths","encodeLengths","concatHex","encodeValue","valueSchema","value","staticData","encodedLengths","dynamicData","encodeValueArgs","concatHex","fieldLayoutToHex","fieldLayout","totalLength","length","schemaType","schemaAbiTypes","staticAbiTypeToByteLength","hexToNumber","sliceHex","hexToSchema","data","InvalidHexLengthForSchemaError","staticDataLength","hexToNumber","sliceHex","numStaticFields","numDynamicFields","staticFields","dynamicFields","i","schemaTypeIndex","schemaAbiTypes","actualStaticDataLength","acc","fieldType","staticAbiTypeToByteLength","SchemaStaticLengthMismatchError","sliceHex","hexToTableSchema","data","valueSchema","hexToSchema","sliceHex","isStaticAbiType","schemaAbiTypes","schemaToHex","schema","staticSchemaTypes","abiType","schemaAbiTypes","dynamicSchemaTypes","staticDataLength","schemaType","keySchemaToHex","keySchema","schemaToHex","isStaticAbiType","schemaIndexToAbiType","schema","schemaIndex","isDynamicAbiType","isStaticAbiType","staticAbiTypeToByteLength","valueSchemaToFieldLayoutHex","valueSchema","staticFields","dynamicFields","staticFieldLengths","fieldType","dataLength","fieldLength","isDynamicAbiType","isStaticAbiType","valueSchemaToHex","valueSchema","schemaToHex","isStaticAbiType","isDynamicAbiType"]}