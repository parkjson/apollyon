import{renderArguments as b,renderCommonData as oe,renderWithFieldSuffix as S,renderWithStore as D}from"@latticexyz/common/codegen";function W(e){let n=e.storeArgument,{_typedTableId:r,_typedKeyArgs:t,_keyTupleDefinition:a}=oe(e),o="";for(let[d,c]of e.fields.entries()){if(!e.withDynamicFieldMethods&&c.isDynamic)continue;let u=`${c.typeWithLocation} ${c.name}`;if(e.withGetters&&(o+=S(e.withSuffixlessFieldMethods,c.name,i=>D(n,(m,y,p,h,f)=>`
            /**
             * @notice Get ${c.name}${p}.
             */
            function ${f}get${i}(${b([m,r,t])}) internal view returns (${u}) {
              ${a}
              ${c.isDynamic?`bytes memory _blob = ${y}.getDynamicField(
                      _tableId,
                      _keyTuple,
                      ${d-e.staticFields.length}
                    );`:`bytes32 _blob = ${y}.getStaticField(
                      _tableId,
                      _keyTuple,
                      ${d},
                      _fieldLayout
                    );`}
              return ${O(c)};
            }
        `))),o+=S(e.withSuffixlessFieldMethods,c.name,i=>D(n,(m,y,p,h,f)=>{let s=b([m,r,t,u]),l=c.isDynamic?"setDynamicField":"setStaticField",g=A(c),_=c.isDynamic?`_tableId, _keyTuple, ${d-e.staticFields.length}, ${g}`:`_tableId, _keyTuple, ${d}, ${g}, _fieldLayout`;return`
          /**
           * @notice Set ${c.name}${p}.
           */
          function ${f}set${i}(${s}) internal {
            ${a}
            ${y}.${l}(${_});
          }
        `})),c.isDynamic){let i=ie(c),m=d-e.staticFields.length;e.withGetters&&(o+=S(e.withSuffixlessFieldMethods,c.name,y=>D(n,(p,h,f,s,l)=>`
              /**
               * @notice Get the length of ${c.name}${f}.
               */
              function ${l}length${y}(${b([p,r,t])}) internal view returns (uint256) {
                ${a}
                uint256 _byteLength = ${h}.getDynamicFieldLength(_tableId, _keyTuple, ${m});
                unchecked {
                  return _byteLength / ${i.elementLength};
                }
              }
          `)),o+=S(e.withSuffixlessFieldMethods,c.name,y=>D(n,(p,h,f,s,l)=>`
              /**
               * @notice Get an item of ${c.name}${f}.
               * @dev Reverts with Store_IndexOutOfBounds if \`_index\` is out of bounds for the array.
              */
              function ${l}getItem${y}(${b([p,r,t,"uint256 _index"])}) internal view returns (${i.typeWithLocation}) {
              ${a}
              unchecked {
                bytes memory _blob = ${h}.getDynamicFieldSlice(
                  _tableId,
                  _keyTuple,
                  ${m},
                  _index * ${i.elementLength},
                  (_index + 1) * ${i.elementLength}
                  );
                  return ${i.decoded};
                }
              }
            `))),o+=S(e.withSuffixlessFieldMethods,c.name,y=>D(n,(p,h,f,s,l)=>`
              /**
               * @notice Push ${i.title} to ${c.name}${f}.
               */
              function ${l}push${y}(${b([p,r,t,`${i.typeWithLocation} ${i.name}`])}) internal {
              ${a}
              ${h}.pushToDynamicField(_tableId, _keyTuple, ${m}, ${i.encoded});
            }
            `)),o+=S(e.withSuffixlessFieldMethods,c.name,y=>D(n,(p,h,f,s,l)=>`
            /**
             * @notice Pop ${i.title} from ${c.name}${f}.
             */
            function ${l}pop${y}(${b([p,r,t])}) internal {
              ${a}
              ${h}.popFromDynamicField(_tableId, _keyTuple, ${m}, ${i.elementLength});
            }
          `)),o+=S(e.withSuffixlessFieldMethods,c.name,y=>D(n,(p,h,f,s,l)=>{let g=b([p,r,t,"uint256 _index",`${i.typeWithLocation} ${i.name}`]),_=`
            _tableId,
            _keyTuple,
            ${m},
            uint40(_index * ${i.elementLength}),
            uint40(_encoded.length),
            _encoded 
          `;return`
            /**
             * @notice Update ${i.title} of ${c.name}${f} at \`_index\`.
             */
            function ${l}update${y}(${g}) internal {
              ${a}
              unchecked {
                bytes memory _encoded = ${i.encoded};
                ${h}.spliceDynamicData(${_});
              }
            }
          `}))}}return o}function A(e){let n;return e.arrayElement?n="EncodeArray.encode":e.isDynamic?n="bytes":n="abi.encodePacked",`${n}(${e.typeUnwrap}(${e.name}))`}function U(e,n){let{staticByteLength:r}=e,t=`Bytes.slice${r}(_blob, ${n})`;return G(e,t)}function G(e,n){let{staticByteLength:r,internalTypeId:t}=e,a=r*8,o;if(t.match(/^uint\d{1,3}$/)||t==="address")o=`${t}(${n})`;else if(t.match(/^int\d{1,3}$/))o=`${t}(uint${a}(${n}))`;else if(t.match(/^bytes\d{1,2}$/))o=n;else if(t==="bool")o=`_toBool(uint8(${n}))`;else throw new Error(`Unknown value type id ${t}`);return`${e.typeWrap}(${o})`}function ie(e){let n="";if(e.arrayElement){let r="_element",t={...e.arrayElement,arrayElement:void 0,name:r,methodNameSuffix:n};return{typeWithLocation:e.arrayElement.typeWithLocation,name:"_element",encoded:A(t),decoded:O(t),title:"an element",elementLength:e.arrayElement.staticByteLength}}else{let r="_slice",t={...e,name:r,methodNameSuffix:n};return{typeWithLocation:`${e.typeId} memory`,name:r,encoded:A(t),decoded:O(t),title:"a slice",elementLength:1}}}function O(e){let{isDynamic:n,arrayElement:r}=e;return r?`${e.typeWrap}(
      SliceLib.getSubslice(_blob, 0, _blob.length).decodeArray_${r.internalTypeId}()
    )`:n?`${e.typeWrap}(${e.internalTypeId}(_blob))`:G(e,`bytes${e.staticByteLength}(_blob)`)}import{renderArguments as $,renderCommonData as q,renderList as j,renderWithStore as F}from"@latticexyz/common/codegen";function H(e){let{structName:n,storeArgument:r}=e,{_typedTableId:t,_typedKeyArgs:a,_keyTupleDefinition:o}=q(e),d="";return e.withGetters&&(d+=F(r,(c,u,i,m,y)=>`
        /**
         * @notice Get the full data${i}.
         */
        function ${y}get(${$([c,t,a])}) internal view returns (${de(e)}) {
          ${o}
          
          (
            bytes memory _staticData,
            PackedCounter _encodedLengths,
            bytes memory _dynamicData
            ) = ${u}.getRecord(_tableId, _keyTuple, _fieldLayout);
            return decode(_staticData, _encodedLengths, _dynamicData);
          }
        `)),d+=F(r,(c,u,i,m,y,p)=>{let h=$([c,t,a,$(e.fields.map(({name:s,typeWithLocation:l})=>`${l} ${s}`))]),f="_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData"+(p?", _fieldLayout":"");return`
        /** 
         * @notice Set the full data using individual values${i}.
         */
        function ${y}set(${h}) internal {
          ${E(e)}

          ${o}

          ${u}.setRecord(${f});
        }
    `}),n!==void 0&&(d+=F(r,(c,u,i,m,y,p)=>{let h=$([c,t,a,`${n} memory _table`]),f="_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData"+(p?", _fieldLayout":"");return`
          /**
           * @notice Set the full data using the data struct${i}.
           */
          function ${y}set(${h}) internal {
            ${E(e,"_table.")}

            ${o}

            ${u}.setRecord(${f});
          }
      `})),d+=ae(e),d}function E(e,n=""){let r="";return e.staticFields.length>0?r+=`
      bytes memory _staticData = encodeStatic(
        ${$(e.staticFields.map(({name:t})=>`${n}${t}`))}
      );
    `:r+="bytes memory _staticData;",e.dynamicFields.length>0?r+=`
      PackedCounter _encodedLengths = encodeLengths(
        ${$(e.dynamicFields.map(({name:t})=>`${n}${t}`))}
      );
      bytes memory _dynamicData = encodeDynamic(
        ${$(e.dynamicFields.map(({name:t})=>`${n}${t}`))}
      );
    `:r+=`
      PackedCounter _encodedLengths;
      bytes memory _dynamicData;
    `,r}function Y(e){let{storeArgument:n}=e,{_typedTableId:r,_typedKeyArgs:t,_keyTupleDefinition:a}=q(e);return F(n,(o,d,c,u,i,m)=>{let y=$([o,r,t]),p="_tableId, _keyTuple"+(m?", _fieldLayout":"");return`
      /** 
       * @notice Delete all data for given keys${c}.
       */
      function ${i}deleteRecord(${y}) internal {
        ${a}
        ${d}.deleteRecord(${p});
      }
    `})}function ae({structName:e,fields:n,staticFields:r,dynamicFields:t}){let a=e?`${e} memory _table`:$(n.map(({name:i,typeWithLocation:m})=>`${m} ${i}`)),o=e?"_table.":"",d=r.map(()=>0),c=0;for(let[i,m]of r.entries())d[i]=c,c+=m.staticByteLength;let u="";return r.length>0&&(u+=`
      /**
       * @notice Decode the tightly packed blob of static data using this table's field layout.
       */
      function decodeStatic(bytes memory _blob) internal pure returns (${$(r.map(({name:i,typeWithLocation:m})=>`${m} ${i}`))}) {
        ${j(r,(i,m)=>`
          ${i.name} = ${U(i,d[m])};
          `)}
      }
    `),t.length>0&&(u+=`
      /**
       * @notice Decode the tightly packed blob of dynamic data using the encoded lengths.
       */
      function decodeDynamic(PackedCounter _encodedLengths, bytes memory _blob) internal pure returns (${$(t.map(({name:i,typeWithLocation:m})=>`${m} ${i}`))}) {
        ${j(t,(i,m)=>m===0?`
                uint256 _start;
                uint256 _end;
                unchecked {
                  _end = _encodedLengths.atIndex(${m});
                }
                ${i.name} = ${K(i)};
              `:`
                _start = _end;
                unchecked {
                  _end += _encodedLengths.atIndex(${m});
                }
                ${i.name} = ${K(i)};
              `)}
      }
    `),u+=`
    /**
     * @notice Decode the tightly packed blobs using this table's field layout.
     * ${r.length>0?"@param _staticData Tightly packed static fields.":""}
    * ${t.length>0?"@param _encodedLengths Encoded lengths of dynamic fields.":""}
    * ${t.length>0?"@param _dynamicData Tightly packed dynamic fields.":""}
    */
    function decode(
      bytes memory ${r.length>0?"_staticData":""},
      PackedCounter ${t.length>0?"_encodedLengths":""},
      bytes memory ${t.length>0?"_dynamicData":""}
    ) internal pure returns (${a}) {
  `,r.length>0&&(u+=`
      (${$(r.map(i=>`${o}${i.name}`))}) = decodeStatic(_staticData);
    `),t.length>0&&(u+=`
      (${$(t.map(i=>`${o}${i.name}`))}) = decodeDynamic(_encodedLengths, _dynamicData);
    `),u+=`
    }
  `,u}function de({structName:e,fields:n}){return e?`${e} memory _table`:$(n.map(({name:r,typeWithLocation:t})=>`${t} ${r}`))}function K(e){let{typeId:n,arrayElement:r,typeWrap:t}=e;return r?`${t}(
      SliceLib.getSubslice(_blob, _start, _end).decodeArray_${r.typeId}()
    )`:`${t}(
      ${n}(
        SliceLib.getSubslice(_blob, _start, _end).toBytes()
      )
    )`}import{renderArguments as T,renderCommonData as ue,renderList as k,renderImports as pe,renderTableId as fe,renderTypeHelpers as he,renderWithStore as $e,renderedSolidityHeader as ge}from"@latticexyz/common/codegen";var w={TOTAL_LENGTH:240,NUM_STATIC_FIELDS:232,NUM_DYNAMIC_FIELDS:224};function X(e){return`FieldLayout constant _fieldLayout = FieldLayout.wrap(${ye(e)});`}function ye(e){let n=e.filter(({isDynamic:d})=>!d),r=e.length-n.length,t=0n,a=0,o=e.length;if(o>28)throw new Error(`FieldLayout: invalid length ${o}`);if(r>5)throw new Error(`FieldLayout: invalid length ${r}`);for(let d=0;d<n.length;d++){let{isDynamic:c,staticByteLength:u}=e[d];if(c)throw new Error("FieldLayout: static type after dynamic type");a+=u,t|=BigInt(u)<<BigInt((31-4-d)*8)}return t|=BigInt(a)<<BigInt(w.TOTAL_LENGTH),t|=BigInt(n.length)<<BigInt(w.NUM_STATIC_FIELDS),t|=BigInt(r)<<BigInt(w.NUM_DYNAMIC_FIELDS),`0x${t.toString(16).padStart(64,"0")}`}function V(e){let{imports:n,libraryName:r,structName:t,staticResourceData:a,storeImportPath:o,fields:d,staticFields:c,dynamicFields:u,withRecordMethods:i,storeArgument:m,keyTuple:y}=e,{_typedTableId:p,_typedKeyArgs:h,_keyTupleDefinition:f}=ue(e);return`
    ${ge}

    // Import schema type
    import { SchemaType } from "@latticexyz/schema-type/src/solidity/SchemaType.sol";

    // Import store internals
    import { IStore } from "${o}IStore.sol";
    import { StoreSwitch } from "${o}StoreSwitch.sol";
    import { StoreCore } from "${o}StoreCore.sol";
    import { Bytes } from "${o}Bytes.sol";
    import { Memory } from "${o}Memory.sol";
    import { SliceLib } from "${o}Slice.sol";
    import { EncodeArray } from "${o}tightcoder/EncodeArray.sol";
    import { FieldLayout, FieldLayoutLib } from "${o}FieldLayout.sol";
    import { Schema, SchemaLib } from "${o}Schema.sol";
    import { PackedCounter, PackedCounterLib } from "${o}PackedCounter.sol";
    import { ResourceId } from "${o}ResourceId.sol";
    import { RESOURCE_TABLE, RESOURCE_OFFCHAIN_TABLE } from "${o}storeResourceTypes.sol";

    ${n.length>0?`
          // Import user types
          ${pe(n)}
          `:""}

    ${a?fe(a).tableIdDefinition:""}

    ${X(d)}

    ${t?`
          struct ${t} {
            ${k(d,({name:s,typeId:l})=>`${l} ${s};`)}
          }
          `:""}

    library ${r} {
      /**
       * @notice Get the table values' field layout.
       * @return _fieldLayout The field layout for the table.
       */
      function getFieldLayout() internal pure returns (FieldLayout) {
        return _fieldLayout;
      }

      /** 
       * @notice Get the table's key schema.
       * @return _keySchema The key schema for the table.
       */
      function getKeySchema() internal pure returns (Schema) {
        SchemaType[] memory _keySchema = new SchemaType[](${y.length});
        ${k(y,({enumName:s},l)=>`_keySchema[${l}] = SchemaType.${s};`)}

        return SchemaLib.encode(_keySchema);
      }

      /**
       * @notice Get the table's value schema.
       * @return _valueSchema The value schema for the table.
       */
      function getValueSchema() internal pure returns (Schema) {
        SchemaType[] memory _valueSchema = new SchemaType[](${d.length});
        ${k(d,({enumName:s},l)=>`_valueSchema[${l}] = SchemaType.${s};`)}

        return SchemaLib.encode(_valueSchema);
      }

      /**
       * @notice Get the table's key field names.
       * @return keyNames An array of strings with the names of key fields.
       */
      function getKeyNames() internal pure returns (string[] memory keyNames) {
        keyNames = new string[](${y.length});
        ${k(y,(s,l)=>`keyNames[${l}] = "${s.name}";`)}
      }

      /**
       * @notice Get the table's value field names.
       * @return fieldNames An array of strings with the names of value fields.
       */
      function getFieldNames() internal pure returns (string[] memory fieldNames) {
        fieldNames = new string[](${d.length});
        ${k(d,(s,l)=>`fieldNames[${l}] = "${s.name}";`)}
      }

      ${$e(m,(s,l,g,_,I)=>`
          /**
           * @notice Register the table with its config${g}.
           */
          function ${I}register(${T([s,p])}) internal {
            ${l}.registerTable(_tableId, _fieldLayout, getKeySchema(), getValueSchema(), getKeyNames(), getFieldNames());
          }
        `)}

      ${W(e)}

      ${i?H(e):""}

      ${Y(e)}

      ${_e(c)}

      ${Te(u)}

      ${be(u)}

      /**
       * @notice Encode all of a record's fields.
       * @return The static (fixed length) data, encoded into a sequence of bytes.
       * @return The lengths of the dynamic fields (packed into a single bytes32 value).
       * @return The dyanmic (variable length) data, encoded into a sequence of bytes.
       */
      function encode(${T(e.fields.map(({name:s,typeWithLocation:l})=>`${l} ${s}`))}) internal pure returns (bytes memory, PackedCounter, bytes memory) {
        ${E(e)}

        return (_staticData, _encodedLengths, _dynamicData);
      }
      
      /**
       * @notice Encode keys as a bytes32 array using this table's field layout.
       */
      function encodeKeyTuple(${T([h])}) internal pure returns (bytes32[] memory) {
        ${f}
        return _keyTuple;
      }
    }

    ${he(e)}
  `}function _e(e){return e.length===0?"":`
    /**
     * @notice Tightly pack static (fixed length) data using this table's schema.
     * @return The static data, encoded into a sequence of bytes.
     */
    function encodeStatic(${T(e.map(({name:n,typeWithLocation:r})=>`${r} ${n}`))}) internal pure returns (bytes memory) {
      return abi.encodePacked(${T(e.map(({name:n})=>n))});
    }
  `}function Te(e){return e.length===0?"":`
    /**
     * @notice Tightly pack dynamic data lengths using this table's schema.
     * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).
     */
    function encodeLengths(${T(e.map(({name:n,typeWithLocation:r})=>`${r} ${n}`))}) internal pure returns (PackedCounter _encodedLengths) {
      // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits
      unchecked {
        _encodedLengths = PackedCounterLib.pack(
          ${T(e.map(({name:n,arrayElement:r})=>r?`${n}.length * ${r.staticByteLength}`:`bytes(${n}).length`))}
        );
      }
    }
  `}function be(e){return e.length===0?"":`
    /**
     * @notice Tightly pack dynamic (variable length) data using this table's schema.
     * @return The dynamic data, encoded into a sequence of bytes.
     */
    function encodeDynamic(${T(e.map(({name:n,typeWithLocation:r})=>`${r} ${n}`))}) internal pure returns (bytes memory) {
      return abi.encodePacked(${T(e.map(n=>A(n)))});
    }
  `}import{renderEnums as Se}from"@latticexyz/common/codegen";function Z(e){let n=Object.keys(e.enums).map(r=>({name:r,memberNames:e.enums[r]}));return Se(n)}import R from"path";import{formatAndWriteSolidity as N,loadAndExtractUserTypes as Fe}from"@latticexyz/common/codegen";import Ie from"path";import{SchemaTypeArrayToElement as Ae}from"@latticexyz/schema-type/deprecated";import{AbiTypeToSchemaType as L,getStaticByteLength as v,SchemaType as x,SchemaTypeToAbiType as z}from"@latticexyz/schema-type/deprecated";import{parseStaticArray as J}from"@latticexyz/config";function C(e,n,r){if(e in L){let a=L[e];return{schemaType:a,renderType:P(a)}}let t=J(e);if(t){if(t.elementType in L)return Le(e,t.elementType,t.staticLength);throw new Error("Static arrays of user types are not supported")}return De(e,n,r)}function B(e,n,r,t){if(!(e in L||J(e))){if(e in t){let o=t[e],d=o.importSymbol;return o.isRelativePath?{symbol:d,fromPath:o.fromPath,usedInPath:n}:{symbol:d,path:o.fromPath}}return{symbol:e,fromPath:r.userTypesFilename,usedInPath:n}}}function P(e){let n=v(e),r=n===0,t=z[e];return{typeId:t,typeWithLocation:r?t+" memory":t,enumName:x[e],staticByteLength:n,isDynamic:r,typeWrap:"",typeUnwrap:"",internalTypeId:t}}function De(e,n,r){if(e in n.enums){let t=x.UINT8,a=v(t),o=a===0,d=e;return{schemaType:t,renderType:{typeId:d,typeWithLocation:d,enumName:x[t],staticByteLength:a,isDynamic:o,typeWrap:`${e}`,typeUnwrap:"uint8",internalTypeId:`${z[t]}`}}}if(e in r){if(!(e in r))throw new Error(`User type "${e}" not found in MUD config`);let t=r[e],a=t.typeId,o=L[t.internalTypeId];return{schemaType:o,renderType:{typeId:a,typeWithLocation:a,enumName:x[o],staticByteLength:v(o),isDynamic:!1,typeWrap:`${a}.wrap`,typeUnwrap:`${a}.unwrap`,internalTypeId:`${t.internalTypeId}`}}}throw new Error(`User type "${e}" does not exist`)}function Le(e,n,r){let t=n+"[]",a=L[t];return{schemaType:a,renderType:{typeId:e,typeWithLocation:`${e} memory`,enumName:x[a],staticByteLength:0,isDynamic:!0,typeWrap:`toStaticArray_${n}_${r}`,typeUnwrap:`fromStaticArray_${n}_${r}`,typeWrappingData:{kind:"staticArray",elementType:n,staticLength:r},internalTypeId:t}}}function Q(e,n){let r=e.storeImportPath,t=[];for(let a of Object.keys(e.tables)){let o=e.tables[a],d=o.dataStruct,c=d||o.offchainOnly||Object.keys(o.valueSchema).length>1,u=!c&&Object.keys(o.valueSchema).length===1,i=[],m=Object.keys(o.keySchema).map(s=>{let l=o.keySchema[s],{renderType:g}=C(l,e,n),_=B(l,o.directory,e,n);if(_&&i.push(_),g.isDynamic)throw new Error(`Parsing error: found dynamic key ${s} in table ${a}`);return{...g,name:s,isDynamic:!1}}),y=Object.keys(o.valueSchema).map(s=>{let l=o.valueSchema[s],{renderType:g,schemaType:_}=C(l,e,n),I=B(l,o.directory,e,n);I&&i.push(I);let M=Ae[_];return{...g,arrayElement:M!==void 0?P(M):void 0,name:s}}),p=y.filter(({isDynamic:s})=>!s),h=y.filter(({isDynamic:s})=>s),f=(()=>{if(!o.tableIdArgument)return{tableIdName:a+"TableId",namespace:e.namespace,name:o.name,offchainOnly:o.offchainOnly}})();t.push({outputPath:Ie.join(o.directory,`${a}.sol`),tableName:a,renderOptions:{imports:i,libraryName:a,structName:d?a+"Data":void 0,staticResourceData:f,storeImportPath:r,keyTuple:m,fields:y,staticFields:p,dynamicFields:h,withGetters:!o.offchainOnly,withRecordMethods:c,withDynamicFieldMethods:!o.offchainOnly,withSuffixlessFieldMethods:u,storeArgument:o.storeArgument}})}return t}import{posixPath as ke,renderList as xe,renderedSolidityHeader as Re}from"@latticexyz/common/codegen";function ee(e){return`
    ${Re}

    ${xe(e,({outputPath:n,tableName:r,renderOptions:{structName:t,staticResourceData:a}})=>{let o=[r];return t&&o.push(t),a&&o.push(`${r}TableId`),`import { ${o.join(", ")} } from "./${ke(n)}";`})}
  `}import{rm as Ee}from"fs/promises";async function Lt(e,n,r){let t=Fe(e.userTypes,n,r),a=Q(e,t),o=Array.from(new Set(a.map(({outputPath:d})=>R.dirname(d))));if(await Promise.all(o.map(async d=>{await Ee(R.join(n,d),{recursive:!0,force:!0})})),await Promise.all(a.map(async({outputPath:d,renderOptions:c})=>{let u=R.join(n,d),i=V(c);await N(i,u,"Generated table")})),a.length>0){let d=R.join(n,e.codegenIndexFilename),c=ee(a);await N(c,d,"Generated table index")}if(Object.keys(e.enums).length>0){let d=R.join(n,e.userTypesFilename),c=Z(e);await N(c,d,"Generated types file")}}import{renderedSolidityHeader as we}from"@latticexyz/common/codegen";import{staticAbiTypeToByteLength as Oe,staticAbiTypes as ve}from"@latticexyz/schema-type";import{getLeftPaddingBits as te}from"@latticexyz/common/codegen";function ne(e){return`
    /**
     * @notice Decodes a slice into an array of ${e.internalTypeId}.
     * @dev Uses TightCoder for initial decoding, and then assembly for memory conversion.
     * @param _input The slice to decode.
     * @return _output The decoded array of ${e.internalTypeId}.
     */
    function decodeArray_${e.internalTypeId}(
      Slice _input
    ) internal pure returns (
      ${e.internalTypeId}[] memory _output
    ) {
      bytes32[] memory _genericArray = TightCoder.decode(
        _input,
        ${e.staticByteLength},
        ${te(e)}
      );
      assembly {
        _output := _genericArray
      }
    }
  `}function re(e){return`

    /**
     * @notice Encodes an array of ${e.internalTypeId} into a tightly packed bytes representation.
     * @param _input The array of ${e.internalTypeId} values to be encoded.
     * @return The resulting tightly packed bytes representation of the input array.
     */
    function encode(${e.internalTypeId}[] memory _input) internal pure returns (bytes memory) {
      bytes32[] memory _genericArray;
      assembly {
        _genericArray := _input
      }
      return TightCoder.encode(
        _genericArray,
        ${e.staticByteLength},
        ${te(e)}
      );
    }
  `}function Et(){return`
    ${we}
    import { TightCoder } from "./TightCoder.sol";
    import { Slice } from "../Slice.sol";

    /**
     * @title DecodeSlice Library
     * @notice A library for decoding slices of data into specific data types.
     * @dev This library provides functions for decoding slices into arrays of basic uint types.
     */
    library DecodeSlice {
      ${ve.map(e=>ne({internalTypeId:e,staticByteLength:Oe[e]})).join(`
`)}
    }
  `}import{renderedSolidityHeader as Ce}from"@latticexyz/common/codegen";import{staticAbiTypeToByteLength as Be,staticAbiTypes as Pe}from"@latticexyz/schema-type";function Bt(){return`
    ${Ce}
    import { TightCoder } from "./TightCoder.sol";

    /**
     * @title EncodeArray
     * @dev This library provides utilities for encoding arrays into tightly packed bytes representations.
     */
    library EncodeArray {
      ${Pe.map(e=>re({internalTypeId:e,staticByteLength:Be[e]})).join(`
`)}
      }
  `}import{renderedSolidityHeader as Ne}from"@latticexyz/common/codegen";import{staticAbiTypes as Me}from"@latticexyz/schema-type";function We({typeId:e}){return`
    function testEncodeDecodeArray_${e}(
      ${e} val0,
      ${e} val1,
      ${e} val2
    ) public {
      ${e}[] memory input = new ${e}[](3);
      input[0] = val0;
      input[1] = val1;
      input[2] = val2;

      bytes memory encoded = EncodeArray.encode(input);
      assertEq(encoded, abi.encodePacked(val0, val1, val2));

      ${e}[] memory decoded = SliceLib.fromBytes(encoded).decodeArray_${e}();
      assertEq(decoded.length, 3);
      assertEq(decoded[0], val0);
      assertEq(decoded[1], val1);
      assertEq(decoded[2], val2);
    }
  `}function Wt(){return`
    ${Ne}

    import { Test } from "forge-std/Test.sol";
    import { EncodeArray } from "../../src/tightcoder/EncodeArray.sol";
    import { SliceLib } from "../../src/Slice.sol";

    contract TightCoderAutoTest is Test {
      ${Me.map(e=>We({typeId:e})).join("")}
    }
  `}export{P as getSchemaTypeInfo,Q as getTableOptions,De as getUserTypeInfo,B as importForAbiOrUserType,Et as renderDecodeSlice,U as renderDecodeValueType,Y as renderDeleteRecordMethods,Bt as renderEncodeArray,A as renderEncodeFieldSingle,W as renderFieldMethods,E as renderRecordData,H as renderRecordMethods,V as renderTable,Wt as renderTightCoderAutoTest,We as renderTightCoderAutoTestFunction,ne as renderTightCoderDecode,re as renderTightCoderEncode,Z as renderTypesFromConfig,C as resolveAbiOrUserType,Lt as tablegen};
//# sourceMappingURL=index.js.map