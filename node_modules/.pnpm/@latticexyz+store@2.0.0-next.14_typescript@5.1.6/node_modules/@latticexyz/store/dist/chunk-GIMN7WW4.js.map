{"version":3,"sources":["../ts/config/defaults.ts","../ts/config/storeConfig.ts","../ts/config/experimental/resolveConfig.ts"],"sourcesContent":["export const PATH_DEFAULTS = {\n  storeImportPath: \"@latticexyz/store/src/\",\n  userTypesFilename: \"common.sol\",\n  codegenDirectory: \"codegen\",\n  codegenIndexFilename: \"index.sol\",\n} as const;\n\nexport const DEFAULTS = {\n  namespace: \"\",\n  enums: {} as Record<string, never>,\n  userTypes: {} as Record<string, never>,\n} as const;\n\nexport const TABLE_DEFAULTS = {\n  directory: \"tables\",\n  keySchema: { key: \"bytes32\" },\n  tableIdArgument: false,\n  storeArgument: false,\n  offchainOnly: false,\n} as const;\n","import { AbiType, AbiTypes, StaticAbiType, StaticAbiTypes, StaticArray } from \"@latticexyz/schema-type/deprecated\";\nimport { RefinementCtx, z, ZodIssueCode } from \"zod\";\nimport type {\n  AsDependent,\n  ExtractUserTypes,\n  OrDefaults,\n  RequireKeys,\n  StringForUnion,\n} from \"@latticexyz/common/type-utils\";\nimport {\n  // validation utils\n  getDuplicates,\n  parseStaticArray,\n  STORE_NAME_MAX_LENGTH,\n  // config\n  MUDCoreUserConfig,\n  // schemas\n  zObjectName,\n  zUserEnum,\n  zValueName,\n  zNamespace,\n  zName,\n} from \"@latticexyz/config\";\nimport { DEFAULTS, PATH_DEFAULTS, TABLE_DEFAULTS } from \"./defaults\";\nimport { UserType } from \"@latticexyz/common/codegen\";\nimport { SchemaAbiType, isSchemaAbiType, schemaAbiTypes } from \"@latticexyz/schema-type\";\n\nconst zTableName = zObjectName;\nconst zKeyName = zValueName;\nconst zColumnName = zValueName;\nconst zUserEnumName = zObjectName;\nconst zUserTypeName = zObjectName;\n\n// Fields can use AbiType or one of user-defined wrapper types\n// (user types are refined later, based on the appropriate config options)\nconst zFieldData = z.string();\n\nexport type FieldData<UserTypes extends StringForUnion> = AbiType | StaticArray | UserTypes;\n\n// Primary keys allow only static types\n// (user types are refined later, based on the appropriate config options)\nconst zKeyElementSchema = z.string();\nconst zKeySchema = z.record(zKeyName, zKeyElementSchema).default(TABLE_DEFAULTS.keySchema);\n\ntype KeySchema<StaticUserTypes extends StringForUnion> = StaticAbiType | StaticUserTypes;\n\n/************************************************************************\n *\n *    TABLE SCHEMA\n *\n ************************************************************************/\n\nexport type FullSchemaConfig<UserTypes extends StringForUnion = StringForUnion> = Record<string, FieldData<UserTypes>>;\nexport type ShorthandSchemaConfig<UserTypes extends StringForUnion = StringForUnion> = FieldData<UserTypes>;\nexport type SchemaConfig<UserTypes extends StringForUnion = StringForUnion> =\n  | FullSchemaConfig<UserTypes>\n  | ShorthandSchemaConfig<UserTypes>;\n\nexport type ExpandSchemaConfig<TSchemaConfig extends SchemaConfig<string>> =\n  TSchemaConfig extends ShorthandSchemaConfig<string> ? { value: TSchemaConfig } : TSchemaConfig;\n\nconst zFullSchemaConfig = z\n  .record(zColumnName, zFieldData)\n  .refine((arg) => Object.keys(arg).length > 0, \"Table schema may not be empty\");\n\nconst zShorthandSchemaConfig = zFieldData.transform((fieldData) => {\n  return zFullSchemaConfig.parse({\n    value: fieldData,\n  });\n});\n\nexport const zSchemaConfig = zFullSchemaConfig.or(zShorthandSchemaConfig);\n\ntype ResolvedSchema<\n  TSchema extends Record<string, string>,\n  TUserTypes extends Record<string, Pick<UserType, \"internalType\">>\n> = {\n  [key in keyof TSchema]: TSchema[key] extends keyof TUserTypes\n    ? TUserTypes[TSchema[key]][\"internalType\"]\n    : TSchema[key];\n};\n\n// TODO: add strong types to UserTypes config and use them here\n// (see https://github.com/latticexyz/mud/pull/1588)\nexport function resolveUserTypes<\n  TSchema extends Record<string, string>,\n  TUserTypes extends Record<string, Pick<UserType, \"internalType\">>\n>(schema: TSchema, userTypes: TUserTypes): ResolvedSchema<TSchema, TUserTypes> {\n  const resolvedSchema: Record<string, SchemaAbiType> = {};\n  for (const [key, value] of Object.entries(schema)) {\n    if (isSchemaAbiType(value)) {\n      resolvedSchema[key] = value;\n    } else if (userTypes[value] !== undefined) {\n      resolvedSchema[key] = userTypes[value].internalType as SchemaAbiType;\n    } else {\n      const staticArray = parseStaticArray(value);\n      if (!staticArray) throw new Error(`Unexpected type: ${value}`);\n      resolvedSchema[key] = `${staticArray.elementType as StaticAbiType}[]`;\n    }\n  }\n  return resolvedSchema as ResolvedSchema<TSchema, TUserTypes>;\n}\n\n/************************************************************************\n *\n *    TABLE\n *\n ************************************************************************/\n\nexport interface TableConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> {\n  /** Output directory path for the file. Default is \"tables\" */\n  directory?: string;\n  /** Make methods accept `tableId` argument instead of it being a hardcoded constant. Default is false */\n  tableIdArgument?: boolean;\n  /** Include methods that accept a manual `IStore` argument. Default is true. */\n  storeArgument?: boolean;\n  /** Include a data struct and methods for it. Default is false for 1-column tables; true for multi-column tables. */\n  dataStruct?: boolean;\n  /** Offchain tables don't write to onchain storage, but only emit events for offchain clients. Default is false. */\n  offchainOnly?: boolean;\n  /**\n   * Table's key names mapped to their types.\n   * Default is `{ key: \"bytes32\" }`\n   * Key names' first letter should be lowercase.\n   */\n  keySchema?: Record<string, KeySchema<StaticUserTypes>>;\n  /**\n   * Table's field names mapped to their types.\n   * Field names' first letter should be lowercase.\n   */\n  valueSchema: SchemaConfig<UserTypes>;\n}\n\nexport type FullTableConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Required<TableConfig<UserTypes, StaticUserTypes>> & {\n  valueSchema: FullSchemaConfig<UserTypes>;\n};\n\nexport interface ExpandTableConfig<T extends TableConfig<string, string>, TableName extends string>\n  extends OrDefaults<\n    T,\n    {\n      directory: typeof TABLE_DEFAULTS.directory;\n      name: TableName;\n      tableIdArgument: typeof TABLE_DEFAULTS.tableIdArgument;\n      storeArgument: typeof TABLE_DEFAULTS.storeArgument;\n      // dataStruct isn't expanded, because its value is conditional on the number of value schema fields\n      dataStruct: boolean;\n      keySchema: typeof TABLE_DEFAULTS.keySchema;\n      offchainOnly: typeof TABLE_DEFAULTS.offchainOnly;\n    }\n  > {\n  valueSchema: ExpandSchemaConfig<T[\"valueSchema\"]>;\n}\n\nconst zFullTableConfig = z\n  .object({\n    directory: z.string().default(TABLE_DEFAULTS.directory),\n    name: zName.optional(),\n    tableIdArgument: z.boolean().default(TABLE_DEFAULTS.tableIdArgument),\n    storeArgument: z.boolean().default(TABLE_DEFAULTS.storeArgument),\n    dataStruct: z.boolean().optional(),\n    keySchema: zKeySchema,\n    valueSchema: zSchemaConfig,\n    offchainOnly: z.boolean().default(TABLE_DEFAULTS.offchainOnly),\n  })\n  .transform((arg) => {\n    // default dataStruct value depends on value schema's length\n    if (Object.keys(arg.valueSchema).length === 1) {\n      arg.dataStruct ??= false;\n    } else {\n      arg.dataStruct ??= true;\n    }\n    return arg as RequireKeys<typeof arg, \"dataStruct\">;\n  });\n\nconst zShorthandTableConfig = zFieldData.transform((fieldData) => {\n  return zFullTableConfig.parse({\n    valueSchema: {\n      value: fieldData,\n    },\n  });\n});\n\nexport const zTableConfig = zFullTableConfig.or(zShorthandTableConfig);\n\n/************************************************************************\n *\n *    TABLES\n *\n ************************************************************************/\n\nexport type TablesConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Record<string, TableConfig<UserTypes, StaticUserTypes> | FieldData<UserTypes>>;\n\nexport const zTablesConfig = z.record(zTableName, zTableConfig).transform((tables) => {\n  // default name depends on tableName\n  for (const tableName of Object.keys(tables)) {\n    const table = tables[tableName];\n    table.name = tableName.slice(0, STORE_NAME_MAX_LENGTH);\n\n    tables[tableName] = table;\n  }\n  return tables as Record<string, RequireKeys<(typeof tables)[string], \"name\">>;\n});\n\nexport type FullTablesConfig<\n  UserTypes extends StringForUnion = StringForUnion,\n  StaticUserTypes extends StringForUnion = StringForUnion\n> = Record<string, FullTableConfig<UserTypes, StaticUserTypes>>;\n\nexport type ExpandTablesConfig<T extends TablesConfig<string, string>> = {\n  [TableName in keyof T]: T[TableName] extends FieldData<string>\n    ? ExpandTableConfig<{ valueSchema: { value: T[TableName] } }, TableName extends string ? TableName : never>\n    : T[TableName] extends TableConfig<string, string>\n    ? ExpandTableConfig<T[TableName], TableName extends string ? TableName : never>\n    : // Weakly typed values get a weakly typed expansion.\n      // This shouldn't normally happen within `mudConfig`, but can be manually triggered via `ExpandMUDUserConfig`\n      ExpandTableConfig<TableConfig<string, string>, TableName extends string ? TableName : string>;\n};\n\n/************************************************************************\n *\n *    ENUMS\n *\n ************************************************************************/\n\nexport type EnumsConfig<EnumNames extends StringForUnion> = never extends EnumNames\n  ? {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * (enums are inferred to be absent)\n       */\n      enums?: Record<EnumNames, string[]>;\n    }\n  : StringForUnion extends EnumNames\n  ? {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * (enums aren't inferred - use `mudConfig` or `storeConfig` helper, and `as const` for variables)\n       */\n      enums?: Record<EnumNames, string[]>;\n    }\n  : {\n      /**\n       * Enum names mapped to lists of their member names\n       *\n       * Enums defined here can be used as types in table schemas/keys\n       */\n      enums: Record<EnumNames, string[]>;\n    };\n\nexport type FullEnumsConfig<EnumNames extends StringForUnion> = {\n  enums: Record<EnumNames, string[]>;\n};\n\nexport const zEnumsConfig = z.object({\n  enums: z.record(zUserEnumName, zUserEnum).default(DEFAULTS.enums),\n});\n\n/************************************************************************\n *\n *    USER TYPES\n *\n ************************************************************************/\n\nexport type UserTypesConfig<UserTypeNames extends StringForUnion = StringForUnion> = never extends UserTypeNames\n  ? {\n      /**\n       * User types mapped to file paths from which to import them.\n       * Paths are treated as relative to root.\n       * Paths that don't start with a \".\" have foundry remappings applied to them first.\n       *\n       * (user types are inferred to be absent)\n       */\n      userTypes?: Record<UserTypeNames, UserType>;\n    }\n  : StringForUnion extends UserTypeNames\n  ? {\n      /**\n       * User types mapped to file paths from which to import them.\n       * Paths are treated as relative to root.\n       * Paths that don't start with a \".\" have foundry remappings applied to them first.\n       *\n       * (user types aren't inferred - use `mudConfig` or `storeConfig` helper, and `as const` for variables)\n       */\n      userTypes?: Record<UserTypeNames, UserType>;\n    }\n  : {\n      /**\n       * User types mapped to file paths from which to import them.\n       * Paths are treated as relative to root.\n       * Paths that don't start with a \".\" have foundry remappings applied to them first.\n       *\n       * User types defined here can be used as types in table schemas/keys\n       */\n      userTypes: Record<UserTypeNames, UserType>;\n    };\n\nconst zUserTypeConfig = z.object({\n  filePath: z.string(),\n  internalType: z.enum(schemaAbiTypes),\n});\n\nexport const zUserTypesConfig = z.object({\n  userTypes: z.record(zUserTypeName, zUserTypeConfig).default(DEFAULTS.userTypes),\n});\n\n/************************************************************************\n *\n *    FINAL\n *\n ************************************************************************/\n\n// zod doesn't preserve doc comments\n/** MUDCoreUserConfig wrapper to use generics in some options for better type inference */\nexport type MUDUserConfig<\n  T extends MUDCoreUserConfig = MUDCoreUserConfig,\n  EnumNames extends StringForUnion = StringForUnion,\n  UserTypeNames extends StringForUnion = StringForUnion,\n  StaticUserTypes extends ExtractUserTypes<EnumNames | UserTypeNames> = ExtractUserTypes<EnumNames | UserTypeNames>\n> = T &\n  EnumsConfig<EnumNames> &\n  UserTypesConfig<UserTypeNames> & {\n    /**\n     * Configuration for each table.\n     *\n     * The key is the table name (capitalized).\n     *\n     * The value:\n     *  - abi or user type for a single-value table.\n     *  - FullTableConfig object for multi-value tables (or for customizable options).\n     */\n    tables: TablesConfig<AsDependent<StaticUserTypes>, AsDependent<StaticUserTypes>>;\n    /** The namespace for table ids. Default is \"\" (ROOT) */\n    namespace?: string;\n    /** Path for store package imports. Default is \"@latticexyz/store/src/\" */\n    storeImportPath?: string;\n    /** Filename where common user types will be generated and imported from. Default is \"common.sol\" */\n    userTypesFilename?: string;\n    /** Path to the directory where generated files will be placed. (Default is \"codegen\") */\n    codegenDirectory?: string;\n    /** Filename where codegen index will be generated. Default is \"index.sol\" */\n    codegenIndexFilename?: string;\n  };\n\nconst StoreConfigUnrefined = z\n  .object({\n    namespace: zNamespace.default(DEFAULTS.namespace),\n    storeImportPath: z.string().default(PATH_DEFAULTS.storeImportPath),\n    tables: zTablesConfig,\n    userTypesFilename: z.string().default(PATH_DEFAULTS.userTypesFilename),\n    codegenDirectory: z.string().default(PATH_DEFAULTS.codegenDirectory),\n    codegenIndexFilename: z.string().default(PATH_DEFAULTS.codegenIndexFilename),\n  })\n  .merge(zEnumsConfig)\n  .merge(zUserTypesConfig);\n\n// finally validate global conditions\nexport const zStoreConfig = StoreConfigUnrefined.superRefine(validateStoreConfig);\n\nexport type StoreUserConfig = z.input<typeof zStoreConfig>;\nexport type StoreConfig = z.output<typeof zStoreConfig>;\n\n// Catchall preserves other plugins' options\nexport const zPluginStoreConfig = StoreConfigUnrefined.catchall(z.any()).superRefine(validateStoreConfig);\n\n/************************************************************************\n *\n *    HELPERS\n *\n ************************************************************************/\n\n// Validate conditions that check multiple different config options simultaneously\nfunction validateStoreConfig(config: z.output<typeof StoreConfigUnrefined>, ctx: RefinementCtx) {\n  // Local table variables must be unique within the table\n  for (const table of Object.values(config.tables)) {\n    const keySchemaNames = Object.keys(table.keySchema);\n    const fieldNames = Object.keys(table.valueSchema);\n    const duplicateVariableNames = getDuplicates([...keySchemaNames, ...fieldNames]);\n    if (duplicateVariableNames.length > 0) {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `Field and key names within one table must be unique: ${duplicateVariableNames.join(\", \")}`,\n      });\n    }\n  }\n  // Global names must be unique\n  const tableLibraryNames = Object.keys(config.tables);\n  const staticUserTypeNames = [...Object.keys(config.enums), ...Object.keys(config.userTypes)];\n  const userTypeNames = staticUserTypeNames;\n  const globalNames = [...tableLibraryNames, ...userTypeNames];\n  const duplicateGlobalNames = getDuplicates(globalNames);\n  if (duplicateGlobalNames.length > 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Table library names, enum names, user type names must be globally unique: ${duplicateGlobalNames.join(\n        \", \"\n      )}`,\n    });\n  }\n  // Table names used for tableId must be unique\n  const tableNames = Object.values(config.tables).map(({ name }) => name);\n  const duplicateTableNames = getDuplicates(tableNames);\n  if (duplicateTableNames.length > 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Table names must be unique: ${duplicateTableNames.join(\", \")}`,\n    });\n  }\n  // User types must exist\n  for (const table of Object.values(config.tables)) {\n    for (const keySchemaType of Object.values(table.keySchema)) {\n      validateStaticAbiOrUserType(staticUserTypeNames, keySchemaType, ctx);\n    }\n    for (const fieldType of Object.values(table.valueSchema)) {\n      validateAbiOrUserType(userTypeNames, staticUserTypeNames, fieldType, ctx);\n    }\n  }\n}\n\nfunction validateAbiOrUserType(\n  userTypeNames: string[],\n  staticUserTypeNames: string[],\n  type: string,\n  ctx: RefinementCtx\n) {\n  if (!(AbiTypes as string[]).includes(type) && !userTypeNames.includes(type)) {\n    const staticArray = parseStaticArray(type);\n    if (staticArray) {\n      validateStaticArray(staticUserTypeNames, staticArray.elementType, staticArray.staticLength, ctx);\n    } else {\n      ctx.addIssue({\n        code: ZodIssueCode.custom,\n        message: `${type} is not a valid abi type, and is not defined in userTypes`,\n      });\n    }\n  }\n}\n\nfunction validateStaticAbiOrUserType(staticUserTypeNames: string[], type: string, ctx: RefinementCtx) {\n  if (!(StaticAbiTypes as string[]).includes(type) && !staticUserTypeNames.includes(type)) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `${type} is not a static type`,\n    });\n  }\n}\n\nfunction validateStaticArray(\n  staticUserTypeNames: string[],\n  elementType: string,\n  staticLength: number,\n  ctx: RefinementCtx\n) {\n  validateStaticAbiOrUserType(staticUserTypeNames, elementType, ctx);\n\n  if (staticLength === 0) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Static array length must not be 0`,\n    });\n  } else if (staticLength >= 2 ** 16) {\n    ctx.addIssue({\n      code: ZodIssueCode.custom,\n      message: `Static array length must be less than 2**16`,\n    });\n  }\n}\n","import { StringForUnion } from \"@latticexyz/common/type-utils\";\nimport { StoreConfig, TableConfig, UserTypesConfig } from \"../storeConfig\";\nimport { UserType } from \"@latticexyz/common/codegen\";\nimport { mapObject } from \"@latticexyz/common/utils\";\nimport { resourceToHex } from \"@latticexyz/common\";\nimport { SchemaAbiType } from \"@latticexyz/schema-type\";\n\n/**\n * @internal Internal only\n * @deprecated Internal only\n */\nexport type ResolvedStoreConfig<TStoreConfig extends StoreConfig> = {\n  tables: {\n    [TableKey in keyof TStoreConfig[\"tables\"] & string]: ResolvedTableConfig<\n      TStoreConfig[\"tables\"][TableKey],\n      TStoreConfig[\"userTypes\"],\n      keyof TStoreConfig[\"enums\"] & string,\n      TStoreConfig[\"namespace\"],\n      TableKey\n    >;\n  };\n};\n\ntype ResolvedTableConfig<\n  TTableConfig extends TableConfig,\n  TUserTypes extends UserTypesConfig[\"userTypes\"],\n  TEnumNames extends StringForUnion,\n  TNamespace extends string = string,\n  TName extends string = string\n> = {\n  keySchema: ResolvedKeySchema<TTableConfig[\"keySchema\"], TUserTypes, TEnumNames>;\n  valueSchema: ResolvedValueSchema<TTableConfig[\"valueSchema\"], TUserTypes, TEnumNames>;\n  namespace: TNamespace;\n  name: TName;\n  tableId: `0x${string}`;\n};\n\ntype ResolvedKeySchema<\n  TKeySchema extends TableConfig[\"keySchema\"],\n  TUserTypes extends UserTypesConfig[\"userTypes\"],\n  TEnumNames extends StringForUnion\n> = ResolvedSchema<TKeySchema, TUserTypes, TEnumNames>;\n\ntype ResolvedValueSchema<\n  TValueSchema extends TableConfig[\"valueSchema\"],\n  TUserTypes extends UserTypesConfig[\"userTypes\"],\n  TEnumNames extends StringForUnion\n> = ResolvedSchema<Exclude<TValueSchema, string>, TUserTypes, TEnumNames>;\n\ntype ResolvedSchema<\n  TSchema extends Exclude<TableConfig[\"keySchema\"] | TableConfig[\"valueSchema\"], string>,\n  TUserTypes extends UserTypesConfig[\"userTypes\"],\n  TEnumNames extends StringForUnion\n> = {\n  [key in keyof TSchema]: {\n    type: TSchema[key] extends SchemaAbiType\n      ? TSchema[key]\n      : TSchema[key] extends keyof TUserTypes\n      ? TUserTypes[TSchema[key]] extends UserType\n        ? // Note: we mistakenly named the plain ABI type \"internalType\",\n          // while in Solidity ABIs the plain ABI type is called \"type\" and\n          // and the custom type \"internalType\". We're planning to\n          // change our version and align with Solidity ABIs going forward.\n          TUserTypes[TSchema[key]][\"internalType\"]\n        : never\n      : TSchema[key] extends TEnumNames\n      ? \"uint8\"\n      : never;\n    internalType: TSchema[key];\n  };\n};\n\n/**\n * @internal Internal only\n * @deprecated Internal only\n */\nexport function resolveConfig<TStoreConfig extends StoreConfig>(\n  config: TStoreConfig\n): ResolvedStoreConfig<TStoreConfig> {\n  const resolvedTables: Record<string, ReturnType<typeof resolveTable>> = {};\n\n  for (const key of Object.keys(config.tables)) {\n    resolvedTables[key] = resolveTable(\n      config.tables[key],\n      config.userTypes,\n      Object.keys(config.enums),\n      config.namespace,\n      key\n    ) as ReturnType<typeof resolveTable>;\n  }\n\n  return {\n    tables: resolvedTables as ResolvedStoreConfig<TStoreConfig>[\"tables\"],\n  };\n}\n\nfunction resolveTable<\n  TTableConfig extends TableConfig,\n  TUserTypes extends UserTypesConfig[\"userTypes\"],\n  TEnums extends StringForUnion[],\n  TNamespace extends string,\n  TName extends string\n>(\n  tableConfig: TTableConfig,\n  userTypes: TUserTypes,\n  enums: TEnums,\n  namespace: TNamespace,\n  name: TName\n): ResolvedTableConfig<typeof tableConfig, TUserTypes, TEnums[number]> {\n  const { keySchema, valueSchema } = tableConfig;\n\n  return {\n    keySchema: resolveKeySchema(keySchema, userTypes, enums),\n    valueSchema: resolveValueSchema(valueSchema, userTypes, enums) as ResolvedSchema<\n      Exclude<TTableConfig[\"valueSchema\"], string>,\n      TUserTypes,\n      TEnums[number]\n    >,\n    namespace,\n    name,\n    tableId: resourceToHex({ type: tableConfig.offchainOnly ? \"offchainTable\" : \"table\", namespace, name }),\n  };\n}\n\nfunction resolveKeySchema<\n  TKeySchema extends TableConfig[\"keySchema\"],\n  TUserTypes extends UserTypesConfig[\"userTypes\"],\n  TEnums extends StringForUnion[]\n>(\n  keySchema: TKeySchema,\n  userTypes: TUserTypes,\n  enums: TEnums\n): ResolvedKeySchema<TKeySchema extends undefined ? { key: \"bytes32\" } : TKeySchema, TUserTypes, TEnums[number]> {\n  const schema = (\n    keySchema == null ? { key: \"bytes32\" } : typeof keySchema === \"string\" ? { key: keySchema } : keySchema\n  ) as TKeySchema extends undefined ? { key: \"bytes32\" } : TKeySchema;\n  return resolveSchema(schema, userTypes, enums);\n}\n\nfunction resolveValueSchema<\n  TValueSchema extends TableConfig[\"valueSchema\"],\n  TUserTypes extends UserTypesConfig[\"userTypes\"],\n  TEnums extends StringForUnion[]\n>(\n  valueSchema: TValueSchema,\n  userTypes: TUserTypes,\n  enums: TEnums\n): ResolvedValueSchema<TValueSchema, TUserTypes, TEnums[number]> {\n  const schema = (\n    typeof valueSchema === \"string\" ? ({ value: valueSchema } as unknown as TValueSchema) : valueSchema\n  ) as Exclude<TValueSchema, string>;\n  return resolveSchema(schema, userTypes, enums);\n}\n\nfunction resolveSchema<\n  TSchema extends Exclude<NonNullable<TableConfig[\"keySchema\"]> | TableConfig[\"valueSchema\"], string>,\n  TUserTypes extends UserTypesConfig[\"userTypes\"],\n  TEnums extends StringForUnion[]\n>(schema: TSchema, userTypes: TUserTypes, enums: TEnums): ResolvedSchema<TSchema, TUserTypes, TEnums[number]> {\n  return mapObject<TSchema, ResolvedSchema<TSchema, TUserTypes, TEnums[number]>>(schema, (value, key) => {\n    const isUserType = userTypes && value in userTypes;\n    const isEnum = enums.includes(value);\n    return {\n      type: (isUserType ? userTypes[value].internalType : isEnum ? (\"uint8\" as const) : value) as ResolvedSchema<\n        TSchema,\n        TUserTypes,\n        TEnums[number]\n      >[typeof key][\"type\"],\n      internalType: value,\n    };\n  });\n}\n"],"mappings":"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","names":["PATH_DEFAULTS","DEFAULTS","TABLE_DEFAULTS","AbiTypes","StaticAbiTypes","z","ZodIssueCode","getDuplicates","parseStaticArray","STORE_NAME_MAX_LENGTH","zObjectName","zUserEnum","zValueName","zNamespace","zName","isSchemaAbiType","schemaAbiTypes","zTableName","zObjectName","zKeyName","zValueName","zColumnName","zUserEnumName","zUserTypeName","zFieldData","z","zKeyElementSchema","zKeySchema","TABLE_DEFAULTS","zFullSchemaConfig","arg","zShorthandSchemaConfig","fieldData","zSchemaConfig","resolveUserTypes","schema","userTypes","resolvedSchema","key","value","staticArray","parseStaticArray","zFullTableConfig","zName","zShorthandTableConfig","zTableConfig","zTablesConfig","tables","tableName","table","STORE_NAME_MAX_LENGTH","zEnumsConfig","zUserEnum","DEFAULTS","zUserTypeConfig","zUserTypesConfig","StoreConfigUnrefined","zNamespace","PATH_DEFAULTS","zStoreConfig","validateStoreConfig","zPluginStoreConfig","config","ctx","keySchemaNames","fieldNames","duplicateVariableNames","getDuplicates","ZodIssueCode","tableLibraryNames","staticUserTypeNames","userTypeNames","globalNames","duplicateGlobalNames","tableNames","name","duplicateTableNames","keySchemaType","validateStaticAbiOrUserType","fieldType","validateAbiOrUserType","type","AbiTypes","validateStaticArray","StaticAbiTypes","elementType","staticLength","mapObject","resourceToHex","resolveConfig","config","resolvedTables","key","resolveTable","tableConfig","userTypes","enums","namespace","name","keySchema","valueSchema","resolveKeySchema","resolveValueSchema","schema","resolveSchema","value","isUserType","isEnum"]}