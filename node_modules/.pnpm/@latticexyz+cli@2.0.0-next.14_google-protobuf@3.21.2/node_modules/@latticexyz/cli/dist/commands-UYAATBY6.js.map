{"version":3,"sources":["../src/commands/index.ts","../src/commands/devnode.ts","../src/commands/faucet.ts","../src/commands/hello.ts","../src/commands/tablegen.ts","../src/runDeploy.ts","../src/deploy/deploy.ts","../src/deploy/ensureDeployer.ts","../src/deploy/create2/deployment.json","../src/debug.ts","../src/deploy/debug.ts","../src/deploy/deployWorld.ts","../src/deploy/ensureWorldFactory.ts","../src/deploy/common.ts","../src/deploy/configToTables.ts","../src/deploy/ensureContractsDeployed.ts","../src/deploy/ensureContract.ts","../src/deploy/logsToWorldDeploy.ts","../src/deploy/ensureTables.ts","../src/deploy/resourceLabel.ts","../src/deploy/getTables.ts","../src/deploy/ensureSystems.ts","../src/deploy/getResourceIds.ts","../src/deploy/getSystems.ts","../src/deploy/getTableValue.ts","../src/deploy/getFunctions.ts","../src/deploy/getResourceAccess.ts","../src/deploy/getWorldDeploy.ts","../src/deploy/ensureFunctions.ts","../src/deploy/ensureModules.ts","../src/deploy/assertNamespaceOwner.ts","../src/deploy/resolveConfig.ts","../src/utils/getExistingContracts.ts","../src/utils/modules/constants.ts","../src/utils/utils/getContractData.ts","../src/utils/utils/postDeploy.ts","../src/commands/deploy.ts","../src/commands/worldgen.ts","../src/commands/set-version.ts","../package.json","../src/mudPackages.ts","../src/commands/test.ts","../src/commands/trace.ts","../src/commands/dev-contracts.ts"],"sourcesContent":["import { CommandModule } from \"yargs\";\n\nimport gasReport from \"@latticexyz/gas-report\";\nimport abiTs from \"@latticexyz/abi-ts\";\n\nimport devnode from \"./devnode\";\nimport faucet from \"./faucet\";\nimport hello from \"./hello\";\nimport tablegen from \"./tablegen\";\nimport deploy from \"./deploy\";\nimport worldgen from \"./worldgen\";\nimport setVersion from \"./set-version\";\nimport test from \"./test\";\nimport trace from \"./trace\";\nimport devContracts from \"./dev-contracts\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any -- Each command has different options\nexport const commands: CommandModule<any, any>[] = [\n  deploy,\n  devnode,\n  faucet,\n  gasReport as CommandModule,\n  hello,\n  tablegen,\n  worldgen,\n  setVersion,\n  test,\n  trace,\n  devContracts,\n  abiTs,\n];\n","import { rmSync } from \"fs\";\nimport { homedir } from \"os\";\nimport path from \"path\";\nimport type { CommandModule } from \"yargs\";\nimport { execa } from \"execa\";\n\ntype Options = {\n  blocktime: number;\n};\n\nconst commandModule: CommandModule<Options, Options> = {\n  command: \"devnode\",\n\n  describe: \"Start a local Ethereum node for development\",\n\n  builder(yargs) {\n    return yargs.options({\n      blocktime: { type: \"number\", default: 1, decs: \"Interval in which new blocks are produced\" },\n    });\n  },\n\n  async handler({ blocktime }) {\n    console.log(\"Clearing devnode history\");\n    const userHomeDir = homedir();\n    rmSync(path.join(userHomeDir, \".foundry\", \"anvil\", \"tmp\"), { recursive: true, force: true });\n\n    const anvilArgs = [\"-b\", String(blocktime), \"--block-base-fee-per-gas\", \"0\"];\n    console.log(`Running: anvil ${anvilArgs.join(\" \")}`);\n    const child = execa(\"anvil\", anvilArgs, {\n      stdio: [\"inherit\", \"inherit\", \"inherit\"],\n    });\n\n    process.on(\"SIGINT\", () => {\n      console.log(\"\\ngracefully shutting down from SIGINT (Crtl-C)\");\n      child.kill();\n      process.exit();\n    });\n    await child;\n  },\n};\n\nexport default commandModule;\n","import type { CommandModule } from \"yargs\";\nimport { FaucetServiceDefinition } from \"@latticexyz/services/faucet\";\nimport { createChannel, createClient } from \"nice-grpc-web\";\nimport chalk from \"chalk\";\nimport { NodeHttpTransport } from \"@improbable-eng/grpc-web-node-http-transport\";\n\ntype Options = {\n  dripDev?: boolean;\n  faucetUrl: string;\n  address: string;\n};\n\n/**\n * Create a FaucetServiceClient\n * @param url FaucetService URL\n * @returns FaucetServiceClient\n */\nfunction createFaucetService(url: string) {\n  return createClient(FaucetServiceDefinition, createChannel(url, NodeHttpTransport()));\n}\n\nconst commandModule: CommandModule<Options, Options> = {\n  command: \"faucet\",\n\n  describe: \"Interact with a MUD faucet\",\n\n  builder(yargs) {\n    return yargs.options({\n      dripDev: {\n        type: \"boolean\",\n        desc: \"Request a drip from the dev endpoint (requires faucet to have dev mode enabled)\",\n        default: true,\n      },\n      faucetUrl: {\n        type: \"string\",\n        desc: \"URL of the MUD faucet\",\n        default: \"https://faucet.testnet-mud-services.linfra.xyz\",\n      },\n      address: {\n        type: \"string\",\n        desc: \"Ethereum address to fund\",\n        required: true,\n      },\n    });\n  },\n\n  async handler({ dripDev, faucetUrl, address }) {\n    const faucet = createFaucetService(faucetUrl);\n\n    if (dripDev) {\n      console.log(chalk.yellow(\"Dripping to\", address));\n      await faucet.dripDev({ address });\n      console.log(chalk.yellow(\"Success\"));\n    }\n\n    process.exit(0);\n  },\n};\n\nexport default commandModule;\n","import type { CommandModule } from \"yargs\";\n\ntype Options = {\n  name: string;\n  upper: boolean | undefined;\n};\n\nconst commandModule: CommandModule<Options, Options> = {\n  command: \"hello <name>\",\n\n  describe: \"Greet <name> with Hello\",\n\n  builder(yargs) {\n    return yargs\n      .options({\n        upper: { type: \"boolean\" },\n      })\n      .positional(\"name\", { type: \"string\", demandOption: true });\n  },\n\n  handler({ name }) {\n    const greeting = `Gm, ${name}!`;\n    console.log(greeting);\n    process.exit(0);\n  },\n};\n\nexport default commandModule;\n","import path from \"path\";\nimport type { CommandModule } from \"yargs\";\nimport { loadConfig } from \"@latticexyz/config/node\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { tablegen } from \"@latticexyz/store/codegen\";\nimport { getRemappings, getSrcDirectory } from \"@latticexyz/common/foundry\";\n\ntype Options = {\n  configPath?: string;\n};\n\nconst commandModule: CommandModule<Options, Options> = {\n  command: \"tablegen\",\n\n  describe: \"Autogenerate MUD Store table libraries based on the config file\",\n\n  builder(yargs) {\n    return yargs.options({\n      configPath: { type: \"string\", desc: \"Path to the config file\" },\n    });\n  },\n\n  async handler({ configPath }) {\n    const config = (await loadConfig(configPath)) as StoreConfig;\n    const srcDir = await getSrcDirectory();\n    const remappings = await getRemappings();\n\n    await tablegen(config, path.join(srcDir, config.codegenDirectory), remappings);\n\n    process.exit(0);\n  },\n};\n\nexport default commandModule;\n","import path from \"node:path\";\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from \"node:fs\";\nimport { InferredOptionTypes, Options } from \"yargs\";\nimport { deploy } from \"./deploy/deploy\";\nimport { createWalletClient, http, Hex } from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { loadConfig } from \"@latticexyz/config/node\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { WorldConfig } from \"@latticexyz/world\";\nimport { forge, getOutDirectory, getRemappings, getRpcUrl, getSrcDirectory } from \"@latticexyz/common/foundry\";\nimport chalk from \"chalk\";\nimport { execa } from \"execa\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { resolveConfig } from \"./deploy/resolveConfig\";\nimport { getChainId } from \"viem/actions\";\nimport { postDeploy } from \"./utils/utils/postDeploy\";\nimport { WorldDeploy } from \"./deploy/common\";\nimport { tablegen } from \"@latticexyz/store/codegen\";\nimport { worldgen } from \"@latticexyz/world/node\";\nimport { getExistingContracts } from \"./utils/getExistingContracts\";\n\nexport const deployOptions = {\n  configPath: { type: \"string\", desc: \"Path to the config file\" },\n  printConfig: { type: \"boolean\", desc: \"Print the resolved config\" },\n  profile: { type: \"string\", desc: \"The foundry profile to use\" },\n  saveDeployment: { type: \"boolean\", desc: \"Save the deployment info to a file\", default: true },\n  rpc: { type: \"string\", desc: \"The RPC URL to use. Defaults to the RPC url from the local foundry.toml\" },\n  worldAddress: { type: \"string\", desc: \"Deploy to an existing World at the given address\" },\n  srcDir: { type: \"string\", desc: \"Source directory. Defaults to foundry src directory.\" },\n  skipBuild: { type: \"boolean\", desc: \"Skip rebuilding the contracts before deploying\" },\n  alwaysRunPostDeploy: {\n    type: \"boolean\",\n    desc: \"Always run PostDeploy.s.sol after each deploy (including during upgrades). By default, PostDeploy.s.sol is only run once after a new world is deployed.\",\n  },\n} as const satisfies Record<string, Options>;\n\nexport type DeployOptions = InferredOptionTypes<typeof deployOptions>;\n\n/**\n * Given some CLI arguments, finds and resolves a MUD config, foundry profile, and runs a deploy.\n * This is used by the deploy, test, and dev-contracts CLI commands.\n */\nexport async function runDeploy(opts: DeployOptions): Promise<WorldDeploy> {\n  const profile = opts.profile ?? process.env.FOUNDRY_PROFILE;\n\n  const config = (await loadConfig(opts.configPath)) as StoreConfig & WorldConfig;\n  if (opts.printConfig) {\n    console.log(chalk.green(\"\\nResolved config:\\n\"), JSON.stringify(config, null, 2));\n  }\n\n  const srcDir = opts.srcDir ?? (await getSrcDirectory(profile));\n  const outDir = await getOutDirectory(profile);\n  const remappings = await getRemappings();\n\n  const rpc = opts.rpc ?? (await getRpcUrl(profile));\n  console.log(\n    chalk.bgBlue(\n      chalk.whiteBright(`\\n Deploying MUD contracts${profile ? \" with profile \" + profile : \"\"} to RPC ${rpc} \\n`)\n    )\n  );\n\n  // Run build\n  if (!opts.skipBuild) {\n    const outPath = path.join(srcDir, config.codegenDirectory);\n    await Promise.all([tablegen(config, outPath, remappings), worldgen(config, getExistingContracts(srcDir), outPath)]);\n    await forge([\"build\"], { profile });\n    await execa(\"mud\", [\"abi-ts\"], { stdio: \"inherit\" });\n  }\n\n  const privateKey = process.env.PRIVATE_KEY as Hex;\n  if (!privateKey) {\n    throw new MUDError(\n      `Missing PRIVATE_KEY environment variable.\nRun 'echo \"PRIVATE_KEY=0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\" > .env'\nin your contracts directory to use the default anvil private key.`\n    );\n  }\n\n  const resolvedConfig = resolveConfig({ config, forgeSourceDir: srcDir, forgeOutDir: outDir });\n\n  const client = createWalletClient({\n    transport: http(rpc),\n    account: privateKeyToAccount(privateKey),\n  });\n  console.log(\"Deploying from\", client.account.address);\n\n  const startTime = Date.now();\n  const worldDeploy = await deploy({\n    worldAddress: opts.worldAddress as Hex | undefined,\n    client,\n    config: resolvedConfig,\n  });\n  if (opts.worldAddress == null || opts.alwaysRunPostDeploy) {\n    await postDeploy(config.postDeployScript, worldDeploy.address, rpc, profile);\n  }\n  console.log(chalk.green(\"Deployment completed in\", (Date.now() - startTime) / 1000, \"seconds\"));\n\n  const deploymentInfo = {\n    worldAddress: worldDeploy.address,\n    blockNumber: Number(worldDeploy.deployBlock),\n  };\n\n  if (opts.saveDeployment) {\n    const chainId = await getChainId(client);\n    const deploysDir = path.join(config.deploysDirectory, chainId.toString());\n    mkdirSync(deploysDir, { recursive: true });\n    writeFileSync(path.join(deploysDir, \"latest.json\"), JSON.stringify(deploymentInfo, null, 2));\n    writeFileSync(path.join(deploysDir, Date.now() + \".json\"), JSON.stringify(deploymentInfo, null, 2));\n\n    const localChains = [1337, 31337];\n    const deploys = existsSync(config.worldsFile) ? JSON.parse(readFileSync(config.worldsFile, \"utf-8\")) : {};\n    deploys[chainId] = {\n      address: deploymentInfo.worldAddress,\n      // We expect the worlds file to be committed and since local deployments are often\n      // a consistent address but different block number, we'll ignore the block number.\n      blockNumber: localChains.includes(chainId) ? undefined : deploymentInfo.blockNumber,\n    };\n    writeFileSync(config.worldsFile, JSON.stringify(deploys, null, 2));\n\n    console.log(\n      chalk.bgGreen(chalk.whiteBright(`\\n Deployment result (written to ${config.worldsFile} and ${deploysDir}): \\n`))\n    );\n  }\n\n  console.log(deploymentInfo);\n\n  return worldDeploy;\n}\n","import { Account, Address, Chain, Client, Transport, getAddress } from \"viem\";\nimport { ensureDeployer } from \"./ensureDeployer\";\nimport { deployWorld } from \"./deployWorld\";\nimport { ensureTables } from \"./ensureTables\";\nimport { Config, ConfigInput, WorldDeploy, supportedStoreVersions, supportedWorldVersions } from \"./common\";\nimport { ensureSystems } from \"./ensureSystems\";\nimport { waitForTransactionReceipt } from \"viem/actions\";\nimport { getWorldDeploy } from \"./getWorldDeploy\";\nimport { ensureFunctions } from \"./ensureFunctions\";\nimport { ensureModules } from \"./ensureModules\";\nimport { Table } from \"./configToTables\";\nimport { assertNamespaceOwner } from \"./assertNamespaceOwner\";\nimport { debug } from \"./debug\";\nimport { resourceLabel } from \"./resourceLabel\";\nimport { uniqueBy } from \"@latticexyz/common/utils\";\nimport { ensureContractsDeployed } from \"./ensureContractsDeployed\";\nimport { coreModuleBytecode, worldFactoryBytecode, worldFactoryContracts } from \"./ensureWorldFactory\";\n\ntype DeployOptions<configInput extends ConfigInput> = {\n  client: Client<Transport, Chain | undefined, Account>;\n  config: Config<configInput>;\n  worldAddress?: Address;\n};\n\n/**\n * Given a viem client and MUD config, we attempt to introspect the world\n * (or deploy a new one if no world address is provided) and do the minimal\n * amount of work to make the world match the config (e.g. deploy new tables,\n * replace systems, etc.)\n */\nexport async function deploy<configInput extends ConfigInput>({\n  client,\n  config,\n  worldAddress: existingWorldAddress,\n}: DeployOptions<configInput>): Promise<WorldDeploy> {\n  const tables = Object.values(config.tables) as Table[];\n  const systems = Object.values(config.systems);\n\n  await ensureDeployer(client);\n\n  // deploy all dependent contracts, because system registration, module install, etc. all expect these contracts to be callable.\n  await ensureContractsDeployed({\n    client,\n    contracts: [\n      ...worldFactoryContracts,\n      ...uniqueBy(systems, (system) => getAddress(system.address)).map((system) => ({\n        bytecode: system.bytecode,\n        deployedBytecodeSize: system.deployedBytecodeSize,\n        label: `${resourceLabel(system)} system`,\n      })),\n      ...uniqueBy(config.modules, (mod) => getAddress(mod.address)).map((mod) => ({\n        bytecode: mod.bytecode,\n        deployedBytecodeSize: mod.deployedBytecodeSize,\n        label: `${mod.name} module`,\n      })),\n    ],\n  });\n\n  const worldDeploy = existingWorldAddress\n    ? await getWorldDeploy(client, existingWorldAddress)\n    : await deployWorld(client);\n\n  if (!supportedStoreVersions.includes(worldDeploy.storeVersion)) {\n    throw new Error(`Unsupported Store version: ${worldDeploy.storeVersion}`);\n  }\n  if (!supportedWorldVersions.includes(worldDeploy.worldVersion)) {\n    throw new Error(`Unsupported World version: ${worldDeploy.worldVersion}`);\n  }\n\n  await assertNamespaceOwner({\n    client,\n    worldDeploy,\n    resourceIds: [...tables.map((table) => table.tableId), ...systems.map((system) => system.systemId)],\n  });\n\n  const tableTxs = await ensureTables({\n    client,\n    worldDeploy,\n    tables,\n  });\n  const systemTxs = await ensureSystems({\n    client,\n    worldDeploy,\n    systems,\n  });\n  const functionTxs = await ensureFunctions({\n    client,\n    worldDeploy,\n    functions: systems.flatMap((system) => system.functions),\n  });\n  const moduleTxs = await ensureModules({\n    client,\n    worldDeploy,\n    modules: config.modules,\n  });\n\n  const txs = [...tableTxs, ...systemTxs, ...functionTxs, ...moduleTxs];\n\n  // wait for each tx separately/serially, because parallelizing results in RPC errors\n  debug(\"waiting for all transactions to confirm\");\n  for (const tx of txs) {\n    await waitForTransactionReceipt(client, { hash: tx });\n    // TODO: throw if there was a revert?\n  }\n\n  debug(\"deploy complete\");\n  return worldDeploy;\n}\n","import { Account, Chain, Client, Transport } from \"viem\";\nimport { getBytecode, sendRawTransaction, sendTransaction, waitForTransactionReceipt } from \"viem/actions\";\nimport deployment from \"./create2/deployment.json\";\nimport { debug } from \"./debug\";\n\nexport const deployer = `0x${deployment.address}` as const;\n\nexport async function ensureDeployer(client: Client<Transport, Chain | undefined, Account>): Promise<void> {\n  const bytecode = await getBytecode(client, { address: deployer });\n  if (bytecode) {\n    debug(\"found create2 deployer at\", deployer);\n    return;\n  }\n\n  // send gas to signer\n  debug(\"sending gas for create2 deployer to signer at\", deployment.signerAddress);\n  const gasTx = await sendTransaction(client, {\n    chain: client.chain ?? null,\n    to: `0x${deployment.signerAddress}`,\n    value: BigInt(deployment.gasLimit) * BigInt(deployment.gasPrice),\n  });\n  const gasReceipt = await waitForTransactionReceipt(client, { hash: gasTx });\n  if (gasReceipt.status !== \"success\") {\n    console.error(\"failed to send gas to deployer signer\", gasReceipt);\n    throw new Error(\"failed to send gas to deployer signer\");\n  }\n\n  // deploy the deployer\n  debug(\"deploying create2 deployer at\", deployer);\n  const deployTx = await sendRawTransaction(client, { serializedTransaction: `0x${deployment.transaction}` });\n  const deployReceipt = await waitForTransactionReceipt(client, { hash: deployTx });\n  if (deployReceipt.contractAddress !== deployer) {\n    console.error(\"unexpected contract address for deployer\", deployReceipt);\n    throw new Error(\"unexpected contract address for deployer\");\n  }\n}\n","{\n  \"gasPrice\": 100000000000,\n  \"gasLimit\": 100000,\n  \"signerAddress\": \"3fab184622dc19b6109349b94811493bf2a45362\",\n  \"transaction\": \"f8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222\",\n  \"address\": \"4e59b44847b379578588920ca78fbf26c0b4956c\"\n}\n","import createDebug from \"debug\";\n\nexport const debug = createDebug(\"mud:cli\");\n","import { debug as parentDebug } from \"../debug\";\n\nexport const debug = parentDebug.extend(\"deploy\");\n","import { Account, Chain, Client, Log, Transport } from \"viem\";\nimport { waitForTransactionReceipt } from \"viem/actions\";\nimport { ensureWorldFactory, worldFactory } from \"./ensureWorldFactory\";\nimport WorldFactoryAbi from \"@latticexyz/world/out/WorldFactory.sol/WorldFactory.abi.json\" assert { type: \"json\" };\nimport { writeContract } from \"@latticexyz/common\";\nimport { debug } from \"./debug\";\nimport { logsToWorldDeploy } from \"./logsToWorldDeploy\";\nimport { WorldDeploy } from \"./common\";\n\nexport async function deployWorld(client: Client<Transport, Chain | undefined, Account>): Promise<WorldDeploy> {\n  await ensureWorldFactory(client);\n\n  debug(\"deploying world\");\n  const tx = await writeContract(client, {\n    chain: client.chain ?? null,\n    address: worldFactory,\n    abi: WorldFactoryAbi,\n    functionName: \"deployWorld\",\n  });\n\n  debug(\"waiting for world deploy\");\n  const receipt = await waitForTransactionReceipt(client, { hash: tx });\n  if (receipt.status !== \"success\") {\n    console.error(\"world deploy failed\", receipt);\n    throw new Error(\"world deploy failed\");\n  }\n\n  // TODO: remove type casting once https://github.com/wagmi-dev/viem/pull/1330 is merged\n  const deploy = logsToWorldDeploy(receipt.logs.map((log) => log as Log<bigint, number, false>));\n  debug(\"deployed world to\", deploy.address, \"at block\", deploy.deployBlock);\n\n  return { ...deploy, stateBlock: deploy.deployBlock };\n}\n","import coreModuleBuild from \"@latticexyz/world/out/CoreModule.sol/CoreModule.json\" assert { type: \"json\" };\nimport worldFactoryBuild from \"@latticexyz/world/out/WorldFactory.sol/WorldFactory.json\" assert { type: \"json\" };\nimport { Client, Transport, Chain, Account, Hex, parseAbi, getCreate2Address, encodeDeployData, size } from \"viem\";\nimport { deployer } from \"./ensureDeployer\";\nimport { salt } from \"./common\";\nimport { ensureContractsDeployed } from \"./ensureContractsDeployed\";\nimport { Contract } from \"./ensureContract\";\n\nexport const coreModuleDeployedBytecodeSize = size(coreModuleBuild.deployedBytecode.object as Hex);\nexport const coreModuleBytecode = encodeDeployData({\n  bytecode: coreModuleBuild.bytecode.object as Hex,\n  abi: [],\n});\n\nexport const coreModule = getCreate2Address({ from: deployer, bytecode: coreModuleBytecode, salt });\n\nexport const worldFactoryDeployedBytecodeSize = size(worldFactoryBuild.deployedBytecode.object as Hex);\nexport const worldFactoryBytecode = encodeDeployData({\n  bytecode: worldFactoryBuild.bytecode.object as Hex,\n  abi: parseAbi([\"constructor(address)\"]),\n  args: [coreModule],\n});\n\nexport const worldFactory = getCreate2Address({ from: deployer, bytecode: worldFactoryBytecode, salt });\n\nexport const worldFactoryContracts: readonly Contract[] = [\n  {\n    bytecode: coreModuleBytecode,\n    deployedBytecodeSize: coreModuleDeployedBytecodeSize,\n    label: \"core module\",\n  },\n  {\n    bytecode: worldFactoryBytecode,\n    deployedBytecodeSize: worldFactoryDeployedBytecodeSize,\n    label: \"world factory\",\n  },\n];\n\nexport async function ensureWorldFactory(\n  client: Client<Transport, Chain | undefined, Account>\n): Promise<readonly Hex[]> {\n  // WorldFactory constructor doesn't call CoreModule, only sets its address, so we can do these in parallel since the address is deterministic\n  return await ensureContractsDeployed({\n    client,\n    contracts: worldFactoryContracts,\n  });\n}\n","import { Abi, Address, Hex, padHex } from \"viem\";\nimport storeConfig from \"@latticexyz/store/mud.config\";\nimport worldConfig from \"@latticexyz/world/mud.config\";\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\" assert { type: \"json\" };\nimport IModuleAbi from \"@latticexyz/world-modules/out/IModule.sol/IModule.abi.json\" assert { type: \"json\" };\nimport { Tables, configToTables } from \"./configToTables\";\nimport { StoreConfig, helloStoreEvent } from \"@latticexyz/store\";\nimport { WorldConfig, helloWorldEvent } from \"@latticexyz/world\";\n\nexport const salt = padHex(\"0x\", { size: 32 });\n\n// https://eips.ethereum.org/EIPS/eip-170\nexport const contractSizeLimit = parseInt(\"6000\", 16);\n\n// TODO: add `as const` to mud config so these get more strongly typed (blocked by current config parsing not using readonly)\nexport const storeTables = configToTables(storeConfig);\nexport const worldTables = configToTables(worldConfig);\n\nexport const worldDeployEvents = [helloStoreEvent, helloWorldEvent] as const;\n\nexport const worldAbi = [...IBaseWorldAbi, ...IModuleAbi] as const;\n\n// Ideally, this should be an append-only list. Before adding more versions here, be sure to add backwards-compatible support for old Store/World versions.\nexport const supportedStoreVersions = [\"1.0.0-unaudited\"];\nexport const supportedWorldVersions = [\"1.0.0-unaudited\"];\n\nexport type WorldDeploy = {\n  readonly address: Address;\n  readonly worldVersion: string;\n  readonly storeVersion: string;\n  /** Block number where the world was deployed */\n  readonly deployBlock: bigint;\n  /**\n   * Block number at the time of fetching world deploy.\n   * We use this block number when requesting data from the chain to align chain state\n   * with the same block during the introspection steps of the deploy.\n   */\n  readonly stateBlock: bigint;\n};\n\nexport type WorldFunction = {\n  readonly signature: string;\n  readonly selector: Hex;\n  readonly systemId: Hex;\n  readonly systemFunctionSignature: string;\n  readonly systemFunctionSelector: Hex;\n};\n\nexport type DeterministicContract = {\n  readonly address: Address;\n  readonly bytecode: Hex;\n  readonly deployedBytecodeSize: number;\n  readonly abi: Abi;\n};\n\nexport type System = DeterministicContract & {\n  readonly namespace: string;\n  readonly name: string;\n  readonly systemId: Hex;\n  readonly allowAll: boolean;\n  readonly allowedAddresses: readonly Hex[];\n  readonly functions: readonly WorldFunction[];\n};\n\nexport type Module = DeterministicContract & {\n  readonly name: string;\n  readonly installAsRoot: boolean;\n  readonly installData: Hex; // TODO: figure out better naming for this\n};\n\nexport type ConfigInput = StoreConfig & WorldConfig;\nexport type Config<config extends ConfigInput> = {\n  readonly tables: Tables<config>;\n  readonly systems: readonly System[];\n  readonly modules: readonly Module[];\n};\n","import { resourceToHex } from \"@latticexyz/common\";\nimport { KeySchema, ValueSchema } from \"@latticexyz/protocol-parser\";\nimport { SchemaAbiType, StaticAbiType } from \"@latticexyz/schema-type\";\nimport { StoreConfig, resolveUserTypes } from \"@latticexyz/store\";\nimport { Hex } from \"viem\";\n\n// TODO: we shouldn't need this file once our config parsing returns nicely formed tables\n\ntype UserTypes<config extends StoreConfig = StoreConfig> = config[\"userTypes\"];\n// TODO: fix strong enum types and avoid every schema getting `{ [k: string]: \"uint8\" }`\n// type UserTypes<config extends StoreConfig = StoreConfig> = config[\"userTypes\"] & {\n//   [k in keyof config[\"enums\"]]: { internalType: \"uint8\" };\n// };\n\nexport type TableKey<\n  config extends StoreConfig = StoreConfig,\n  table extends config[\"tables\"][keyof config[\"tables\"]] = config[\"tables\"][keyof config[\"tables\"]]\n> = `${config[\"namespace\"]}_${table[\"name\"]}`;\n\nexport type Table<\n  config extends StoreConfig = StoreConfig,\n  table extends config[\"tables\"][keyof config[\"tables\"]] = config[\"tables\"][keyof config[\"tables\"]]\n> = {\n  readonly namespace: config[\"namespace\"];\n  readonly name: table[\"name\"];\n  readonly tableId: Hex;\n  readonly keySchema: table[\"keySchema\"] extends KeySchema<UserTypes<config>>\n    ? KeySchema & {\n        readonly [k in keyof table[\"keySchema\"]]: UserTypes<config>[table[\"keySchema\"][k]][\"internalType\"] extends StaticAbiType\n          ? UserTypes<config>[table[\"keySchema\"][k]][\"internalType\"]\n          : table[\"keySchema\"][k];\n      }\n    : KeySchema;\n  readonly valueSchema: table[\"valueSchema\"] extends ValueSchema<UserTypes<config>>\n    ? {\n        readonly [k in keyof table[\"valueSchema\"]]: UserTypes<config>[table[\"valueSchema\"][k]][\"internalType\"] extends SchemaAbiType\n          ? UserTypes<config>[table[\"valueSchema\"][k]][\"internalType\"]\n          : table[\"valueSchema\"][k];\n      }\n    : ValueSchema;\n};\n\nexport type Tables<config extends StoreConfig = StoreConfig> = {\n  readonly [k in keyof config[\"tables\"] as TableKey<config, config[\"tables\"][k]>]: Table<config, config[\"tables\"][k]>;\n};\n\nexport function configToTables<config extends StoreConfig>(config: config): Tables<config> {\n  const userTypes = {\n    ...config.userTypes,\n    ...Object.fromEntries(Object.entries(config.enums).map(([key]) => [key, { internalType: \"uint8\" }] as const)),\n  };\n  return Object.fromEntries(\n    Object.entries(config.tables).map(([tableName, table]) => [\n      `${config.namespace}_${tableName}` satisfies TableKey<config, config[\"tables\"][keyof config[\"tables\"]]>,\n      {\n        namespace: config.namespace,\n        name: table.name,\n        tableId: resourceToHex({\n          type: table.offchainOnly ? \"offchainTable\" : \"table\",\n          namespace: config.namespace,\n          name: table.name,\n        }),\n        keySchema: resolveUserTypes(table.keySchema, userTypes) as any,\n        valueSchema: resolveUserTypes(table.valueSchema, userTypes) as any,\n      } satisfies Table<config, config[\"tables\"][keyof config[\"tables\"]]>,\n    ])\n  ) as Tables<config>;\n}\n","import { Client, Transport, Chain, Account, Hex } from \"viem\";\nimport { waitForTransactionReceipt } from \"viem/actions\";\nimport { debug } from \"./debug\";\nimport { Contract, ensureContract } from \"./ensureContract\";\n\nexport async function ensureContractsDeployed({\n  client,\n  contracts,\n}: {\n  readonly client: Client<Transport, Chain | undefined, Account>;\n  readonly contracts: readonly Contract[];\n}): Promise<readonly Hex[]> {\n  const txs = (await Promise.all(contracts.map((contract) => ensureContract({ client, ...contract })))).flat();\n\n  if (txs.length) {\n    debug(\"waiting for contracts\");\n    // wait for each tx separately/serially, because parallelizing results in RPC errors\n    for (const tx of txs) {\n      await waitForTransactionReceipt(client, { hash: tx });\n      // TODO: throw if there was a revert?\n    }\n  }\n\n  return txs;\n}\n","import { Client, Transport, Chain, Account, concatHex, getCreate2Address, Hex, size } from \"viem\";\nimport { getBytecode } from \"viem/actions\";\nimport { deployer } from \"./ensureDeployer\";\nimport { contractSizeLimit, salt } from \"./common\";\nimport { sendTransaction } from \"@latticexyz/common\";\nimport { debug } from \"./debug\";\nimport pRetry from \"p-retry\";\nimport { wait } from \"@latticexyz/common/utils\";\n\nexport type Contract = {\n  bytecode: Hex;\n  deployedBytecodeSize: number;\n  label?: string;\n};\n\nexport async function ensureContract({\n  client,\n  bytecode,\n  deployedBytecodeSize,\n  label = \"contract\",\n}: {\n  readonly client: Client<Transport, Chain | undefined, Account>;\n} & Contract): Promise<readonly Hex[]> {\n  const address = getCreate2Address({ from: deployer, salt, bytecode });\n\n  const contractCode = await getBytecode(client, { address, blockTag: \"pending\" });\n  if (contractCode) {\n    debug(\"found\", label, \"at\", address);\n    return [];\n  }\n\n  if (deployedBytecodeSize > contractSizeLimit) {\n    console.warn(\n      `\\nBytecode for ${label} (${deployedBytecodeSize} bytes) is over the contract size limit (${contractSizeLimit} bytes). Run \\`forge build --sizes\\` for more info.\\n`\n    );\n  } else if (deployedBytecodeSize > contractSizeLimit * 0.95) {\n    console.warn(\n      `\\nBytecode for ${label} (${deployedBytecodeSize} bytes) is almost over the contract size limit (${contractSizeLimit} bytes). Run \\`forge build --sizes\\` for more info.\\n`\n    );\n  }\n\n  debug(\"deploying\", label, \"at\", address);\n  return [\n    await pRetry(\n      () =>\n        sendTransaction(client, {\n          chain: client.chain ?? null,\n          to: deployer,\n          data: concatHex([salt, bytecode]),\n        }),\n      {\n        retries: 3,\n        onFailedAttempt: async (error) => {\n          const delay = error.attemptNumber * 500;\n          debug(`failed to deploy ${label}, retrying in ${delay}ms...`);\n          await wait(delay);\n        },\n      }\n    ),\n  ];\n}\n","import { AbiEventSignatureNotFoundError, Log, decodeEventLog, hexToString, parseAbi, trim } from \"viem\";\nimport { WorldDeploy, worldDeployEvents } from \"./common\";\nimport { isDefined } from \"@latticexyz/common/utils\";\n\nexport function logsToWorldDeploy(logs: readonly Log<bigint, number, false>[]): Omit<WorldDeploy, \"stateBlock\"> {\n  const deployLogs = logs\n    .map((log) => {\n      try {\n        return {\n          ...log,\n          ...decodeEventLog({\n            strict: true,\n            abi: parseAbi(worldDeployEvents),\n            topics: log.topics,\n            data: log.data,\n          }),\n        };\n      } catch (error: unknown) {\n        if (error instanceof AbiEventSignatureNotFoundError) {\n          return;\n        }\n        throw error;\n      }\n    })\n    .filter(isDefined);\n\n  // TODO: should this test for/validate that only one of each of these events is present? and that the address/block number don't change between each?\n  const { address, deployBlock, worldVersion, storeVersion } = deployLogs.reduce<Partial<WorldDeploy>>(\n    (deploy, log) => ({\n      ...deploy,\n      address: log.address,\n      deployBlock: log.blockNumber,\n      ...(log.eventName === \"HelloWorld\"\n        ? { worldVersion: hexToString(trim(log.args.worldVersion, { dir: \"right\" })) }\n        : null),\n      ...(log.eventName === \"HelloStore\"\n        ? { storeVersion: hexToString(trim(log.args.storeVersion, { dir: \"right\" })) }\n        : null),\n    }),\n    {}\n  );\n\n  if (address == null) throw new Error(\"could not find world address\");\n  if (deployBlock == null) throw new Error(\"could not find world deploy block number\");\n  if (worldVersion == null) throw new Error(\"could not find world version\");\n  if (storeVersion == null) throw new Error(\"could not find store version\");\n\n  return { address, deployBlock, worldVersion, storeVersion };\n}\n","import { Client, Transport, Chain, Account, Hex } from \"viem\";\nimport { Table } from \"./configToTables\";\nimport { writeContract } from \"@latticexyz/common\";\nimport { WorldDeploy, worldAbi } from \"./common\";\nimport { valueSchemaToFieldLayoutHex, keySchemaToHex, valueSchemaToHex } from \"@latticexyz/protocol-parser\";\nimport { debug } from \"./debug\";\nimport { resourceLabel } from \"./resourceLabel\";\nimport { getTables } from \"./getTables\";\nimport pRetry from \"p-retry\";\nimport { wait } from \"@latticexyz/common/utils\";\n\nexport async function ensureTables({\n  client,\n  worldDeploy,\n  tables,\n}: {\n  readonly client: Client<Transport, Chain | undefined, Account>;\n  readonly worldDeploy: WorldDeploy;\n  readonly tables: readonly Table[];\n}): Promise<readonly Hex[]> {\n  const worldTables = await getTables({ client, worldDeploy });\n  const worldTableIds = worldTables.map((table) => table.tableId);\n\n  const existingTables = tables.filter((table) => worldTableIds.includes(table.tableId));\n  if (existingTables.length) {\n    debug(\"existing tables\", existingTables.map(resourceLabel).join(\", \"));\n  }\n\n  const missingTables = tables.filter((table) => !worldTableIds.includes(table.tableId));\n  if (missingTables.length) {\n    debug(\"registering tables\", missingTables.map(resourceLabel).join(\", \"));\n    return await Promise.all(\n      missingTables.map((table) =>\n        pRetry(\n          () =>\n            writeContract(client, {\n              chain: client.chain ?? null,\n              address: worldDeploy.address,\n              abi: worldAbi,\n              // TODO: replace with batchCall (https://github.com/latticexyz/mud/issues/1645)\n              functionName: \"registerTable\",\n              args: [\n                table.tableId,\n                valueSchemaToFieldLayoutHex(table.valueSchema),\n                keySchemaToHex(table.keySchema),\n                valueSchemaToHex(table.valueSchema),\n                Object.keys(table.keySchema),\n                Object.keys(table.valueSchema),\n              ],\n            }),\n          {\n            retries: 3,\n            onFailedAttempt: async (error) => {\n              const delay = error.attemptNumber * 500;\n              debug(`failed to register table ${resourceLabel(table)}, retrying in ${delay}ms...`);\n              await wait(delay);\n            },\n          }\n        )\n      )\n    );\n  }\n\n  return [];\n}\n","export function resourceLabel({ namespace, name }: { readonly namespace: string; readonly name: string }): string {\n  return `${namespace}:${name}`;\n}\n","import { Client, parseAbiItem, decodeAbiParameters, parseAbiParameters } from \"viem\";\nimport { Table } from \"./configToTables\";\nimport { hexToResource } from \"@latticexyz/common\";\nimport { WorldDeploy, storeTables } from \"./common\";\nimport { debug } from \"./debug\";\nimport { storeSetRecordEvent } from \"@latticexyz/store\";\nimport { getLogs } from \"viem/actions\";\nimport { KeySchema, ValueSchema, decodeKey, decodeValueArgs, hexToSchema } from \"@latticexyz/protocol-parser\";\n\nexport async function getTables({\n  client,\n  worldDeploy,\n}: {\n  readonly client: Client;\n  readonly worldDeploy: WorldDeploy;\n}): Promise<readonly Table[]> {\n  // This assumes we only use `Tables._set(...)`, which is true as of this writing.\n  // TODO: PR to viem's getLogs to accept topics array so we can filter on all store events and quickly recreate this table's current state\n  // TODO: consider moving this to a batched getRecord for Tables table\n\n  debug(\"looking up tables for\", worldDeploy.address);\n  const logs = await getLogs(client, {\n    strict: true,\n    // this may fail for certain RPC providers with block range limits\n    // if so, could potentially use our fetchLogs helper (which does pagination)\n    fromBlock: worldDeploy.deployBlock,\n    toBlock: worldDeploy.stateBlock,\n    address: worldDeploy.address,\n    event: parseAbiItem(storeSetRecordEvent),\n    args: { tableId: storeTables.store_Tables.tableId },\n  });\n\n  // TODO: combine with store-sync logToTable and export from somewhere\n  const tables = logs.map((log) => {\n    const { tableId } = decodeKey(storeTables.store_Tables.keySchema, log.args.keyTuple);\n    const { namespace, name } = hexToResource(tableId);\n    const value = decodeValueArgs(storeTables.store_Tables.valueSchema, log.args);\n\n    // TODO: migrate to better helper\n    const keySchemaFields = hexToSchema(value.keySchema);\n    const valueSchemaFields = hexToSchema(value.valueSchema);\n    const keyNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), value.abiEncodedKeyNames)[0];\n    const fieldNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), value.abiEncodedFieldNames)[0];\n\n    const valueAbiTypes = [...valueSchemaFields.staticFields, ...valueSchemaFields.dynamicFields];\n\n    const keySchema = Object.fromEntries(\n      keySchemaFields.staticFields.map((abiType, i) => [keyNames[i], abiType])\n    ) as KeySchema;\n    const valueSchema = Object.fromEntries(valueAbiTypes.map((abiType, i) => [fieldNames[i], abiType])) as ValueSchema;\n\n    return { namespace, name, tableId, keySchema, valueSchema } as const;\n  });\n  // TODO: filter/detect duplicates?\n\n  debug(\"found\", tables.length, \"tables for\", worldDeploy.address);\n\n  return tables;\n}\n","import { Client, Transport, Chain, Account, Hex, getAddress } from \"viem\";\nimport { writeContract } from \"@latticexyz/common\";\nimport { System, WorldDeploy, worldAbi } from \"./common\";\nimport { debug } from \"./debug\";\nimport { resourceLabel } from \"./resourceLabel\";\nimport { getSystems } from \"./getSystems\";\nimport { getResourceAccess } from \"./getResourceAccess\";\nimport { uniqueBy, wait } from \"@latticexyz/common/utils\";\nimport pRetry from \"p-retry\";\nimport { ensureContractsDeployed } from \"./ensureContractsDeployed\";\n\nexport async function ensureSystems({\n  client,\n  worldDeploy,\n  systems,\n}: {\n  readonly client: Client<Transport, Chain | undefined, Account>;\n  readonly worldDeploy: WorldDeploy;\n  readonly systems: readonly System[];\n}): Promise<readonly Hex[]> {\n  const [worldSystems, worldAccess] = await Promise.all([\n    getSystems({ client, worldDeploy }),\n    getResourceAccess({ client, worldDeploy }),\n  ]);\n  const systemIds = systems.map((system) => system.systemId);\n  const currentAccess = worldAccess.filter(({ resourceId }) => systemIds.includes(resourceId));\n  const desiredAccess = systems.flatMap((system) =>\n    system.allowedAddresses.map((address) => ({ resourceId: system.systemId, address }))\n  );\n\n  const accessToAdd = desiredAccess.filter(\n    (access) =>\n      !currentAccess.some(\n        ({ resourceId, address }) =>\n          resourceId === access.resourceId && getAddress(address) === getAddress(access.address)\n      )\n  );\n\n  const accessToRemove = currentAccess.filter(\n    (access) =>\n      !desiredAccess.some(\n        ({ resourceId, address }) =>\n          resourceId === access.resourceId && getAddress(address) === getAddress(access.address)\n      )\n  );\n\n  // TODO: move each system access+registration to batch call to be atomic\n\n  if (accessToRemove.length) {\n    debug(\"revoking\", accessToRemove.length, \"access grants\");\n  }\n  if (accessToAdd.length) {\n    debug(\"adding\", accessToAdd.length, \"access grants\");\n  }\n\n  const accessTxs = [\n    ...accessToRemove.map((access) =>\n      pRetry(\n        () =>\n          writeContract(client, {\n            chain: client.chain ?? null,\n            address: worldDeploy.address,\n            abi: worldAbi,\n            functionName: \"revokeAccess\",\n            args: [access.resourceId, access.address],\n          }),\n        {\n          retries: 3,\n          onFailedAttempt: async (error) => {\n            const delay = error.attemptNumber * 500;\n            debug(`failed to revoke access, retrying in ${delay}ms...`);\n            await wait(delay);\n          },\n        }\n      )\n    ),\n    ...accessToAdd.map((access) =>\n      pRetry(\n        () =>\n          writeContract(client, {\n            chain: client.chain ?? null,\n            address: worldDeploy.address,\n            abi: worldAbi,\n            functionName: \"grantAccess\",\n            args: [access.resourceId, access.address],\n          }),\n        {\n          retries: 3,\n          onFailedAttempt: async (error) => {\n            const delay = error.attemptNumber * 500;\n            debug(`failed to grant access, retrying in ${delay}ms...`);\n            await wait(delay);\n          },\n        }\n      )\n    ),\n  ];\n\n  const existingSystems = systems.filter((system) =>\n    worldSystems.some(\n      (worldSystem) =>\n        worldSystem.systemId === system.systemId && getAddress(worldSystem.address) === getAddress(system.address)\n    )\n  );\n  if (existingSystems.length) {\n    debug(\"existing systems\", existingSystems.map(resourceLabel).join(\", \"));\n  }\n  const existingSystemIds = existingSystems.map((system) => system.systemId);\n\n  const missingSystems = systems.filter((system) => !existingSystemIds.includes(system.systemId));\n  if (!missingSystems.length) return [];\n\n  const systemsToUpgrade = missingSystems.filter((system) =>\n    worldSystems.some(\n      (worldSystem) =>\n        worldSystem.systemId === system.systemId && getAddress(worldSystem.address) !== getAddress(system.address)\n    )\n  );\n  if (systemsToUpgrade.length) {\n    debug(\"upgrading systems\", systemsToUpgrade.map(resourceLabel).join(\", \"));\n  }\n\n  const systemsToAdd = missingSystems.filter(\n    (system) => !worldSystems.some((worldSystem) => worldSystem.systemId === system.systemId)\n  );\n  if (systemsToAdd.length) {\n    debug(\"registering new systems\", systemsToAdd.map(resourceLabel).join(\", \"));\n  }\n\n  await ensureContractsDeployed({\n    client,\n    contracts: uniqueBy(missingSystems, (system) => getAddress(system.address)).map((system) => ({\n      bytecode: system.bytecode,\n      deployedBytecodeSize: system.deployedBytecodeSize,\n      label: `${resourceLabel(system)} system`,\n    })),\n  });\n\n  const registerTxs = missingSystems.map((system) =>\n    pRetry(\n      () =>\n        writeContract(client, {\n          chain: client.chain ?? null,\n          address: worldDeploy.address,\n          abi: worldAbi,\n          // TODO: replace with batchCall (https://github.com/latticexyz/mud/issues/1645)\n          functionName: \"registerSystem\",\n          args: [system.systemId, system.address, system.allowAll],\n        }),\n      {\n        retries: 3,\n        onFailedAttempt: async (error) => {\n          const delay = error.attemptNumber * 500;\n          debug(`failed to register system ${resourceLabel(system)}, retrying in ${delay}ms...`);\n          await wait(delay);\n        },\n      }\n    )\n  );\n\n  return await Promise.all([...accessTxs, ...registerTxs]);\n}\n","import { Client, parseAbiItem, Hex } from \"viem\";\nimport { getLogs } from \"viem/actions\";\nimport { storeSpliceStaticDataEvent } from \"@latticexyz/store\";\nimport { WorldDeploy, storeTables } from \"./common\";\nimport { debug } from \"./debug\";\n\nexport async function getResourceIds({\n  client,\n  worldDeploy,\n}: {\n  readonly client: Client;\n  readonly worldDeploy: WorldDeploy;\n}): Promise<readonly Hex[]> {\n  // This assumes we only use `ResourceIds._setExists(true)`, which is true as of this writing.\n  // TODO: PR to viem's getLogs to accept topics array so we can filter on all store events and quickly recreate this table's current state\n\n  debug(\"looking up resource IDs for\", worldDeploy.address);\n  const logs = await getLogs(client, {\n    strict: true,\n    address: worldDeploy.address,\n    fromBlock: worldDeploy.deployBlock,\n    toBlock: worldDeploy.stateBlock,\n    event: parseAbiItem(storeSpliceStaticDataEvent),\n    args: { tableId: storeTables.store_ResourceIds.tableId },\n  });\n\n  const resourceIds = logs.map((log) => log.args.keyTuple[0]);\n  debug(\"found\", resourceIds.length, \"resource IDs for\", worldDeploy.address);\n\n  return resourceIds;\n}\n","import { System, WorldDeploy, worldTables } from \"./common\";\nimport { Client } from \"viem\";\nimport { getResourceIds } from \"./getResourceIds\";\nimport { hexToResource } from \"@latticexyz/common\";\nimport { getTableValue } from \"./getTableValue\";\nimport { debug } from \"./debug\";\nimport { resourceLabel } from \"./resourceLabel\";\nimport { getFunctions } from \"./getFunctions\";\nimport { getResourceAccess } from \"./getResourceAccess\";\n\nexport async function getSystems({\n  client,\n  worldDeploy,\n}: {\n  readonly client: Client;\n  readonly worldDeploy: WorldDeploy;\n}): Promise<readonly Omit<System, \"abi\" | \"bytecode\" | \"deployedBytecodeSize\">[]> {\n  const [resourceIds, functions, resourceAccess] = await Promise.all([\n    getResourceIds({ client, worldDeploy }),\n    getFunctions({ client, worldDeploy }),\n    getResourceAccess({ client, worldDeploy }),\n  ]);\n  const systems = resourceIds.map(hexToResource).filter((resource) => resource.type === \"system\");\n\n  debug(\"looking up systems\", systems.map(resourceLabel).join(\", \"));\n  return await Promise.all(\n    systems.map(async (system) => {\n      const { system: address, publicAccess } = await getTableValue({\n        client,\n        worldDeploy,\n        table: worldTables.world_Systems,\n        key: { systemId: system.resourceId },\n      });\n      const systemFunctions = functions.filter((func) => func.systemId === system.resourceId);\n      return {\n        address,\n        namespace: system.namespace,\n        name: system.name,\n        systemId: system.resourceId,\n        allowAll: publicAccess,\n        allowedAddresses: resourceAccess\n          .filter(({ resourceId }) => resourceId === system.resourceId)\n          .map(({ address }) => address),\n        functions: systemFunctions,\n      };\n    })\n  );\n}\n","import { SchemaToPrimitives, decodeValueArgs, encodeKey } from \"@latticexyz/protocol-parser\";\nimport { WorldDeploy, worldAbi } from \"./common\";\nimport { Client } from \"viem\";\nimport { readContract } from \"viem/actions\";\nimport { Table } from \"./configToTables\";\n\nexport async function getTableValue<table extends Table>({\n  client,\n  worldDeploy,\n  table,\n  key,\n}: {\n  readonly client: Client;\n  readonly worldDeploy: WorldDeploy;\n  readonly table: table;\n  readonly key: SchemaToPrimitives<table[\"keySchema\"]>;\n}): Promise<SchemaToPrimitives<table[\"valueSchema\"]>> {\n  const [staticData, encodedLengths, dynamicData] = await readContract(client, {\n    blockNumber: worldDeploy.stateBlock,\n    address: worldDeploy.address,\n    abi: worldAbi,\n    functionName: \"getRecord\",\n    args: [table.tableId, encodeKey(table.keySchema, key)],\n  });\n  return decodeValueArgs(table.valueSchema, {\n    staticData,\n    encodedLengths,\n    dynamicData,\n  });\n}\n","import { Client, getFunctionSelector, parseAbiItem } from \"viem\";\nimport { WorldDeploy, WorldFunction, worldTables } from \"./common\";\nimport { debug } from \"./debug\";\nimport { storeSetRecordEvent } from \"@latticexyz/store\";\nimport { getLogs } from \"viem/actions\";\nimport { decodeValueArgs } from \"@latticexyz/protocol-parser\";\nimport { getTableValue } from \"./getTableValue\";\nimport { hexToResource } from \"@latticexyz/common\";\n\nexport async function getFunctions({\n  client,\n  worldDeploy,\n}: {\n  readonly client: Client;\n  readonly worldDeploy: WorldDeploy;\n}): Promise<readonly WorldFunction[]> {\n  // This assumes we only use `FunctionSelectors._set(...)`, which is true as of this writing.\n  debug(\"looking up function signatures for\", worldDeploy.address);\n  const logs = await getLogs(client, {\n    strict: true,\n    fromBlock: worldDeploy.deployBlock,\n    toBlock: worldDeploy.stateBlock,\n    address: worldDeploy.address,\n    event: parseAbiItem(storeSetRecordEvent),\n    args: { tableId: worldTables.world_FunctionSignatures.tableId },\n  });\n\n  const signatures = logs.map((log) => {\n    const value = decodeValueArgs(worldTables.world_FunctionSignatures.valueSchema, log.args);\n    return value.functionSignature;\n  });\n  debug(\"found\", signatures.length, \"function signatures for\", worldDeploy.address);\n\n  // TODO: parallelize with a bulk getRecords\n  const functions = await Promise.all(\n    signatures.map(async (signature) => {\n      const selector = getFunctionSelector(signature);\n      const { systemId, systemFunctionSelector } = await getTableValue({\n        client,\n        worldDeploy,\n        table: worldTables.world_FunctionSelectors,\n        key: { functionSelector: selector },\n      });\n      const { namespace, name } = hexToResource(systemId);\n      // TODO: find away around undoing contract logic (https://github.com/latticexyz/mud/issues/1708)\n      const systemFunctionSignature = namespace === \"\" ? signature : signature.replace(`${namespace}_${name}_`, \"\");\n      return {\n        signature,\n        selector,\n        systemId,\n        systemFunctionSignature,\n        systemFunctionSelector,\n      };\n    })\n  );\n\n  return functions;\n}\n","import { Client, parseAbiItem, Hex, Address, getAddress } from \"viem\";\nimport { WorldDeploy, worldTables } from \"./common\";\nimport { debug } from \"./debug\";\nimport { storeSpliceStaticDataEvent } from \"@latticexyz/store\";\nimport { getLogs } from \"viem/actions\";\nimport { decodeKey } from \"@latticexyz/protocol-parser\";\nimport { getTableValue } from \"./getTableValue\";\n\nexport async function getResourceAccess({\n  client,\n  worldDeploy,\n}: {\n  readonly client: Client;\n  readonly worldDeploy: WorldDeploy;\n}): Promise<readonly { readonly resourceId: Hex; readonly address: Address }[]> {\n  // This assumes we only use `ResourceAccess._set(...)`, which is true as of this writing.\n  // TODO: PR to viem's getLogs to accept topics array so we can filter on all store events and quickly recreate this table's current state\n\n  debug(\"looking up resource access for\", worldDeploy.address);\n\n  const logs = await getLogs(client, {\n    strict: true,\n    fromBlock: worldDeploy.deployBlock,\n    toBlock: worldDeploy.stateBlock,\n    address: worldDeploy.address,\n    // our usage of `ResourceAccess._set(...)` emits a splice instead of set record\n    // TODO: https://github.com/latticexyz/mud/issues/479\n    event: parseAbiItem(storeSpliceStaticDataEvent),\n    args: { tableId: worldTables.world_ResourceAccess.tableId },\n  });\n\n  const keys = logs.map((log) => decodeKey(worldTables.world_ResourceAccess.keySchema, log.args.keyTuple));\n\n  const access = (\n    await Promise.all(\n      keys.map(\n        async (key) =>\n          [key, await getTableValue({ client, worldDeploy, table: worldTables.world_ResourceAccess, key })] as const\n      )\n    )\n  )\n    .filter(([, value]) => value.access)\n    .map(([key]) => ({\n      resourceId: key.resourceId,\n      address: getAddress(key.caller),\n    }));\n\n  debug(\"found\", access.length, \"resource<>address access pairs\");\n\n  return access;\n}\n","import { Client, Address, getAddress, parseAbi } from \"viem\";\nimport { getBlockNumber, getLogs } from \"viem/actions\";\nimport { WorldDeploy, worldDeployEvents } from \"./common\";\nimport { debug } from \"./debug\";\nimport { logsToWorldDeploy } from \"./logsToWorldDeploy\";\n\nconst deploys = new Map<Address, WorldDeploy>();\n\nexport async function getWorldDeploy(client: Client, worldAddress: Address): Promise<WorldDeploy> {\n  const address = getAddress(worldAddress);\n\n  let deploy = deploys.get(address);\n  if (deploy != null) {\n    return deploy;\n  }\n\n  debug(\"looking up world deploy for\", address);\n\n  const stateBlock = await getBlockNumber(client);\n  const logs = await getLogs(client, {\n    strict: true,\n    address,\n    events: parseAbi(worldDeployEvents),\n    // this may fail for certain RPC providers with block range limits\n    // if so, could potentially use our fetchLogs helper (which does pagination)\n    fromBlock: \"earliest\",\n    toBlock: stateBlock,\n  });\n\n  deploy = {\n    ...logsToWorldDeploy(logs),\n    stateBlock,\n  };\n  deploys.set(address, deploy);\n\n  debug(\"found world deploy for\", address, \"at block\", deploy.deployBlock);\n\n  return deploy;\n}\n","import { Client, Transport, Chain, Account, Hex } from \"viem\";\nimport { hexToResource, writeContract } from \"@latticexyz/common\";\nimport { WorldDeploy, WorldFunction, worldAbi } from \"./common\";\nimport { debug } from \"./debug\";\nimport { getFunctions } from \"./getFunctions\";\nimport pRetry from \"p-retry\";\nimport { wait } from \"@latticexyz/common/utils\";\n\nexport async function ensureFunctions({\n  client,\n  worldDeploy,\n  functions,\n}: {\n  readonly client: Client<Transport, Chain | undefined, Account>;\n  readonly worldDeploy: WorldDeploy;\n  readonly functions: readonly WorldFunction[];\n}): Promise<readonly Hex[]> {\n  const worldFunctions = await getFunctions({ client, worldDeploy });\n  const worldSelectorToFunction = Object.fromEntries(worldFunctions.map((func) => [func.selector, func]));\n\n  const toSkip = functions.filter((func) => worldSelectorToFunction[func.selector]);\n  const toAdd = functions.filter((func) => !toSkip.includes(func));\n\n  if (toSkip.length) {\n    debug(\"functions already registered:\", toSkip.map((func) => func.signature).join(\", \"));\n    const wrongSystem = toSkip.filter((func) => func.systemId !== worldSelectorToFunction[func.selector]?.systemId);\n    if (wrongSystem.length) {\n      console.warn(\n        \"found\",\n        wrongSystem.length,\n        \"functions already registered but pointing at a different system ID:\",\n        wrongSystem.map((func) => func.signature).join(\", \")\n      );\n    }\n  }\n\n  if (!toAdd.length) return [];\n\n  debug(\"registering functions:\", toAdd.map((func) => func.signature).join(\", \"));\n\n  return Promise.all(\n    toAdd.map((func) => {\n      const { namespace } = hexToResource(func.systemId);\n      if (namespace === \"\") {\n        return pRetry(\n          () =>\n            writeContract(client, {\n              chain: client.chain ?? null,\n              address: worldDeploy.address,\n              abi: worldAbi,\n              // TODO: replace with batchCall (https://github.com/latticexyz/mud/issues/1645)\n              functionName: \"registerRootFunctionSelector\",\n              args: [func.systemId, func.systemFunctionSignature, func.systemFunctionSelector],\n            }),\n          {\n            retries: 3,\n            onFailedAttempt: async (error) => {\n              const delay = error.attemptNumber * 500;\n              debug(`failed to register function ${func.signature}, retrying in ${delay}ms...`);\n              await wait(delay);\n            },\n          }\n        );\n      }\n      return pRetry(\n        () =>\n          writeContract(client, {\n            chain: client.chain ?? null,\n            address: worldDeploy.address,\n            abi: worldAbi,\n            // TODO: replace with batchCall (https://github.com/latticexyz/mud/issues/1645)\n            functionName: \"registerFunctionSelector\",\n            args: [func.systemId, func.systemFunctionSignature],\n          }),\n        {\n          retries: 3,\n          onFailedAttempt: async (error) => {\n            const delay = error.attemptNumber * 500;\n            debug(`failed to register function ${func.signature}, retrying in ${delay}ms...`);\n            await wait(delay);\n          },\n        }\n      );\n    })\n  );\n}\n","import { Client, Transport, Chain, Account, Hex, BaseError, getAddress } from \"viem\";\nimport { writeContract } from \"@latticexyz/common\";\nimport { Module, WorldDeploy, worldAbi } from \"./common\";\nimport { debug } from \"./debug\";\nimport { isDefined, uniqueBy, wait } from \"@latticexyz/common/utils\";\nimport pRetry from \"p-retry\";\nimport { ensureContractsDeployed } from \"./ensureContractsDeployed\";\n\nexport async function ensureModules({\n  client,\n  worldDeploy,\n  modules,\n}: {\n  readonly client: Client<Transport, Chain | undefined, Account>;\n  readonly worldDeploy: WorldDeploy;\n  readonly modules: readonly Module[];\n}): Promise<readonly Hex[]> {\n  if (!modules.length) return [];\n\n  await ensureContractsDeployed({\n    client,\n    contracts: uniqueBy(modules, (mod) => getAddress(mod.address)).map((mod) => ({\n      bytecode: mod.bytecode,\n      deployedBytecodeSize: mod.deployedBytecodeSize,\n      label: `${mod.name} module`,\n    })),\n  });\n\n  debug(\"installing modules:\", modules.map((mod) => mod.name).join(\", \"));\n  return (\n    await Promise.all(\n      modules.map((mod) =>\n        pRetry(\n          async () => {\n            try {\n              return mod.installAsRoot\n                ? await writeContract(client, {\n                    chain: client.chain ?? null,\n                    address: worldDeploy.address,\n                    abi: worldAbi,\n                    // TODO: replace with batchCall (https://github.com/latticexyz/mud/issues/1645)\n                    functionName: \"installRootModule\",\n                    args: [mod.address, mod.installData],\n                  })\n                : await writeContract(client, {\n                    chain: client.chain ?? null,\n                    address: worldDeploy.address,\n                    abi: worldAbi,\n                    // TODO: replace with batchCall (https://github.com/latticexyz/mud/issues/1645)\n                    functionName: \"installModule\",\n                    args: [mod.address, mod.installData],\n                  });\n            } catch (error) {\n              if (error instanceof BaseError && error.message.includes(\"Module_AlreadyInstalled\")) {\n                debug(`module ${mod.name} already installed`);\n                return;\n              }\n              throw error;\n            }\n          },\n          {\n            retries: 3,\n            onFailedAttempt: async (error) => {\n              const delay = error.attemptNumber * 500;\n              debug(`failed to install module ${mod.name}, retrying in ${delay}ms...`);\n              await wait(delay);\n            },\n          }\n        )\n      )\n    )\n  ).filter(isDefined);\n}\n","import { Account, Chain, Client, Hex, Transport, getAddress } from \"viem\";\nimport { WorldDeploy, worldTables } from \"./common\";\nimport { hexToResource, resourceToHex } from \"@latticexyz/common\";\nimport { getResourceIds } from \"./getResourceIds\";\nimport { getTableValue } from \"./getTableValue\";\n\nexport async function assertNamespaceOwner({\n  client,\n  worldDeploy,\n  resourceIds,\n}: {\n  readonly client: Client<Transport, Chain | undefined, Account>;\n  readonly worldDeploy: WorldDeploy;\n  readonly resourceIds: readonly Hex[];\n}): Promise<void> {\n  const desiredNamespaces = Array.from(new Set(resourceIds.map((resourceId) => hexToResource(resourceId).namespace)));\n  const existingResourceIds = await getResourceIds({ client, worldDeploy });\n  const existingNamespaces = Array.from(\n    new Set(existingResourceIds.map((resourceId) => hexToResource(resourceId).namespace))\n  );\n\n  const namespaces = desiredNamespaces.filter((namespace) => existingNamespaces.includes(namespace));\n  const namespaceOwners = await Promise.all(\n    namespaces.map(async (namespace) => {\n      const { owner } = await getTableValue({\n        client,\n        worldDeploy,\n        table: worldTables.world_NamespaceOwner,\n        key: { namespaceId: resourceToHex({ type: \"namespace\", namespace, name: \"\" }) },\n      });\n      return [namespace, owner];\n    })\n  );\n\n  const unauthorizedNamespaces = namespaceOwners\n    .filter(([, owner]) => getAddress(owner) !== getAddress(client.account.address))\n    .map(([namespace]) => namespace);\n\n  if (unauthorizedNamespaces.length) {\n    throw new Error(`You are attempting to deploy to namespaces you do not own: ${unauthorizedNamespaces.join(\", \")}`);\n  }\n}\n","import { resolveWorldConfig } from \"@latticexyz/world\";\nimport { Config, ConfigInput, WorldFunction, salt } from \"./common\";\nimport { resourceToHex, hexToResource } from \"@latticexyz/common\";\nimport { resolveWithContext } from \"@latticexyz/config\";\nimport { encodeField } from \"@latticexyz/protocol-parser\";\nimport { SchemaAbiType, SchemaAbiTypeToPrimitiveType } from \"@latticexyz/schema-type\";\nimport {\n  getFunctionSelector,\n  Hex,\n  getCreate2Address,\n  getAddress,\n  hexToBytes,\n  Abi,\n  bytesToHex,\n  getFunctionSignature,\n} from \"viem\";\nimport { getExistingContracts } from \"../utils/getExistingContracts\";\nimport { defaultModuleContracts } from \"../utils/modules/constants\";\nimport { getContractData } from \"../utils/utils/getContractData\";\nimport { configToTables } from \"./configToTables\";\nimport { deployer } from \"./ensureDeployer\";\nimport { resourceLabel } from \"./resourceLabel\";\n\n// TODO: this should be replaced by https://github.com/latticexyz/mud/issues/1668\n\nexport function resolveConfig<config extends ConfigInput>({\n  config,\n  forgeSourceDir,\n  forgeOutDir,\n}: {\n  config: config;\n  forgeSourceDir: string;\n  forgeOutDir: string;\n}): Config<config> {\n  const tables = configToTables(config);\n\n  // TODO: should the config parser/loader help with resolving systems?\n  const contractNames = getExistingContracts(forgeSourceDir).map(({ basename }) => basename);\n  const resolvedConfig = resolveWorldConfig(config, contractNames);\n  const baseSystemContractData = getContractData(\"System\", forgeOutDir);\n  const baseSystemFunctions = baseSystemContractData.abi\n    .filter((item): item is typeof item & { type: \"function\" } => item.type === \"function\")\n    .map(getFunctionSignature);\n\n  const systems = Object.entries(resolvedConfig.systems).map(([systemName, system]) => {\n    const namespace = config.namespace;\n    const name = system.name;\n    const systemId = resourceToHex({ type: \"system\", namespace, name });\n    const contractData = getContractData(systemName, forgeOutDir);\n\n    const systemFunctions = contractData.abi\n      .filter((item): item is typeof item & { type: \"function\" } => item.type === \"function\")\n      .map(getFunctionSignature)\n      .filter((sig) => !baseSystemFunctions.includes(sig))\n      .map((sig): WorldFunction => {\n        // TODO: figure out how to not duplicate contract behavior (https://github.com/latticexyz/mud/issues/1708)\n        const worldSignature = namespace === \"\" ? sig : `${namespace}_${name}_${sig}`;\n        return {\n          signature: worldSignature,\n          selector: getFunctionSelector(worldSignature),\n          systemId,\n          systemFunctionSignature: sig,\n          systemFunctionSelector: getFunctionSelector(sig),\n        };\n      });\n\n    return {\n      namespace,\n      name,\n      systemId,\n      allowAll: system.openAccess,\n      allowedAddresses: system.accessListAddresses as Hex[],\n      allowedSystemIds: system.accessListSystems.map((name) =>\n        resourceToHex({ type: \"system\", namespace, name: resolvedConfig.systems[name].name })\n      ),\n      address: getCreate2Address({ from: deployer, bytecode: contractData.bytecode, salt }),\n      bytecode: contractData.bytecode,\n      deployedBytecodeSize: contractData.deployedBytecodeSize,\n      abi: contractData.abi,\n      functions: systemFunctions,\n    };\n  });\n\n  // resolve allowedSystemIds\n  // TODO: resolve this at deploy time so we can allow for arbitrary system IDs registered in the world as the source-of-truth rather than config\n  const systemsWithAccess = systems.map(({ allowedAddresses, allowedSystemIds, ...system }) => {\n    const allowedSystemAddresses = allowedSystemIds.map((systemId) => {\n      const targetSystem = systems.find((s) => s.systemId === systemId);\n      if (!targetSystem) {\n        throw new Error(\n          `System ${resourceLabel(system)} wanted access to ${resourceLabel(\n            hexToResource(systemId)\n          )}, but it wasn't found in the config.`\n        );\n      }\n      return targetSystem.address;\n    });\n    return {\n      ...system,\n      allowedAddresses: Array.from(\n        new Set([...allowedAddresses, ...allowedSystemAddresses].map((addr) => getAddress(addr)))\n      ),\n    };\n  });\n\n  // ugh (https://github.com/latticexyz/mud/issues/1668)\n  const resolveContext = {\n    tableIds: Object.fromEntries(\n      Object.entries(config.tables).map(([tableName, table]) => [\n        tableName,\n        hexToBytes(\n          resourceToHex({\n            type: table.offchainOnly ? \"offchainTable\" : \"table\",\n            namespace: config.namespace,\n            name: table.name,\n          })\n        ),\n      ])\n    ),\n  };\n\n  const modules = config.modules.map((mod) => {\n    const contractData =\n      defaultModuleContracts.find((defaultMod) => defaultMod.name === mod.name) ??\n      getContractData(mod.name, forgeOutDir);\n    const installArgs = mod.args\n      .map((arg) => resolveWithContext(arg, resolveContext))\n      .map((arg) => {\n        const value = arg.value instanceof Uint8Array ? bytesToHex(arg.value) : arg.value;\n        return encodeField(arg.type as SchemaAbiType, value as SchemaAbiTypeToPrimitiveType<SchemaAbiType>);\n      });\n    if (installArgs.length > 1) {\n      throw new Error(`${mod.name} module should only have 0-1 args, but had ${installArgs.length} args.`);\n    }\n    return {\n      name: mod.name,\n      installAsRoot: mod.root,\n      installData: installArgs.length === 0 ? \"0x\" : installArgs[0],\n      address: getCreate2Address({ from: deployer, bytecode: contractData.bytecode, salt }),\n      bytecode: contractData.bytecode,\n      deployedBytecodeSize: contractData.deployedBytecodeSize,\n      abi: contractData.abi,\n    };\n  });\n\n  return {\n    tables,\n    systems: systemsWithAccess,\n    modules,\n  };\n}\n","import glob from \"glob\";\nimport { basename } from \"path\";\n\n/**\n * Get a list of all contract paths/names within the provided src directory\n */\nexport function getExistingContracts(srcDir: string) {\n  return glob.sync(`${srcDir}/**/*.sol`).map((path) => ({\n    path,\n    basename: basename(path, \".sol\"),\n  }));\n}\n","import KeysWithValueModuleData from \"@latticexyz/world-modules/out/KeysWithValueModule.sol/KeysWithValueModule.json\" assert { type: \"json\" };\nimport KeysInTableModuleData from \"@latticexyz/world-modules/out/KeysInTableModule.sol/KeysInTableModule.json\" assert { type: \"json\" };\nimport UniqueEntityModuleData from \"@latticexyz/world-modules/out/UniqueEntityModule.sol/UniqueEntityModule.json\" assert { type: \"json\" };\nimport { Abi, Hex, size } from \"viem\";\n\n// These modules are always deployed\nexport const defaultModuleContracts = [\n  {\n    name: \"KeysWithValueModule\",\n    abi: KeysWithValueModuleData.abi as Abi,\n    bytecode: KeysWithValueModuleData.bytecode.object as Hex,\n    deployedBytecodeSize: size(KeysWithValueModuleData.deployedBytecode.object as Hex),\n  },\n  {\n    name: \"KeysInTableModule\",\n    abi: KeysInTableModuleData.abi as Abi,\n    bytecode: KeysInTableModuleData.bytecode.object as Hex,\n    deployedBytecodeSize: size(KeysInTableModuleData.deployedBytecode.object as Hex),\n  },\n  {\n    name: \"UniqueEntityModule\",\n    abi: UniqueEntityModuleData.abi as Abi,\n    bytecode: UniqueEntityModuleData.bytecode.object as Hex,\n    deployedBytecodeSize: size(UniqueEntityModuleData.deployedBytecode.object as Hex),\n  },\n];\n","import { readFileSync } from \"fs\";\nimport path from \"path\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { Abi, Hex, size } from \"viem\";\n\n/**\n * Load the contract's abi and bytecode from the file system\n * @param contractName: Name of the contract to load\n */\nexport function getContractData(\n  contractName: string,\n  forgeOutDirectory: string\n): { bytecode: Hex; abi: Abi; deployedBytecodeSize: number } {\n  let data: any;\n  const contractDataPath = path.join(forgeOutDirectory, contractName + \".sol\", contractName + \".json\");\n  try {\n    data = JSON.parse(readFileSync(contractDataPath, \"utf8\"));\n  } catch (error: any) {\n    throw new MUDError(`Error reading file at ${contractDataPath}`);\n  }\n\n  const bytecode = data?.bytecode?.object;\n  if (!bytecode) throw new MUDError(`No bytecode found in ${contractDataPath}`);\n\n  const deployedBytecode = data?.deployedBytecode?.object;\n  if (!deployedBytecode) throw new MUDError(`No deployed bytecode found in ${contractDataPath}`);\n\n  const abi = data?.abi;\n  if (!abi) throw new MUDError(`No ABI found in ${contractDataPath}`);\n\n  return { abi, bytecode, deployedBytecodeSize: size(deployedBytecode as Hex) };\n}\n","import { existsSync } from \"fs\";\nimport path from \"path\";\nimport chalk from \"chalk\";\nimport { getScriptDirectory, forge } from \"@latticexyz/common/foundry\";\n\nexport async function postDeploy(\n  postDeployScript: string,\n  worldAddress: string,\n  rpc: string,\n  profile: string | undefined\n): Promise<void> {\n  // Execute postDeploy forge script\n  const postDeployPath = path.join(await getScriptDirectory(), postDeployScript + \".s.sol\");\n  if (existsSync(postDeployPath)) {\n    console.log(chalk.blue(`Executing post deploy script at ${postDeployPath}`));\n    await forge(\n      [\"script\", postDeployScript, \"--sig\", \"run(address)\", worldAddress, \"--broadcast\", \"--rpc-url\", rpc, \"-vvv\"],\n      {\n        profile: profile,\n      }\n    );\n  } else {\n    console.log(`No script at ${postDeployPath}, skipping post deploy hook`);\n  }\n}\n","import type { CommandModule } from \"yargs\";\nimport { logError } from \"../utils/errors\";\nimport { DeployOptions, deployOptions, runDeploy } from \"../runDeploy\";\n\nconst commandModule: CommandModule<typeof deployOptions, DeployOptions> = {\n  command: \"deploy\",\n\n  describe: \"Deploy MUD contracts\",\n\n  builder(yargs) {\n    return yargs.options(deployOptions);\n  },\n\n  async handler(opts) {\n    // Wrap in try/catch, because yargs seems to swallow errors\n    try {\n      await runDeploy(opts);\n    } catch (error: any) {\n      logError(error);\n      process.exit(1);\n    }\n    process.exit(0);\n  },\n};\n\nexport default commandModule;\n","import type { CommandModule } from \"yargs\";\nimport { loadConfig } from \"@latticexyz/config/node\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { WorldConfig } from \"@latticexyz/world\";\nimport { worldgen } from \"@latticexyz/world/node\";\nimport { getSrcDirectory } from \"@latticexyz/common/foundry\";\nimport path from \"path\";\nimport { rmSync } from \"fs\";\nimport { getExistingContracts } from \"../utils/getExistingContracts\";\n\ntype Options = {\n  configPath?: string;\n  clean?: boolean;\n  srcDir?: string;\n  config?: StoreConfig & WorldConfig;\n};\n\nconst commandModule: CommandModule<Options, Options> = {\n  command: \"worldgen\",\n\n  describe: \"Autogenerate interfaces for Systems and World based on existing contracts and the config file\",\n\n  builder(yargs) {\n    return yargs.options({\n      configPath: { type: \"string\", desc: \"Path to the config file\" },\n      clean: {\n        type: \"boolean\",\n        desc: \"Clear the worldgen directory before generating new interfaces (defaults to true)\",\n        default: true,\n      },\n    });\n  },\n\n  async handler(args) {\n    await worldgenHandler(args);\n    process.exit(0);\n  },\n};\n\nexport async function worldgenHandler(args: Options) {\n  const srcDir = args.srcDir ?? (await getSrcDirectory());\n\n  const existingContracts = getExistingContracts(srcDir);\n\n  // Load the config\n  const mudConfig = args.config ?? ((await loadConfig(args.configPath)) as StoreConfig & WorldConfig);\n\n  const outputBaseDirectory = path.join(srcDir, mudConfig.codegenDirectory);\n\n  // clear the worldgen directory\n  if (args.clean) rmSync(path.join(outputBaseDirectory, mudConfig.worldgenDirectory), { recursive: true, force: true });\n\n  // generate new interfaces\n  await worldgen(mudConfig, existingContracts, outputBaseDirectory);\n}\n\nexport default commandModule;\n","import chalk from \"chalk\";\nimport { readFileSync, writeFileSync } from \"fs\";\nimport path from \"path\";\nimport type { CommandModule } from \"yargs\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { logError } from \"../utils/errors\";\nimport localPackageJson from \"../../package.json\" assert { type: \"json\" };\nimport glob from \"glob\";\nimport { mudPackages } from \"../mudPackages\";\n\ntype Options = {\n  backup?: boolean;\n  force?: boolean;\n  restore?: boolean;\n  mudVersion?: string;\n  tag?: string;\n  commit?: string;\n  link?: string;\n};\n\nconst commandModule: CommandModule<Options, Options> = {\n  command: \"set-version\",\n\n  describe: \"Set MUD version in all package.json files and optionally backup the previously installed version\",\n\n  builder(yargs) {\n    return yargs.options({\n      mudVersion: { alias: \"v\", type: \"string\", description: \"Set MUD to the given version\" },\n      tag: {\n        alias: \"t\",\n        type: \"string\",\n        description: \"Set MUD to the latest version with the given tag from npm\",\n      },\n      commit: {\n        alias: \"c\",\n        type: \"string\",\n        description: \"Set MUD to the version based on a given git commit hash from npm\",\n      },\n      link: { alias: \"l\", type: \"string\", description: \"Relative path to the local MUD root directory to link\" },\n    });\n  },\n\n  async handler(options) {\n    try {\n      const mutuallyExclusiveOptions = [\"mudVersion\", \"link\", \"tag\", \"commit\", \"restore\"];\n      const numMutuallyExclusiveOptions = mutuallyExclusiveOptions.reduce(\n        (acc, opt) => (options[opt] ? acc + 1 : acc),\n        0\n      );\n\n      if (numMutuallyExclusiveOptions === 0) {\n        throw new MUDError(`You need to provide one these options: ${mutuallyExclusiveOptions.join(\", \")}`);\n      }\n\n      if (numMutuallyExclusiveOptions > 1) {\n        throw new MUDError(`These options are mutually exclusive: ${mutuallyExclusiveOptions.join(\", \")}`);\n      }\n\n      // Resolve the version number from available options like `tag` or `commit`\n      options.mudVersion = await resolveVersion(options);\n\n      // Update all package.json below the current working directory (except in node_modules)\n      const packageJsons = glob.sync(\"**/package.json\").filter((p) => !p.includes(\"node_modules\"));\n      for (const packageJson of packageJsons) {\n        updatePackageJson(packageJson, options);\n      }\n    } catch (e) {\n      logError(e);\n    } finally {\n      process.exit(0);\n    }\n  },\n};\n\nasync function resolveVersion(options: Options) {\n  // Backwards compatibility to previous behavior of this script where passing \"canary\" as the version resolved to the latest commit on main\n  if (options.mudVersion === \"canary\") options.tag = \"main\";\n\n  let npmResult;\n  try {\n    console.log(chalk.blue(`Fetching available versions`));\n    npmResult = await (await fetch(`https://registry.npmjs.org/${localPackageJson.name}`)).json();\n  } catch (e) {\n    throw new MUDError(`Could not fetch available MUD versions`);\n  }\n\n  if (options.tag) {\n    const version = npmResult[\"dist-tags\"][options.tag];\n    if (!version) {\n      throw new MUDError(`Could not find npm version with tag \"${options.tag}\"`);\n    }\n    console.log(chalk.green(`Latest version with tag ${options.tag}: ${version}`));\n    return version;\n  }\n\n  if (options.commit) {\n    // Find a version with this commit hash\n    const commit = options.commit.substring(0, 8); // changesets uses the first 8 characters of the commit hash as version for prereleases/snapshot releases\n    const version = Object.keys(npmResult[\"versions\"]).find((v) => (v as string).includes(commit));\n    if (!version) {\n      throw new MUDError(`Could not find npm version based on commit \"${options.commit}\"`);\n    }\n    console.log(chalk.green(`Version from commit ${options.commit}: ${version}`));\n    return version;\n  }\n\n  // If neither a tag nor a commit option is given, return the `mudVersion`\n  return options.mudVersion;\n}\n\nfunction updatePackageJson(filePath: string, options: Options): { workspaces?: string[] } {\n  const { link } = options;\n  let { mudVersion } = options;\n\n  const packageJson = readPackageJson(filePath);\n  const mudPackageNames = Object.keys(mudPackages);\n\n  // Find all MUD dependencies\n  const mudDependencies: Record<string, string> = {};\n  for (const packageName in packageJson.dependencies) {\n    if (mudPackageNames.includes(packageName)) {\n      mudDependencies[packageName] = packageJson.dependencies[packageName];\n    }\n  }\n\n  // Find all MUD devDependencies\n  const mudDevDependencies: Record<string, string> = {};\n  for (const packageName in packageJson.devDependencies) {\n    if (mudPackageNames.includes(packageName)) {\n      mudDevDependencies[packageName] = packageJson.devDependencies[packageName];\n    }\n  }\n\n  // Update the dependencies\n  for (const packageName in packageJson.dependencies) {\n    if (mudPackageNames.includes(packageName)) {\n      packageJson.dependencies[packageName] = resolveMudVersion(packageName, \"dependencies\");\n    }\n  }\n\n  // Update the devDependencies\n  for (const packageName in packageJson.devDependencies) {\n    if (mudPackageNames.includes(packageName)) {\n      packageJson.devDependencies[packageName] = resolveMudVersion(packageName, \"devDependencies\");\n    }\n  }\n\n  // Write the updated package.json\n  writeFileSync(filePath, JSON.stringify(packageJson, null, 2) + \"\\n\");\n\n  console.log(`Updating ${filePath}`);\n  logComparison(mudDependencies, packageJson.dependencies);\n  logComparison(mudDevDependencies, packageJson.devDependencies);\n\n  return packageJson;\n\n  function resolveMudVersion(key: string, type: \"dependencies\" | \"devDependencies\") {\n    if (link) mudVersion = resolveLinkPath(filePath, link, key);\n    if (!mudVersion) return packageJson[type][key];\n    return mudVersion;\n  }\n}\n\nfunction readPackageJson(path: string): {\n  workspaces?: string[];\n  dependencies: Record<string, string>;\n  devDependencies: Record<string, string>;\n} {\n  try {\n    const jsonString = readFileSync(path, \"utf8\");\n    return JSON.parse(jsonString);\n  } catch {\n    throw new MUDError(\"Could not read JSON at \" + path);\n  }\n}\n\nfunction logComparison(prev: Record<string, string>, curr: Record<string, string>) {\n  for (const key in prev) {\n    if (prev[key] !== curr[key]) {\n      console.log(`${key}: ${chalk.red(prev[key])} -> ${chalk.green(curr[key])}`);\n    }\n  }\n}\n\n/**\n * Returns path of the package to link, given a path to a local MUD clone and a package\n */\nfunction resolveLinkPath(packageJsonPath: string, mudLinkPath: string, packageName: string) {\n  const packageJsonToRootPath = path.relative(path.dirname(packageJsonPath), process.cwd());\n  const linkPath = path.join(packageJsonToRootPath, mudLinkPath, mudPackages[packageName].localPath);\n  return \"link:\" + linkPath;\n}\n\nexport default commandModule;\n","{\n  \"name\": \"@latticexyz/cli\",\n  \"version\": \"2.0.0-next.14\",\n  \"description\": \"Command line interface for mud\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/latticexyz/mud.git\",\n    \"directory\": \"packages/cli\"\n  },\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./dist/index.js\"\n  },\n  \"types\": \"src/index.ts\",\n  \"bin\": {\n    \"mud\": \"./dist/mud.js\"\n  },\n  \"scripts\": {\n    \"build\": \"pnpm run build:js && pnpm run build:test-tables\",\n    \"build:js\": \"tsup && chmod +x ./dist/mud.js\",\n    \"build:test-tables\": \"tsx ./scripts/generate-test-tables.ts\",\n    \"clean\": \"pnpm run clean:js && pnpm run clean:test-tables\",\n    \"clean:js\": \"rimraf dist\",\n    \"clean:test-tables\": \"rimraf src/codegen\",\n    \"dev\": \"tsup --watch\",\n    \"lint\": \"eslint . --ext .ts\",\n    \"prepare\": \"mkdir -p ./dist && touch ./dist/mud.js\",\n    \"test\": \"tsc --noEmit && forge test\",\n    \"test:ci\": \"pnpm run test\"\n  },\n  \"dependencies\": {\n    \"@ethersproject/abi\": \"^5.7.0\",\n    \"@ethersproject/providers\": \"^5.7.2\",\n    \"@improbable-eng/grpc-web\": \"^0.15.0\",\n    \"@improbable-eng/grpc-web-node-http-transport\": \"^0.15.0\",\n    \"@latticexyz/abi-ts\": \"workspace:*\",\n    \"@latticexyz/common\": \"workspace:*\",\n    \"@latticexyz/config\": \"workspace:*\",\n    \"@latticexyz/gas-report\": \"workspace:*\",\n    \"@latticexyz/protocol-parser\": \"workspace:*\",\n    \"@latticexyz/schema-type\": \"workspace:*\",\n    \"@latticexyz/services\": \"workspace:*\",\n    \"@latticexyz/store\": \"workspace:*\",\n    \"@latticexyz/utils\": \"workspace:*\",\n    \"@latticexyz/world\": \"workspace:*\",\n    \"@latticexyz/world-modules\": \"workspace:*\",\n    \"chalk\": \"^5.0.1\",\n    \"chokidar\": \"^3.5.3\",\n    \"debug\": \"^4.3.4\",\n    \"dotenv\": \"^16.0.3\",\n    \"ejs\": \"^3.1.8\",\n    \"ethers\": \"^5.7.2\",\n    \"execa\": \"^7.0.0\",\n    \"glob\": \"^8.0.3\",\n    \"nice-grpc-web\": \"^2.0.1\",\n    \"openurl\": \"^1.1.1\",\n    \"p-retry\": \"^5.1.2\",\n    \"path\": \"^0.12.7\",\n    \"rxjs\": \"7.5.5\",\n    \"throttle-debounce\": \"^5.0.0\",\n    \"typescript\": \"5.1.6\",\n    \"viem\": \"1.14.0\",\n    \"yargs\": \"^17.7.1\",\n    \"zod\": \"^3.21.4\",\n    \"zod-validation-error\": \"^1.3.0\"\n  },\n  \"devDependencies\": {\n    \"@types/debug\": \"^4.1.7\",\n    \"@types/ejs\": \"^3.1.1\",\n    \"@types/glob\": \"^7.2.0\",\n    \"@types/node\": \"^18.15.11\",\n    \"@types/openurl\": \"^1.0.0\",\n    \"@types/throttle-debounce\": \"^5.0.0\",\n    \"@types/yargs\": \"^17.0.10\",\n    \"ds-test\": \"https://github.com/dapphub/ds-test.git#e282159d5170298eb2455a6c05280ab5a73a4ef0\",\n    \"forge-std\": \"https://github.com/foundry-rs/forge-std.git#74cfb77e308dd188d2f58864aaf44963ae6b88b1\",\n    \"tsup\": \"^6.7.0\",\n    \"tsx\": \"^3.12.6\",\n    \"vitest\": \"0.31.4\"\n  },\n  \"gitHead\": \"914a1e0ae4a573d685841ca2ea921435057deb8f\"\n}\n","import { ZodError, z } from \"zod\";\nimport { MudPackages } from \"./common\";\n\nconst envSchema = z.object({\n  MUD_PACKAGES: z.string().transform((value) => JSON.parse(value) as MudPackages),\n});\n\nfunction parseEnv(): z.infer<typeof envSchema> {\n  try {\n    return envSchema.parse({\n      // tsup replaces the env vars with their values at compile time\n      MUD_PACKAGES: process.env.MUD_PACKAGES,\n    });\n  } catch (error) {\n    if (error instanceof ZodError) {\n      const { _errors, ...invalidEnvVars } = error.format();\n      console.error(`\\nMissing or invalid environment variables:\\n\\n  ${Object.keys(invalidEnvVars).join(\"\\n  \")}\\n`);\n      process.exit(1);\n    }\n    throw error;\n  }\n}\n\nexport const mudPackages = parseEnv().MUD_PACKAGES;\n","import type { CommandModule, InferredOptionTypes, Options } from \"yargs\";\nimport { anvil, forge, getRpcUrl } from \"@latticexyz/common/foundry\";\nimport chalk from \"chalk\";\nimport { deployOptions, runDeploy } from \"../runDeploy\";\n\nconst testOptions = {\n  ...deployOptions,\n  port: { type: \"number\", description: \"Port to run internal node for fork testing on\", default: 4242 },\n  worldAddress: {\n    type: \"string\",\n    description:\n      \"Address of an existing world contract. If provided, deployment is skipped and the RPC provided in the foundry.toml is used for fork testing.\",\n  },\n  forgeOptions: { type: \"string\", description: \"Options to pass to forge test\" },\n} as const satisfies Record<string, Options>;\n\ntype TestOptions = InferredOptionTypes<typeof testOptions>;\n\nconst commandModule: CommandModule<typeof testOptions, TestOptions> = {\n  command: \"test\",\n\n  describe: \"Run tests in MUD contracts\",\n\n  builder(yargs) {\n    return yargs.options(testOptions);\n  },\n\n  async handler(opts) {\n    // Start an internal anvil process if no world address is provided\n    if (!opts.worldAddress) {\n      const anvilArgs = [\"--block-base-fee-per-gas\", \"0\", \"--port\", String(opts.port)];\n      anvil(anvilArgs);\n    }\n\n    const forkRpc = opts.worldAddress ? await getRpcUrl(opts.profile) : `http://127.0.0.1:${opts.port}`;\n\n    const worldAddress =\n      opts.worldAddress ??\n      (\n        await runDeploy({\n          ...opts,\n          saveDeployment: false,\n          rpc: forkRpc,\n        })\n      ).address;\n\n    console.log(chalk.blue(\"World address\", worldAddress));\n\n    const userOptions = opts.forgeOptions?.replaceAll(\"\\\\\", \"\").split(\" \") ?? [];\n    try {\n      await forge([\"test\", \"--fork-url\", forkRpc, ...userOptions], {\n        profile: opts.profile,\n        env: {\n          WORLD_ADDRESS: worldAddress,\n        },\n      });\n      process.exit(0);\n    } catch (e) {\n      console.error(e);\n      process.exit(1);\n    }\n  },\n};\n\nexport default commandModule;\n","import { existsSync, readFileSync } from \"fs\";\nimport type { CommandModule } from \"yargs\";\nimport { ethers } from \"ethers\";\n\nimport { loadConfig } from \"@latticexyz/config/node\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { cast, getRpcUrl, getSrcDirectory } from \"@latticexyz/common/foundry\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport { resolveWorldConfig, WorldConfig } from \"@latticexyz/world\";\nimport IBaseWorldAbi from \"@latticexyz/world/out/IBaseWorld.sol/IBaseWorld.abi.json\" assert { type: \"json\" };\nimport worldConfig from \"@latticexyz/world/mud.config\";\nimport { resourceToHex } from \"@latticexyz/common\";\nimport { getExistingContracts } from \"../utils/getExistingContracts\";\nimport { createClient, http } from \"viem\";\nimport { getChainId } from \"viem/actions\";\n\n// TODO account for multiple namespaces (https://github.com/latticexyz/mud/issues/994)\nconst systemsTableId = resourceToHex({\n  type: \"system\",\n  namespace: worldConfig.namespace,\n  name: worldConfig.tables.Systems.name,\n});\n\ntype Options = {\n  tx: string;\n  worldAddress?: string;\n  configPath?: string;\n  profile?: string;\n  srcDir?: string;\n  rpc?: string;\n};\n\nconst commandModule: CommandModule<Options, Options> = {\n  command: \"trace\",\n\n  describe: \"Display the trace of a transaction\",\n\n  builder(yargs) {\n    return yargs.options({\n      tx: { type: \"string\", required: true, description: \"Transaction hash to replay\" },\n      worldAddress: {\n        type: \"string\",\n        description: \"World contract address. Defaults to the value from worlds.json, based on rpc's chainId\",\n      },\n      configPath: { type: \"string\", description: \"Path to the config file\" },\n      profile: { type: \"string\", description: \"The foundry profile to use\" },\n      srcDir: { type: \"string\", description: \"Source directory. Defaults to foundry src directory.\" },\n      rpc: { type: \"string\", description: \"json rpc endpoint. Defaults to foundry's configured eth_rpc_url\" },\n    });\n  },\n\n  async handler(args) {\n    args.profile ??= process.env.FOUNDRY_PROFILE;\n    const { profile } = args;\n    args.srcDir ??= await getSrcDirectory(profile);\n    args.rpc ??= await getRpcUrl(profile);\n    const { tx, configPath, srcDir, rpc } = args;\n\n    const existingContracts = getExistingContracts(srcDir);\n\n    // Load the config\n    const mudConfig = (await loadConfig(configPath)) as StoreConfig & WorldConfig;\n\n    const resolvedConfig = resolveWorldConfig(\n      mudConfig,\n      existingContracts.map(({ basename }) => basename)\n    );\n\n    // Get worldAddress either from args or from worldsFile\n    const worldAddress = args.worldAddress ?? (await getWorldAddress(mudConfig.worldsFile, rpc));\n\n    // Create World contract instance from deployed address\n    const provider = new ethers.providers.StaticJsonRpcProvider(rpc);\n    const WorldContract = new ethers.Contract(worldAddress, IBaseWorldAbi, provider);\n\n    // TODO account for multiple namespaces (https://github.com/latticexyz/mud/issues/994)\n    const namespace = mudConfig.namespace;\n    const names = Object.values(resolvedConfig.systems).map(({ name }) => name);\n\n    // Fetch system table field layout from chain\n    const systemTableFieldLayout = await WorldContract.getFieldLayout(systemsTableId);\n    const labels: { name: string; address: string }[] = [];\n    for (const name of names) {\n      const systemSelector = resourceToHex({ type: \"system\", namespace, name });\n      // Get the first field of `Systems` table (the table maps system name to its address and other data)\n      const address = await WorldContract.getField(systemsTableId, [systemSelector], 0, systemTableFieldLayout);\n      labels.push({ name, address });\n    }\n\n    const result = await cast([\n      \"run\",\n      \"--label\",\n      `${worldAddress}:World`,\n      ...labels.map(({ name, address }) => [\"--label\", `${address}:${name}`]).flat(),\n      `${tx}`,\n    ]);\n    console.log(result);\n\n    process.exit(0);\n  },\n};\n\nexport default commandModule;\n\nasync function getWorldAddress(worldsFile: string, rpc: string) {\n  if (existsSync(worldsFile)) {\n    const client = createClient({ transport: http(rpc) });\n    const chainId = await getChainId(client);\n    const deploys = JSON.parse(readFileSync(worldsFile, \"utf-8\"));\n\n    if (!deploys[chainId]) {\n      throw new MUDError(`chainId ${chainId} is missing in worldsFile \"${worldsFile}\"`);\n    }\n    return deploys[chainId].address as string;\n  } else {\n    throw new MUDError(\"worldAddress is not specified and worldsFile is missing\");\n  }\n}\n","import type { CommandModule, InferredOptionTypes } from \"yargs\";\nimport { anvil, getScriptDirectory, getSrcDirectory } from \"@latticexyz/common/foundry\";\nimport chalk from \"chalk\";\nimport chokidar from \"chokidar\";\nimport { loadConfig, resolveConfigPath } from \"@latticexyz/config/node\";\nimport { StoreConfig } from \"@latticexyz/store\";\nimport path from \"path\";\nimport { WorldConfig } from \"@latticexyz/world\";\nimport { homedir } from \"os\";\nimport { rmSync } from \"fs\";\nimport { deployOptions, runDeploy } from \"../runDeploy\";\nimport { BehaviorSubject, debounceTime, exhaustMap, filter } from \"rxjs\";\nimport { Address } from \"viem\";\nimport { isDefined } from \"@latticexyz/common/utils\";\n\nconst devOptions = {\n  rpc: deployOptions.rpc,\n  configPath: deployOptions.configPath,\n  alwaysRunPostDeploy: deployOptions.alwaysRunPostDeploy,\n  worldAddress: deployOptions.worldAddress,\n};\n\nconst commandModule: CommandModule<typeof devOptions, InferredOptionTypes<typeof devOptions>> = {\n  command: \"dev-contracts\",\n\n  describe: \"Start a development server for MUD contracts\",\n\n  builder(yargs) {\n    return yargs.options(devOptions);\n  },\n\n  async handler(opts) {\n    let rpc = opts.rpc;\n    const configPath = opts.configPath ?? (await resolveConfigPath(opts.configPath));\n    const srcDir = await getSrcDirectory();\n    const scriptDir = await getScriptDirectory();\n    const initialConfig = (await loadConfig(configPath)) as StoreConfig & WorldConfig;\n\n    // Start an anvil instance in the background if no RPC url is provided\n    if (!opts.rpc) {\n      // Clean anvil cache as 1s block times can fill up the disk\n      // - https://github.com/foundry-rs/foundry/issues/3623\n      // - https://github.com/foundry-rs/foundry/issues/4989\n      // - https://github.com/foundry-rs/foundry/issues/3699\n      // - https://github.com/foundry-rs/foundry/issues/3512\n      console.log(chalk.gray(\"Cleaning devnode cache\"));\n      const userHomeDir = homedir();\n      rmSync(path.join(userHomeDir, \".foundry\", \"anvil\", \"tmp\"), { recursive: true, force: true });\n\n      const anvilArgs = [\"--block-time\", \"1\", \"--block-base-fee-per-gas\", \"0\"];\n      anvil(anvilArgs);\n      rpc = \"http://127.0.0.1:8545\";\n    }\n\n    // Watch for changes\n    const lastChange$ = new BehaviorSubject<number>(Date.now());\n    chokidar.watch([configPath, srcDir, scriptDir], { ignoreInitial: true }).on(\"all\", async (_, updatePath) => {\n      if (updatePath.includes(configPath)) {\n        console.log(chalk.blue(\"Config changed, queuing deploy…\"));\n        lastChange$.next(Date.now());\n      }\n      if (updatePath.includes(srcDir) || updatePath.includes(scriptDir)) {\n        // Ignore changes to codegen files to avoid an infinite loop\n        if (!updatePath.includes(initialConfig.codegenDirectory)) {\n          console.log(chalk.blue(\"Contracts changed, queuing deploy…\"));\n          lastChange$.next(Date.now());\n        }\n      }\n    });\n\n    let worldAddress = opts.worldAddress as Address | undefined;\n\n    const deploys$ = lastChange$.pipe(\n      // debounce so that a large batch of file changes only triggers a deploy after it settles down, rather than the first change it sees (and then redeploying immediately after)\n      debounceTime(200),\n      exhaustMap(async (lastChange) => {\n        if (worldAddress) {\n          console.log(chalk.blue(\"Rebuilding and upgrading world…\"));\n        }\n\n        try {\n          const deploy = await runDeploy({\n            ...opts,\n            configPath,\n            rpc,\n            skipBuild: false,\n            printConfig: false,\n            profile: undefined,\n            saveDeployment: true,\n            worldAddress,\n            srcDir,\n          });\n          worldAddress = deploy.address;\n          // if there were changes while we were deploying, trigger it again\n          if (lastChange < lastChange$.value) {\n            lastChange$.next(lastChange$.value);\n          } else {\n            console.log(chalk.gray(\"\\nWaiting for file changes…\\n\"));\n          }\n          return deploy;\n        } catch (error) {\n          console.error(chalk.bgRed(chalk.whiteBright(\"\\n Error while attempting deploy \\n\")));\n          console.error(error);\n          console.log(chalk.gray(\"\\nWaiting for file changes…\\n\"));\n        }\n      }),\n      filter(isDefined)\n    );\n\n    deploys$.subscribe();\n  },\n};\n\nexport default commandModule;\n"],"mappings":"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","names":["gasReport","abiTs","rmSync","homedir","path","execa","commandModule","yargs","blocktime","userHomeDir","anvilArgs","child","devnode_default","FaucetServiceDefinition","createChannel","createClient","chalk","NodeHttpTransport","createFaucetService","url","commandModule","yargs","dripDev","faucetUrl","address","faucet","faucet_default","commandModule","yargs","name","greeting","hello_default","path","loadConfig","tablegen","getRemappings","getSrcDirectory","commandModule","yargs","configPath","config","srcDir","remappings","tablegen_default","path","existsSync","mkdirSync","readFileSync","writeFileSync","getAddress","getBytecode","sendRawTransaction","sendTransaction","waitForTransactionReceipt","deployment_default","createDebug","debug","debug","deployer","deployment_default","ensureDeployer","client","getBytecode","debug","gasTx","sendTransaction","gasReceipt","waitForTransactionReceipt","deployTx","sendRawTransaction","deployReceipt","waitForTransactionReceipt","coreModuleBuild","worldFactoryBuild","parseAbi","getCreate2Address","encodeDeployData","size","padHex","storeConfig","worldConfig","IBaseWorldAbi","IModuleAbi","resourceToHex","resolveUserTypes","configToTables","config","userTypes","key","tableName","table","helloStoreEvent","helloWorldEvent","salt","padHex","contractSizeLimit","storeTables","configToTables","storeConfig","worldTables","worldConfig","worldDeployEvents","worldAbi","IBaseWorldAbi","IModuleAbi","supportedStoreVersions","supportedWorldVersions","waitForTransactionReceipt","concatHex","getCreate2Address","getBytecode","sendTransaction","pRetry","wait","ensureContract","client","bytecode","deployedBytecodeSize","label","address","getCreate2Address","deployer","salt","getBytecode","debug","contractSizeLimit","sendTransaction","concatHex","error","delay","ensureContractsDeployed","client","contracts","txs","contract","ensureContract","debug","tx","waitForTransactionReceipt","coreModuleDeployedBytecodeSize","size","coreModuleBuild","coreModuleBytecode","encodeDeployData","coreModule","getCreate2Address","deployer","salt","worldFactoryDeployedBytecodeSize","worldFactoryBuild","worldFactoryBytecode","parseAbi","worldFactory","worldFactoryContracts","ensureWorldFactory","client","ensureContractsDeployed","WorldFactoryAbi","writeContract","AbiEventSignatureNotFoundError","decodeEventLog","hexToString","parseAbi","trim","isDefined","logsToWorldDeploy","logs","deployLogs","log","decodeEventLog","parseAbi","worldDeployEvents","error","AbiEventSignatureNotFoundError","address","deployBlock","worldVersion","storeVersion","deploy","hexToString","trim","deployWorld","client","ensureWorldFactory","debug","tx","writeContract","worldFactory","WorldFactoryAbi","receipt","waitForTransactionReceipt","deploy","logsToWorldDeploy","log","writeContract","valueSchemaToFieldLayoutHex","keySchemaToHex","valueSchemaToHex","resourceLabel","namespace","name","parseAbiItem","decodeAbiParameters","parseAbiParameters","hexToResource","storeSetRecordEvent","getLogs","decodeKey","decodeValueArgs","hexToSchema","getTables","client","worldDeploy","debug","tables","parseAbiItem","storeTables","log","tableId","namespace","name","hexToResource","value","keySchemaFields","valueSchemaFields","keyNames","decodeAbiParameters","parseAbiParameters","fieldNames","valueAbiTypes","keySchema","abiType","i","valueSchema","pRetry","wait","ensureTables","client","worldDeploy","tables","worldTableIds","getTables","table","existingTables","debug","resourceLabel","missingTables","writeContract","worldAbi","valueSchemaToFieldLayoutHex","keySchemaToHex","valueSchemaToHex","error","delay","getAddress","writeContract","parseAbiItem","getLogs","storeSpliceStaticDataEvent","getResourceIds","client","worldDeploy","debug","resourceIds","getLogs","parseAbiItem","storeSpliceStaticDataEvent","storeTables","log","hexToResource","decodeValueArgs","encodeKey","readContract","getTableValue","client","worldDeploy","table","key","staticData","encodedLengths","dynamicData","worldAbi","encodeKey","decodeValueArgs","getFunctionSelector","parseAbiItem","storeSetRecordEvent","getLogs","decodeValueArgs","hexToResource","getFunctions","client","worldDeploy","debug","signatures","getLogs","parseAbiItem","storeSetRecordEvent","worldTables","log","decodeValueArgs","signature","selector","getFunctionSelector","systemId","systemFunctionSelector","getTableValue","namespace","name","systemFunctionSignature","parseAbiItem","getAddress","storeSpliceStaticDataEvent","getLogs","decodeKey","getResourceAccess","client","worldDeploy","debug","keys","getLogs","parseAbiItem","storeSpliceStaticDataEvent","worldTables","log","decodeKey","access","key","getTableValue","value","getAddress","getSystems","client","worldDeploy","resourceIds","functions","resourceAccess","getResourceIds","getFunctions","getResourceAccess","systems","hexToResource","resource","debug","resourceLabel","system","address","publicAccess","getTableValue","worldTables","systemFunctions","func","resourceId","uniqueBy","wait","pRetry","ensureSystems","client","worldDeploy","systems","worldSystems","worldAccess","getSystems","getResourceAccess","systemIds","system","currentAccess","resourceId","desiredAccess","address","accessToAdd","access","getAddress","accessToRemove","debug","accessTxs","pRetry","writeContract","worldAbi","error","delay","wait","existingSystems","worldSystem","resourceLabel","existingSystemIds","missingSystems","systemsToUpgrade","systemsToAdd","ensureContractsDeployed","uniqueBy","registerTxs","waitForTransactionReceipt","getAddress","parseAbi","getBlockNumber","getLogs","deploys","getWorldDeploy","client","worldAddress","address","getAddress","deploy","debug","stateBlock","getBlockNumber","logs","getLogs","parseAbi","worldDeployEvents","logsToWorldDeploy","hexToResource","writeContract","pRetry","wait","ensureFunctions","client","worldDeploy","functions","worldFunctions","getFunctions","worldSelectorToFunction","func","toSkip","toAdd","debug","wrongSystem","namespace","hexToResource","writeContract","worldAbi","error","delay","BaseError","getAddress","writeContract","isDefined","uniqueBy","wait","pRetry","ensureModules","client","worldDeploy","modules","ensureContractsDeployed","uniqueBy","mod","getAddress","debug","pRetry","writeContract","worldAbi","error","BaseError","delay","wait","isDefined","getAddress","hexToResource","resourceToHex","assertNamespaceOwner","client","worldDeploy","resourceIds","desiredNamespaces","resourceId","hexToResource","existingResourceIds","getResourceIds","existingNamespaces","namespaces","namespace","unauthorizedNamespaces","owner","getTableValue","worldTables","resourceToHex","getAddress","uniqueBy","deploy","client","config","existingWorldAddress","tables","systems","ensureDeployer","ensureContractsDeployed","worldFactoryContracts","uniqueBy","system","getAddress","resourceLabel","mod","worldDeploy","getWorldDeploy","deployWorld","supportedStoreVersions","supportedWorldVersions","assertNamespaceOwner","table","tableTxs","ensureTables","systemTxs","ensureSystems","functionTxs","ensureFunctions","moduleTxs","ensureModules","txs","debug","tx","waitForTransactionReceipt","createWalletClient","http","privateKeyToAccount","loadConfig","forge","getOutDirectory","getRemappings","getRpcUrl","getSrcDirectory","chalk","execa","MUDError","resolveWorldConfig","resourceToHex","hexToResource","resolveWithContext","encodeField","getFunctionSelector","getCreate2Address","getAddress","hexToBytes","bytesToHex","getFunctionSignature","glob","basename","getExistingContracts","srcDir","path","KeysWithValueModuleData","KeysInTableModuleData","UniqueEntityModuleData","size","defaultModuleContracts","readFileSync","path","MUDError","size","getContractData","contractName","forgeOutDirectory","data","contractDataPath","bytecode","deployedBytecode","abi","resolveConfig","config","forgeSourceDir","forgeOutDir","tables","configToTables","contractNames","getExistingContracts","basename","resolvedConfig","resolveWorldConfig","baseSystemFunctions","getContractData","item","getFunctionSignature","systems","systemName","system","namespace","name","systemId","resourceToHex","contractData","systemFunctions","sig","worldSignature","getFunctionSelector","getCreate2Address","deployer","salt","systemsWithAccess","allowedAddresses","allowedSystemIds","allowedSystemAddresses","targetSystem","s","resourceLabel","hexToResource","addr","getAddress","resolveContext","tableName","table","hexToBytes","modules","mod","defaultModuleContracts","defaultMod","installArgs","arg","resolveWithContext","value","bytesToHex","encodeField","getChainId","existsSync","path","chalk","getScriptDirectory","forge","postDeploy","postDeployScript","worldAddress","rpc","profile","postDeployPath","tablegen","worldgen","deployOptions","runDeploy","opts","profile","config","loadConfig","chalk","srcDir","getSrcDirectory","outDir","getOutDirectory","remappings","getRemappings","rpc","getRpcUrl","outPath","path","tablegen","worldgen","getExistingContracts","forge","execa","privateKey","MUDError","resolvedConfig","resolveConfig","client","createWalletClient","http","privateKeyToAccount","startTime","worldDeploy","deploy","postDeploy","deploymentInfo","chainId","getChainId","deploysDir","mkdirSync","writeFileSync","localChains","deploys","existsSync","readFileSync","commandModule","yargs","deployOptions","opts","runDeploy","error","logError","deploy_default","loadConfig","worldgen","getSrcDirectory","path","rmSync","commandModule","yargs","args","worldgenHandler","srcDir","getSrcDirectory","existingContracts","getExistingContracts","mudConfig","loadConfig","outputBaseDirectory","path","rmSync","worldgen","worldgen_default","chalk","readFileSync","writeFileSync","path","MUDError","package_default","glob","ZodError","z","envSchema","value","parseEnv","error","_errors","invalidEnvVars","mudPackages","commandModule","yargs","options","mutuallyExclusiveOptions","numMutuallyExclusiveOptions","acc","opt","MUDError","resolveVersion","packageJsons","glob","p","packageJson","updatePackageJson","e","logError","npmResult","chalk","package_default","version","commit","v","filePath","link","mudVersion","readPackageJson","mudPackageNames","mudPackages","mudDependencies","packageName","mudDevDependencies","resolveMudVersion","writeFileSync","logComparison","key","type","resolveLinkPath","path","jsonString","readFileSync","prev","curr","packageJsonPath","mudLinkPath","packageJsonToRootPath","set_version_default","anvil","forge","getRpcUrl","chalk","testOptions","deployOptions","commandModule","yargs","opts","anvilArgs","anvil","forkRpc","getRpcUrl","worldAddress","runDeploy","chalk","userOptions","forge","e","test_default","existsSync","readFileSync","ethers","loadConfig","MUDError","cast","getRpcUrl","getSrcDirectory","resolveWorldConfig","IBaseWorldAbi","worldConfig","resourceToHex","createClient","http","getChainId","systemsTableId","resourceToHex","worldConfig","commandModule","yargs","args","profile","getSrcDirectory","getRpcUrl","tx","configPath","srcDir","rpc","existingContracts","getExistingContracts","mudConfig","loadConfig","resolvedConfig","resolveWorldConfig","basename","worldAddress","getWorldAddress","provider","ethers","WorldContract","IBaseWorldAbi","namespace","names","name","systemTableFieldLayout","labels","systemSelector","address","result","cast","trace_default","worldsFile","existsSync","client","chainId","deploys","readFileSync","MUDError","anvil","getScriptDirectory","getSrcDirectory","chalk","chokidar","loadConfig","resolveConfigPath","path","homedir","rmSync","BehaviorSubject","debounceTime","exhaustMap","filter","isDefined","devOptions","deployOptions","commandModule","yargs","opts","rpc","configPath","resolveConfigPath","srcDir","getSrcDirectory","scriptDir","getScriptDirectory","initialConfig","loadConfig","chalk","userHomeDir","homedir","rmSync","path","anvil","lastChange$","chokidar","_","updatePath","worldAddress","lastChange","deploy","runDeploy","error","dev_contracts_default","commands","deploy_default","devnode_default","faucet_default","gasReport","hello_default","tablegen_default","worldgen_default","set_version_default","test_default","trace_default","dev_contracts_default","abiTs"]}