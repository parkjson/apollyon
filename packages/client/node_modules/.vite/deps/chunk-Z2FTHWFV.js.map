{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/TRPCError-6a1653a4.mjs", "../../../../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/codes-24aa1ce1.mjs", "../../../../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/index-044a193b.mjs", "../../../../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/config-7eddc5bb.mjs", "../../../../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/index.mjs", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/double-indexed-kv.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/registry.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/class-registry.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/util.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/custom-transformer-registry.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/is.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/pathstringifier.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/transformer.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/accessDeep.ts", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/plainer.ts", "../../../../../node_modules/.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js", "../../../../../node_modules/.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js", "../../../../../node_modules/.pnpm/superjson@1.13.3/node_modules/superjson/src/index.ts", "../../../../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/observable-ade1bad8.mjs", "../../../../../node_modules/.pnpm/@trpc+server@10.34.0/node_modules/@trpc/server/dist/observable/index.mjs", "../../../../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs", "../../../../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/TRPCClientError-fef6cf44.mjs", "../../../../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/httpUtils-1efcb902.mjs", "../../../../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/transformResult-7ab522e6.mjs", "../../../../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/httpBatchLink-fbd7b43c.mjs", "../../../../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/links/httpLink.mjs", "../../../../../node_modules/.pnpm/@trpc+client@10.34.0_@trpc+server@10.34.0/node_modules/@trpc/client/dist/index.mjs", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/trpc-indexer/createAppRouter.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/trpc-indexer/createIndexerClient.ts", "../../../../../node_modules/.pnpm/@latticexyz+store@2.0.0-next.14_typescript@5.1.6/node_modules/@latticexyz/store/ts/storeEvents.ts", "../../../../../node_modules/.pnpm/@latticexyz+store@2.0.0-next.14_typescript@5.1.6/node_modules/@latticexyz/store/ts/storeEventsAbi.ts", "../../../../../node_modules/.pnpm/@latticexyz+store@2.0.0-next.14_typescript@5.1.6/node_modules/@latticexyz/store/mud.config.ts", "../../../../../node_modules/.pnpm/@latticexyz+world@2.0.0-next.14_typescript@5.1.6/node_modules/@latticexyz/world/mud.config.ts", "../../../../../node_modules/.pnpm/@latticexyz+block-logs-stream@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/block-logs-stream/src/blockRangeToLogs.ts", "../../../../../node_modules/.pnpm/@latticexyz+block-logs-stream@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/block-logs-stream/src/fetchLogs.ts", "../../../../../node_modules/.pnpm/@latticexyz+block-logs-stream@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/block-logs-stream/src/debug.ts", "../../../../../node_modules/.pnpm/@latticexyz+block-logs-stream@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/block-logs-stream/src/createBlockStream.ts", "../../../../../node_modules/.pnpm/@latticexyz+block-logs-stream@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/block-logs-stream/src/groupLogsByBlockNumber.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/common.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/flattenSchema.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/SyncStep.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/internalTableIds.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/createStoreSync.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/debug.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/abiTypesToSchema.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/decodeDynamicField.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/decodeStaticField.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/errors.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/decodeField.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/decodeKeyTuple.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/decodeKey.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/decodeRecord.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/hexToPackedCounter.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/staticDataLength.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/decodeValue.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/decodeValueArgs.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/encodeField.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/encodeKey.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/encodeKeyTuple.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/encodeRecord.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/encodeValue.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/encodeValueArgs.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/encodeLengths.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/fieldLayoutToHex.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/hexToSchema.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/hexToTableSchema.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/keySchemaToHex.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/schemaToHex.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/schemaIndexToAbiType.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/valueSchemaToFieldLayoutHex.ts", "../../../../../node_modules/.pnpm/@latticexyz+protocol-parser@2.0.0-next.14_typescript@5.1.6_zod@3.22.4/node_modules/@latticexyz/protocol-parser/src/valueSchemaToHex.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/isTableRegistrationLog.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/logToTable.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/decodeEntity.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/entityToHexKeyTuple.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/encodeEntity.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/hexKeyTupleToEntity.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/isStoreComponent.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/recsStorage.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/debug.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/defineInternalComponents.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/getTableEntity.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/singletonEntity.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/tableToComponent.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/schemaAbiTypeToRecsType.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/tablesToComponents.ts", "../../../../../node_modules/.pnpm/@latticexyz+store-sync@2.0.0-next.14_react@18.2.0_typescript@5.1.6/node_modules/@latticexyz/store-sync/src/recs/syncToRecs.ts"],
  "sourcesContent": ["/**\n * @internal\n */ function isObject(value) {\n    // check that value is object\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\nfunction getTRPCErrorFromUnknown(cause) {\n    if (cause instanceof TRPCError) {\n        return cause;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause\n    });\n    // Inherit stack from error\n    if (cause instanceof Error && cause.stack) {\n        trpcError.stack = cause.stack;\n    }\n    return trpcError;\n}\nclass UnknownCauseError extends Error {\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const type = typeof cause;\n    if (type === 'undefined' || type === 'function' || cause === null) {\n        return undefined;\n    }\n    // Primitive types just get wrapped in an error\n    if (type !== 'object') {\n        return new Error(String(cause));\n    }\n    // If it's an object, we'll create a synthetic error\n    if (isObject(cause)) {\n        const err = new UnknownCauseError();\n        for(const key in cause){\n            err[key] = cause[key];\n        }\n        return err;\n    }\n    return undefined;\n}\nclass TRPCError extends Error {\n    constructor(opts){\n        const cause = getCauseFromUnknown(opts.cause);\n        const message = opts.message ?? cause?.message ?? opts.code;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.code = opts.code;\n        this.name = this.constructor.name;\n    }\n}\n\nexport { TRPCError as T, getTRPCErrorFromUnknown as g };\n", "/**\n * @internal\n */ function invert(obj) {\n    const newObj = Object.create(null);\n    for(const key in obj){\n        const v = obj[key];\n        newObj[v] = key;\n    }\n    return newObj;\n}\n\n// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    /**\n   * Internal JSON-RPC error.\n   */ INTERNAL_SERVER_ERROR: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\n\nexport { TRPC_ERROR_CODES_BY_KEY as T, TRPC_ERROR_CODES_BY_NUMBER as a, invert as i };\n", "import { i as invert, T as TRPC_ERROR_CODES_BY_KEY } from './codes-24aa1ce1.mjs';\n\nconst TRPC_ERROR_CODES_BY_NUMBER = invert(TRPC_ERROR_CODES_BY_KEY);\nconst JSONRPC2_TO_HTTP_CODE = {\n    PARSE_ERROR: 400,\n    BAD_REQUEST: 400,\n    NOT_FOUND: 404,\n    INTERNAL_SERVER_ERROR: 500,\n    UNAUTHORIZED: 401,\n    FORBIDDEN: 403,\n    TIMEOUT: 408,\n    CONFLICT: 409,\n    CLIENT_CLOSED_REQUEST: 499,\n    PRECONDITION_FAILED: 412,\n    PAYLOAD_TOO_LARGE: 413,\n    METHOD_NOT_SUPPORTED: 405,\n    UNPROCESSABLE_CONTENT: 422,\n    TOO_MANY_REQUESTS: 429\n};\nfunction getStatusCodeFromKey(code) {\n    return JSONRPC2_TO_HTTP_CODE[code] ?? 500;\n}\nfunction getHTTPStatusCode(json) {\n    const arr = Array.isArray(json) ? json : [\n        json\n    ];\n    const httpStatuses = new Set(arr.map((res)=>{\n        if ('error' in res) {\n            const data = res.error.data;\n            if (typeof data.httpStatus === 'number') {\n                return data.httpStatus;\n            }\n            const code = TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n            return getStatusCodeFromKey(code);\n        }\n        return 200;\n    }));\n    if (httpStatuses.size !== 1) {\n        return 207;\n    }\n    const httpStatus = httpStatuses.values().next().value;\n    return httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n    const { code  } = error;\n    return getStatusCodeFromKey(code);\n}\n\nconst noop = ()=>{\n// noop\n};\nfunction createInnerProxy(callback, path) {\n    const proxy = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== 'string' || key === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ]);\n        },\n        apply (_1, _2, args) {\n            const isApply = path[path.length - 1] === 'apply';\n            return callback({\n                args: isApply ? args.length >= 2 ? args[1] : [] : args,\n                path: isApply ? path.slice(0, -1) : path\n            });\n        }\n    });\n    return proxy;\n}\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */ const createRecursiveProxy = (callback)=>createInnerProxy(callback, []);\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (typeof name !== 'string' || name === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return callback(name);\n        }\n    });\n};\n\nexport { TRPC_ERROR_CODES_BY_NUMBER as T, createRecursiveProxy as a, getHTTPStatusCode as b, createFlatProxy as c, getHTTPStatusCodeFromError as g };\n", "import { T as TRPCError } from './TRPCError-6a1653a4.mjs';\nimport { a as createRecursiveProxy, g as getHTTPStatusCodeFromError } from './index-044a193b.mjs';\nimport { T as TRPC_ERROR_CODES_BY_KEY } from './codes-24aa1ce1.mjs';\n\n/**\n * @public\n */ /**\n * @internal\n */ function getDataTransformer(transformer) {\n    if ('input' in transformer) {\n        return transformer;\n    }\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n * @internal\n */ const defaultTransformer = {\n    _default: true,\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\n\nconst defaultFormatter = ({ shape  })=>{\n    return shape;\n};\n\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\n\nconst procedureTypes = [\n    'query',\n    'mutation',\n    'subscription'\n];\n\nfunction isRouter(procedureOrRouter) {\n    return 'router' in procedureOrRouter._def;\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n * Reserved words that can't be used as router or procedure names\n */ const reservedWords = [\n    /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */ 'then'\n];\n/**\n * @internal\n */ function createRouterFactory(config) {\n    return function createRouterInner(procedures) {\n        const reservedWordsUsed = new Set(Object.keys(procedures).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) {\n            throw new Error('Reserved words used in `router({})` call: ' + Array.from(reservedWordsUsed).join(', '));\n        }\n        const routerProcedures = omitPrototype({});\n        function recursiveGetPaths(procedures, path = '') {\n            for (const [key, procedureOrRouter] of Object.entries(procedures ?? {})){\n                const newPath = `${path}${key}`;\n                if (isRouter(procedureOrRouter)) {\n                    recursiveGetPaths(procedureOrRouter._def.procedures, `${newPath}.`);\n                    continue;\n                }\n                if (routerProcedures[newPath]) {\n                    throw new Error(`Duplicate key: ${newPath}`);\n                }\n                routerProcedures[newPath] = procedureOrRouter;\n            }\n        }\n        recursiveGetPaths(procedures);\n        const _def = {\n            _config: config,\n            router: true,\n            procedures: routerProcedures,\n            ...emptyRouter,\n            record: procedures,\n            queries: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.query).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {}),\n            mutations: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.mutation).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {}),\n            subscriptions: Object.entries(routerProcedures).filter((pair)=>pair[1]._def.subscription).reduce((acc, [key, val])=>({\n                    ...acc,\n                    [key]: val\n                }), {})\n        };\n        const router = {\n            ...procedures,\n            _def,\n            createCaller (ctx) {\n                const proxy = createRecursiveProxy(({ path , args  })=>{\n                    // interop mode\n                    if (path.length === 1 && procedureTypes.includes(path[0])) {\n                        return callProcedure({\n                            procedures: _def.procedures,\n                            path: args[0],\n                            rawInput: args[1],\n                            ctx,\n                            type: path[0]\n                        });\n                    }\n                    const fullPath = path.join('.');\n                    const procedure = _def.procedures[fullPath];\n                    let type = 'query';\n                    if (procedure._def.mutation) {\n                        type = 'mutation';\n                    } else if (procedure._def.subscription) {\n                        type = 'subscription';\n                    }\n                    return procedure({\n                        path: fullPath,\n                        rawInput: args[0],\n                        ctx,\n                        type\n                    });\n                });\n                return proxy;\n            },\n            getErrorShape (opts) {\n                const { path , error  } = opts;\n                const { code  } = opts.error;\n                const shape = {\n                    message: error.message,\n                    code: TRPC_ERROR_CODES_BY_KEY[code],\n                    data: {\n                        code,\n                        httpStatus: getHTTPStatusCodeFromError(error)\n                    }\n                };\n                if (config.isDev && typeof opts.error.stack === 'string') {\n                    shape.data.stack = opts.error.stack;\n                }\n                if (typeof path === 'string') {\n                    shape.data.path = path;\n                }\n                return this._def._config.errorFormatter({\n                    ...opts,\n                    shape\n                });\n            }\n        };\n        return router;\n    };\n}\n/**\n * @internal\n */ function callProcedure(opts) {\n    const { type , path  } = opts;\n    if (!(path in opts.procedures) || !opts.procedures[path]?._def[type]) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    const procedure = opts.procedures[path];\n    return procedure(opts);\n}\n\n/**\n * The default check to see if we're in a server\n */ const isServerDefault = typeof window === 'undefined' || 'Deno' in window || globalThis.process?.env?.NODE_ENV === 'test' || !!globalThis.process?.env?.JEST_WORKER_ID || !!globalThis.process?.env?.VITEST_WORKER_ID;\n\nexport { defaultTransformer as a, callProcedure as b, createRouterFactory as c, defaultFormatter as d, getDataTransformer as g, isServerDefault as i, procedureTypes as p };\n", "import { c as createRouterFactory, d as defaultFormatter, a as defaultTransformer, g as getDataTransformer$1, i as isServerDefault } from './config-7eddc5bb.mjs';\nexport { b as callProcedure, a as defaultTransformer, g as getDataTransformer, p as procedureTypes } from './config-7eddc5bb.mjs';\nimport { T as TRPCError, g as getTRPCErrorFromUnknown } from './TRPCError-6a1653a4.mjs';\nexport { T as TRPCError, g as getTRPCErrorFromUnknown } from './TRPCError-6a1653a4.mjs';\nimport { g as getHTTPStatusCodeFromError, c as createFlatProxy } from './index-044a193b.mjs';\nimport { T as TRPC_ERROR_CODES_BY_KEY } from './codes-24aa1ce1.mjs';\n\n/**\n * @deprecated\n */ const middlewareMarker$1 = 'middlewareMarker';\n\nfunction getParseFn$1(procedureParser) {\n    const parser = procedureParser;\n    if (typeof parser === 'function') {\n        // ProcedureParserCustomValidatorEsque\n        return parser;\n    }\n    if (typeof parser.parseAsync === 'function') {\n        // ProcedureParserZodEsque\n        return parser.parseAsync.bind(parser);\n    }\n    if (typeof parser.parse === 'function') {\n        // ProcedureParserZodEsque\n        return parser.parse.bind(parser);\n    }\n    if (typeof parser.validateSync === 'function') {\n        // ProcedureParserYupEsque\n        return parser.validateSync.bind(parser);\n    }\n    if (typeof parser.create === 'function') {\n        // ProcedureParserSuperstructEsque\n        return parser.create.bind(parser);\n    }\n    throw new Error('Could not find a validator fn');\n}\n/**\n * @internal\n * @deprecated\n */ class Procedure {\n    _def() {\n        return {\n            middlewares: this.middlewares,\n            resolver: this.resolver,\n            inputParser: this.inputParser,\n            outputParser: this.outputParser,\n            meta: this.meta\n        };\n    }\n    async parseInput(rawInput) {\n        try {\n            return await this.parseInputFn(rawInput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                cause\n            });\n        }\n    }\n    async parseOutput(rawOutput) {\n        try {\n            return await this.parseOutputFn(rawOutput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                cause,\n                message: 'Output validation failed'\n            });\n        }\n    }\n    /**\n   * Trigger middlewares in order, parse raw input, call resolver & parse raw output\n   * @internal\n   */ async call(opts) {\n        // wrap the actual resolver and treat as the last \"middleware\"\n        const middlewaresWithResolver = this.middlewares.concat([\n            async ({ ctx  })=>{\n                const input = await this.parseInput(opts.rawInput);\n                const rawOutput = await this.resolver({\n                    ...opts,\n                    ctx,\n                    input\n                });\n                const data = await this.parseOutput(rawOutput);\n                return {\n                    marker: middlewareMarker$1,\n                    ok: true,\n                    data,\n                    ctx\n                };\n            }\n        ]);\n        // run the middlewares recursively with the resolver as the last one\n        const callRecursive = async (callOpts = {\n            index: 0,\n            ctx: opts.ctx\n        })=>{\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const result = await middlewaresWithResolver[callOpts.index]({\n                    ctx: callOpts.ctx,\n                    type: opts.type,\n                    path: opts.path,\n                    rawInput: opts.rawInput,\n                    meta: this.meta,\n                    next: async (nextOpts)=>{\n                        return await callRecursive({\n                            index: callOpts.index + 1,\n                            ctx: nextOpts ? nextOpts.ctx : callOpts.ctx\n                        });\n                    }\n                });\n                return result;\n            } catch (cause) {\n                return {\n                    ctx: callOpts.ctx,\n                    ok: false,\n                    error: getTRPCErrorFromUnknown(cause),\n                    marker: middlewareMarker$1\n                };\n            }\n        };\n        // there's always at least one \"next\" since we wrap this.resolver in a middleware\n        const result = await callRecursive();\n        if (!result) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                message: 'No result from middlewares - did you forget to `return next()`?'\n            });\n        }\n        if (!result.ok) {\n            // re-throw original error\n            throw result.error;\n        }\n        return result.data;\n    }\n    /**\n   * Create new procedure with passed middlewares\n   * @param middlewares\n   */ inheritMiddlewares(middlewares) {\n        const Constructor = this.constructor;\n        const instance = new Constructor({\n            middlewares: [\n                ...middlewares,\n                ...this.middlewares\n            ],\n            resolver: this.resolver,\n            inputParser: this.inputParser,\n            outputParser: this.outputParser,\n            meta: this.meta\n        });\n        return instance;\n    }\n    constructor(opts){\n        this.middlewares = opts.middlewares;\n        this.resolver = opts.resolver;\n        this.inputParser = opts.inputParser;\n        this.parseInputFn = getParseFn$1(this.inputParser);\n        this.outputParser = opts.outputParser;\n        this.parseOutputFn = getParseFn$1(this.outputParser);\n        this.meta = opts.meta;\n    }\n}\nfunction createProcedure(opts) {\n    const inputParser = 'input' in opts ? opts.input : (input)=>{\n        if (input != null) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                message: 'No input expected'\n            });\n        }\n        return undefined;\n    };\n    const outputParser = 'output' in opts && opts.output ? opts.output : (output)=>output;\n    return new Procedure({\n        inputParser: inputParser,\n        resolver: opts.resolve,\n        middlewares: [],\n        outputParser: outputParser,\n        meta: opts.meta\n    });\n}\n\nfunction getParseFn(procedureParser) {\n    const parser = procedureParser;\n    if (typeof parser === 'function') {\n        // ProcedureParserCustomValidatorEsque\n        return parser;\n    }\n    if (typeof parser.parseAsync === 'function') {\n        // ProcedureParserZodEsque\n        return parser.parseAsync.bind(parser);\n    }\n    if (typeof parser.parse === 'function') {\n        // ProcedureParserZodEsque\n        return parser.parse.bind(parser);\n    }\n    if (typeof parser.validateSync === 'function') {\n        // ProcedureParserYupEsque\n        return parser.validateSync.bind(parser);\n    }\n    if (typeof parser.create === 'function') {\n        // ProcedureParserSuperstructEsque\n        return parser.create.bind(parser);\n    }\n    if (typeof parser.assert === 'function') {\n        // ParserScaleEsque\n        return (value)=>{\n            parser.assert(value);\n            return value;\n        };\n    }\n    throw new Error('Could not find a validator fn');\n}\n/**\n * @deprecated only for backwards compat\n * @internal\n */ function getParseFnOrPassThrough(procedureParser) {\n    if (!procedureParser) {\n        return (v)=>v;\n    }\n    return getParseFn(procedureParser);\n}\n\n/**\n * Ensures there are no duplicate keys when building a procedure.\n */ function mergeWithoutOverrides(obj1, ...objs) {\n    const newObj = Object.assign(Object.create(null), obj1);\n    for (const overrides of objs){\n        for(const key in overrides){\n            if (key in newObj && newObj[key] !== overrides[key]) {\n                throw new Error(`Duplicate key ${key}`);\n            }\n            newObj[key] = overrides[key];\n        }\n    }\n    return newObj;\n}\n\n/**\n * @internal\n */ function createMiddlewareFactory() {\n    function createMiddlewareInner(middlewares) {\n        return {\n            _middlewares: middlewares,\n            unstable_pipe (middlewareBuilderOrFn) {\n                const pipedMiddleware = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                    middlewareBuilderOrFn\n                ];\n                return createMiddlewareInner([\n                    ...middlewares,\n                    ...pipedMiddleware\n                ]);\n            }\n        };\n    }\n    function createMiddleware(fn) {\n        return createMiddlewareInner([\n            fn\n        ]);\n    }\n    return createMiddleware;\n}\nfunction isPlainObject(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n}\n/**\n * @internal\n * Please note, `trpc-openapi` uses this function.\n */ function createInputMiddleware(parse) {\n    const inputMiddleware = async ({ next , rawInput , input ,  })=>{\n        let parsedInput;\n        try {\n            parsedInput = await parse(rawInput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                cause\n            });\n        }\n        // Multiple input parsers\n        const combinedInput = isPlainObject(input) && isPlainObject(parsedInput) ? {\n            ...input,\n            ...parsedInput\n        } : parsedInput;\n        // TODO fix this typing?\n        return next({\n            input: combinedInput\n        });\n    };\n    inputMiddleware._type = 'input';\n    return inputMiddleware;\n}\n/**\n * @internal\n */ function createOutputMiddleware(parse) {\n    const outputMiddleware = async ({ next  })=>{\n        const result = await next();\n        if (!result.ok) {\n            // pass through failures without validating\n            return result;\n        }\n        try {\n            const data = await parse(result.data);\n            return {\n                ...result,\n                data\n            };\n        } catch (cause) {\n            throw new TRPCError({\n                message: 'Output validation failed',\n                code: 'INTERNAL_SERVER_ERROR',\n                cause\n            });\n        }\n    };\n    outputMiddleware._type = 'output';\n    return outputMiddleware;\n}\n\n/**\n * @internal\n */ const middlewareMarker = 'middlewareMarker';\n\nfunction createNewBuilder(def1, def2) {\n    const { middlewares =[] , inputs , meta , ...rest } = def2;\n    // TODO: maybe have a fn here to warn about calls\n    return createBuilder({\n        ...mergeWithoutOverrides(def1, rest),\n        inputs: [\n            ...def1.inputs,\n            ...inputs ?? []\n        ],\n        middlewares: [\n            ...def1.middlewares,\n            ...middlewares\n        ],\n        meta: def1.meta && meta ? {\n            ...def1.meta,\n            ...meta\n        } : meta ?? def1.meta\n    });\n}\nfunction createBuilder(initDef = {}) {\n    const _def = {\n        inputs: [],\n        middlewares: [],\n        ...initDef\n    };\n    return {\n        _def,\n        input (input) {\n            const parser = getParseFn(input);\n            return createNewBuilder(_def, {\n                inputs: [\n                    input\n                ],\n                middlewares: [\n                    createInputMiddleware(parser)\n                ]\n            });\n        },\n        output (output) {\n            const parseOutput = getParseFn(output);\n            return createNewBuilder(_def, {\n                output,\n                middlewares: [\n                    createOutputMiddleware(parseOutput)\n                ]\n            });\n        },\n        meta (meta) {\n            return createNewBuilder(_def, {\n                meta: meta\n            });\n        },\n        /**\n     * @deprecated\n     * This functionality is deprecated and will be removed in the next major version.\n     */ unstable_concat (builder) {\n            return createNewBuilder(_def, builder._def);\n        },\n        use (middlewareBuilderOrFn) {\n            // Distinguish between a middleware builder and a middleware function\n            const middlewares = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                middlewareBuilderOrFn\n            ];\n            return createNewBuilder(_def, {\n                middlewares: middlewares\n            });\n        },\n        query (resolver) {\n            return createResolver({\n                ..._def,\n                query: true\n            }, resolver);\n        },\n        mutation (resolver) {\n            return createResolver({\n                ..._def,\n                mutation: true\n            }, resolver);\n        },\n        subscription (resolver) {\n            return createResolver({\n                ..._def,\n                subscription: true\n            }, resolver);\n        }\n    };\n}\nfunction createResolver(_def, resolver) {\n    const finalBuilder = createNewBuilder(_def, {\n        resolver,\n        middlewares: [\n            async function resolveMiddleware(opts) {\n                const data = await resolver(opts);\n                return {\n                    marker: middlewareMarker,\n                    ok: true,\n                    data,\n                    ctx: opts.ctx\n                };\n            }\n        ]\n    });\n    return createProcedureCaller(finalBuilder._def);\n}\nconst codeblock = `\nIf you want to call this function on the server, you do the following:\nThis is a client-only function.\n\nconst caller = appRouter.createCaller({\n  /* ... your context */\n});\n\nconst result = await caller.call('myProcedure', input);\n`.trim();\nfunction createProcedureCaller(_def) {\n    const procedure = async function resolve(opts) {\n        // is direct server-side call\n        if (!opts || !('rawInput' in opts)) {\n            throw new Error(codeblock);\n        }\n        // run the middlewares recursively with the resolver as the last one\n        const callRecursive = async (callOpts = {\n            index: 0,\n            ctx: opts.ctx\n        })=>{\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const middleware = _def.middlewares[callOpts.index];\n                const result = await middleware({\n                    ctx: callOpts.ctx,\n                    type: opts.type,\n                    path: opts.path,\n                    rawInput: callOpts.rawInput ?? opts.rawInput,\n                    meta: _def.meta,\n                    input: callOpts.input,\n                    next (_nextOpts) {\n                        const nextOpts = _nextOpts;\n                        return callRecursive({\n                            index: callOpts.index + 1,\n                            ctx: nextOpts && 'ctx' in nextOpts ? {\n                                ...callOpts.ctx,\n                                ...nextOpts.ctx\n                            } : callOpts.ctx,\n                            input: nextOpts && 'input' in nextOpts ? nextOpts.input : callOpts.input,\n                            rawInput: nextOpts && 'rawInput' in nextOpts ? nextOpts.rawInput : callOpts.rawInput\n                        });\n                    }\n                });\n                return result;\n            } catch (cause) {\n                return {\n                    ok: false,\n                    error: getTRPCErrorFromUnknown(cause),\n                    marker: middlewareMarker\n                };\n            }\n        };\n        // there's always at least one \"next\" since we wrap this.resolver in a middleware\n        const result = await callRecursive();\n        if (!result) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                message: 'No result from middlewares - did you forget to `return next()`?'\n            });\n        }\n        if (!result.ok) {\n            // re-throw original error\n            throw result.error;\n        }\n        return result.data;\n    };\n    procedure._def = _def;\n    procedure.meta = _def.meta;\n    return procedure;\n}\n\nfunction migrateProcedure(oldProc, type) {\n    const def = oldProc._def();\n    const inputParser = getParseFnOrPassThrough(def.inputParser);\n    const outputParser = getParseFnOrPassThrough(def.outputParser);\n    const inputMiddleware = createInputMiddleware(inputParser);\n    const builder = createBuilder({\n        inputs: [\n            def.inputParser\n        ],\n        middlewares: [\n            ...def.middlewares,\n            inputMiddleware,\n            createOutputMiddleware(outputParser)\n        ],\n        meta: def.meta,\n        output: def.outputParser,\n        mutation: type === 'mutation',\n        query: type === 'query',\n        subscription: type === 'subscription'\n    });\n    const proc = builder[type]((opts)=>def.resolver(opts));\n    return proc;\n}\nfunction migrateRouter(oldRouter) {\n    const errorFormatter = oldRouter._def.errorFormatter;\n    const transformer = oldRouter._def.transformer;\n    const queries = {};\n    const mutations = {};\n    const subscriptions = {};\n    for (const [name, procedure] of Object.entries(oldRouter._def.queries)){\n        queries[name] = migrateProcedure(procedure, 'query');\n    }\n    for (const [name1, procedure1] of Object.entries(oldRouter._def.mutations)){\n        mutations[name1] = migrateProcedure(procedure1, 'mutation');\n    }\n    for (const [name2, procedure2] of Object.entries(oldRouter._def.subscriptions)){\n        subscriptions[name2] = migrateProcedure(procedure2, 'subscription');\n    }\n    const procedures = mergeWithoutOverrides(queries, mutations, subscriptions);\n    const newRouter = createRouterFactory({\n        transformer,\n        errorFormatter,\n        isDev: process.env.NODE_ENV !== 'production'\n    })(procedures);\n    return newRouter;\n}\n\nfunction getDataTransformer(transformer) {\n    if ('input' in transformer) {\n        return transformer;\n    }\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\nconst PROCEDURE_DEFINITION_MAP = {\n    query: 'queries',\n    mutation: 'mutations',\n    subscription: 'subscriptions'\n};\nfunction safeObject(...args) {\n    return Object.assign(Object.create(null), ...args);\n}\n/**\n * @internal The type signature of this class may change without warning.\n * @deprecated\n */ class Router {\n    static prefixProcedures(procedures, prefix) {\n        const eps = safeObject();\n        for (const [key, procedure] of Object.entries(procedures)){\n            eps[prefix + key] = procedure;\n        }\n        return eps;\n    }\n    query(path, procedure) {\n        const router = new Router({\n            queries: safeObject({\n                [path]: createProcedure(procedure)\n            })\n        });\n        return this.merge(router);\n    }\n    mutation(path, procedure) {\n        const router = new Router({\n            mutations: safeObject({\n                [path]: createProcedure(procedure)\n            })\n        });\n        return this.merge(router);\n    }\n    subscription(path, procedure) {\n        const router = new Router({\n            subscriptions: safeObject({\n                [path]: createProcedure(procedure)\n            })\n        });\n        return this.merge(router);\n    }\n    merge(prefixOrRouter, maybeRouter) {\n        let prefix = '';\n        let childRouter;\n        if (typeof prefixOrRouter === 'string' && maybeRouter instanceof Router) {\n            prefix = prefixOrRouter;\n            childRouter = maybeRouter;\n        } else if (prefixOrRouter instanceof Router) {\n            childRouter = prefixOrRouter;\n        } else {\n            throw new Error('Invalid args');\n        }\n        const duplicateQueries = Object.keys(childRouter._def.queries).filter((key)=>!!this._def.queries[prefix + key]);\n        const duplicateMutations = Object.keys(childRouter._def.mutations).filter((key)=>!!this._def.mutations[prefix + key]);\n        const duplicateSubscriptions = Object.keys(childRouter._def.subscriptions).filter((key)=>!!this._def.subscriptions[prefix + key]);\n        const duplicates = [\n            ...duplicateQueries,\n            ...duplicateMutations,\n            ...duplicateSubscriptions\n        ];\n        if (duplicates.length) {\n            throw new Error(`Duplicate endpoint(s): ${duplicates.join(', ')}`);\n        }\n        const mergeProcedures = (defs)=>{\n            const newDefs = safeObject();\n            for (const [key, procedure] of Object.entries(defs)){\n                const newProcedure = procedure.inheritMiddlewares(this._def.middlewares);\n                newDefs[key] = newProcedure;\n            }\n            return Router.prefixProcedures(newDefs, prefix);\n        };\n        return new Router({\n            ...this._def,\n            queries: safeObject(this._def.queries, mergeProcedures(childRouter._def.queries)),\n            mutations: safeObject(this._def.mutations, mergeProcedures(childRouter._def.mutations)),\n            subscriptions: safeObject(this._def.subscriptions, mergeProcedures(childRouter._def.subscriptions))\n        });\n    }\n    /**\n   * Invoke procedure. Only for internal use within library.\n   */ async call(opts) {\n        const { type , path  } = opts;\n        const defTarget = PROCEDURE_DEFINITION_MAP[type];\n        const defs = this._def[defTarget];\n        const procedure = defs[path];\n        if (!procedure) {\n            throw new TRPCError({\n                code: 'NOT_FOUND',\n                message: `No \"${type}\"-procedure on path \"${path}\"`\n            });\n        }\n        return procedure.call(opts);\n    }\n    createCaller(ctx) {\n        return {\n            query: (path, ...args)=>{\n                return this.call({\n                    type: 'query',\n                    ctx,\n                    path,\n                    rawInput: args[0]\n                });\n            },\n            mutation: (path, ...args)=>{\n                return this.call({\n                    type: 'mutation',\n                    ctx,\n                    path,\n                    rawInput: args[0]\n                });\n            },\n            subscription: (path, ...args)=>{\n                return this.call({\n                    type: 'subscription',\n                    ctx,\n                    path,\n                    rawInput: args[0]\n                });\n            }\n        };\n    }\n    /**\n   * Function to be called before any procedure is invoked\n   * @link https://trpc.io/docs/middlewares\n   */ middleware(middleware) {\n        return new Router({\n            ...this._def,\n            middlewares: [\n                ...this._def.middlewares,\n                middleware\n            ]\n        });\n    }\n    /**\n   * Format errors\n   * @link https://trpc.io/docs/error-formatting\n   */ formatError(errorFormatter) {\n        if (this._def.errorFormatter !== defaultFormatter) {\n            throw new Error('You seem to have double `formatError()`-calls in your router tree');\n        }\n        return new Router({\n            ...this._def,\n            errorFormatter: errorFormatter\n        });\n    }\n    getErrorShape(opts) {\n        const { path , error  } = opts;\n        const { code  } = opts.error;\n        const shape = {\n            message: error.message,\n            code: TRPC_ERROR_CODES_BY_KEY[code],\n            data: {\n                code,\n                httpStatus: getHTTPStatusCodeFromError(error)\n            }\n        };\n        if (globalThis.process?.env?.NODE_ENV !== 'production' && typeof opts.error.stack === 'string') {\n            shape.data.stack = opts.error.stack;\n        }\n        if (typeof path === 'string') {\n            shape.data.path = path;\n        }\n        return this._def.errorFormatter({\n            ...opts,\n            shape\n        });\n    }\n    /**\n   * Add data transformer to serialize/deserialize input args + output\n   * @link https://trpc.io/docs/data-transformers\n   */ transformer(_transformer) {\n        const transformer = getDataTransformer(_transformer);\n        if (this._def.transformer !== defaultTransformer) {\n            throw new Error('You seem to have double `transformer()`-calls in your router tree');\n        }\n        return new Router({\n            ...this._def,\n            transformer\n        });\n    }\n    /**\n   * Flattens the generics of TQueries/TMutations/TSubscriptions.\n   * ⚠️ Experimental - might disappear. ⚠️\n   *\n   * @alpha\n   */ flat() {\n        return this;\n    }\n    /**\n   * Interop mode for v9.x -> v10.x\n   */ interop() {\n        return migrateRouter(this);\n    }\n    constructor(def){\n        this._def = {\n            queries: def?.queries ?? safeObject(),\n            mutations: def?.mutations ?? safeObject(),\n            subscriptions: def?.subscriptions ?? safeObject(),\n            middlewares: def?.middlewares ?? [],\n            errorFormatter: def?.errorFormatter ?? defaultFormatter,\n            transformer: def?.transformer ?? defaultTransformer\n        };\n    }\n}\n/**\n * @deprecated\n */ function router() {\n    return new Router();\n}\n\nfunction mergeRouters(...routerList) {\n    const record = mergeWithoutOverrides({}, ...routerList.map((r)=>r._def.record));\n    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{\n        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {\n                throw new Error('You seem to have several error formatters');\n            }\n            return nextRouter._def._config.errorFormatter;\n        }\n        return currentErrorFormatter;\n    }, defaultFormatter);\n    const transformer = routerList.reduce((prev, current)=>{\n        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n            if (prev !== defaultTransformer && prev !== current._def._config.transformer) {\n                throw new Error('You seem to have several transformers');\n            }\n            return current._def._config.transformer;\n        }\n        return prev;\n    }, defaultTransformer);\n    const router = createRouterFactory({\n        errorFormatter,\n        transformer,\n        isDev: routerList.some((r)=>r._def._config.isDev),\n        allowOutsideOfServer: routerList.some((r)=>r._def._config.allowOutsideOfServer),\n        isServer: routerList.some((r)=>r._def._config.isServer),\n        $types: routerList[0]?._def._config.$types\n    })(record);\n    return router;\n}\n\n/**\n * TODO: This can be improved:\n * - We should be able to chain `.meta()`/`.context()` only once\n * - Simplify typings\n * - Doesn't need to be a class but it doesn't really hurt either\n */ class TRPCBuilder {\n    context() {\n        return new TRPCBuilder();\n    }\n    meta() {\n        return new TRPCBuilder();\n    }\n    create(options) {\n        return createTRPCInner()(options);\n    }\n}\n/**\n * Initialize tRPC - done exactly once per backend\n */ const initTRPC = new TRPCBuilder();\nfunction createTRPCInner() {\n    return function initTRPCInner(runtime) {\n        const errorFormatter = runtime?.errorFormatter ?? defaultFormatter;\n        const transformer = getDataTransformer$1(runtime?.transformer ?? defaultTransformer);\n        const config = {\n            transformer,\n            isDev: runtime?.isDev ?? globalThis.process?.env?.NODE_ENV !== 'production',\n            allowOutsideOfServer: runtime?.allowOutsideOfServer ?? false,\n            errorFormatter,\n            isServer: runtime?.isServer ?? isServerDefault,\n            /**\n       * @internal\n       */ $types: createFlatProxy((key)=>{\n                throw new Error(`Tried to access \"$types.${key}\" which is not available at runtime`);\n            })\n        };\n        {\n            // Server check\n            const isServer = runtime?.isServer ?? isServerDefault;\n            if (!isServer && runtime?.allowOutsideOfServer !== true) {\n                throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);\n            }\n        }\n        return {\n            /**\n       * These are just types, they can't be used\n       * @internal\n       */ _config: config,\n            /**\n       * Builder object for creating procedures\n       */ procedure: createBuilder({\n                meta: runtime?.defaultMeta\n            }),\n            /**\n       * Create reusable middlewares\n       */ middleware: createMiddlewareFactory(),\n            /**\n       * Create a router\n       */ router: createRouterFactory(config),\n            /**\n       * Merge Routers\n       */ mergeRouters\n        };\n    };\n}\n\nexport { createInputMiddleware, createOutputMiddleware, initTRPC, router };\n", "export class DoubleIndexedKV<K, V> {\n  keyToValue = new Map<K, V>();\n  valueToKey = new Map<V, K>();\n\n  set(key: K, value: V) {\n    this.keyToValue.set(key, value);\n    this.valueToKey.set(value, key);\n  }\n\n  getByKey(key: K): V | undefined {\n    return this.keyToValue.get(key);\n  }\n\n  getByValue(value: V): K | undefined {\n    return this.valueToKey.get(value);\n  }\n\n  clear() {\n    this.keyToValue.clear();\n    this.valueToKey.clear();\n  }\n}\n", "import { DoubleIndexedKV } from './double-indexed-kv';\n\nexport class Registry<T> {\n  private kv = new DoubleIndexedKV<string, T>();\n\n  constructor(private readonly generateIdentifier: (v: T) => string) {}\n\n  register(value: T, identifier?: string): void {\n    if (this.kv.getByValue(value)) {\n      return;\n    }\n\n    if (!identifier) {\n      identifier = this.generateIdentifier(value);\n    }\n\n    this.kv.set(identifier, value);\n  }\n\n  clear(): void {\n    this.kv.clear();\n  }\n\n  getIdentifier(value: T) {\n    return this.kv.getByValue(value);\n  }\n\n  getValue(identifier: string) {\n    return this.kv.getByKey(identifier);\n  }\n}\n", "import { Registry } from './registry';\nimport { Class } from './types';\n\nexport interface RegisterOptions {\n  identifier?: string;\n  allowProps?: string[];\n}\n\nexport class ClassRegistry extends Registry<Class> {\n  constructor() {\n    super(c => c.name);\n  }\n\n  private classToAllowedProps = new Map<Class, string[]>();\n\n  register(value: Class, options?: string | RegisterOptions): void {\n    if (typeof options === 'object') {\n      if (options.allowProps) {\n        this.classToAllowedProps.set(value, options.allowProps);\n      }\n\n      super.register(value, options.identifier);\n    } else {\n      super.register(value, options);\n    }\n  }\n\n  getAllowedProps(value: Class): string[] | undefined {\n    return this.classToAllowedProps.get(value);\n  }\n}\n", "function valuesOfObj<T>(record: Record<string, T>): T[] {\n  if ('values' in Object) {\n    // eslint-disable-next-line es5/no-es6-methods\n    return Object.values(record);\n  }\n\n  const values: T[] = [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in record) {\n    if (record.hasOwnProperty(key)) {\n      values.push(record[key]);\n    }\n  }\n\n  return values;\n}\n\nexport function find<T>(\n  record: Record<string, T>,\n  predicate: (v: T) => boolean\n): T | undefined {\n  const values = valuesOfObj(record);\n  if ('find' in values) {\n    // eslint-disable-next-line es5/no-es6-methods\n    return values.find(predicate);\n  }\n\n  const valuesNotNever = values as T[];\n\n  for (let i = 0; i < valuesNotNever.length; i++) {\n    const value = valuesNotNever[i];\n    if (predicate(value)) {\n      return value;\n    }\n  }\n\n  return undefined;\n}\n\nexport function forEach<T>(\n  record: Record<string, T>,\n  run: (v: T, key: string) => void\n) {\n  Object.entries(record).forEach(([key, value]) => run(value, key));\n}\n\nexport function includes<T>(arr: T[], value: T) {\n  return arr.indexOf(value) !== -1;\n}\n\nexport function findArr<T>(\n  record: T[],\n  predicate: (v: T) => boolean\n): T | undefined {\n  for (let i = 0; i < record.length; i++) {\n    const value = record[i];\n    if (predicate(value)) {\n      return value;\n    }\n  }\n\n  return undefined;\n}\n", "import { JSONValue } from './types';\nimport { find } from './util';\n\nexport interface CustomTransfomer<I, O extends JSONValue> {\n  name: string;\n  isApplicable: (v: any) => v is I;\n  serialize: (v: I) => O;\n  deserialize: (v: O) => I;\n}\n\nexport class CustomTransformerRegistry {\n  private transfomers: Record<string, CustomTransfomer<any, any>> = {};\n\n  register<I, O extends JSONValue>(transformer: CustomTransfomer<I, O>) {\n    this.transfomers[transformer.name] = transformer;\n  }\n\n  findApplicable<T>(v: T) {\n    return find(this.transfomers, transformer =>\n      transformer.isApplicable(v)\n    ) as CustomTransfomer<T, JSONValue> | undefined;\n  }\n\n  findByName(name: string) {\n    return this.transfomers[name];\n  }\n}\n", "const getType = (payload: any): string =>\n  Object.prototype.toString.call(payload).slice(8, -1);\n\nexport const isUndefined = (payload: any): payload is undefined =>\n  typeof payload === 'undefined';\n\nexport const isNull = (payload: any): payload is null => payload === null;\n\nexport const isPlainObject = (\n  payload: any\n): payload is { [key: string]: any } => {\n  if (typeof payload !== 'object' || payload === null) return false;\n  if (payload === Object.prototype) return false;\n  if (Object.getPrototypeOf(payload) === null) return true;\n\n  return Object.getPrototypeOf(payload) === Object.prototype;\n};\n\nexport const isEmptyObject = (payload: any): payload is {} =>\n  isPlainObject(payload) && Object.keys(payload).length === 0;\n\nexport const isArray = (payload: any): payload is any[] =>\n  Array.isArray(payload);\n\nexport const isString = (payload: any): payload is string =>\n  typeof payload === 'string';\n\nexport const isNumber = (payload: any): payload is number =>\n  typeof payload === 'number' && !isNaN(payload);\n\nexport const isBoolean = (payload: any): payload is boolean =>\n  typeof payload === 'boolean';\n\nexport const isRegExp = (payload: any): payload is RegExp =>\n  payload instanceof RegExp;\n\nexport const isMap = (payload: any): payload is Map<any, any> =>\n  payload instanceof Map;\n\nexport const isSet = (payload: any): payload is Set<any> =>\n  payload instanceof Set;\n\nexport const isSymbol = (payload: any): payload is symbol =>\n  getType(payload) === 'Symbol';\n\nexport const isDate = (payload: any): payload is Date =>\n  payload instanceof Date && !isNaN(payload.valueOf());\n\nexport const isError = (payload: any): payload is Error =>\n  payload instanceof Error;\n\nexport const isNaNValue = (payload: any): payload is typeof NaN =>\n  typeof payload === 'number' && isNaN(payload);\n\nexport const isPrimitive = (\n  payload: any\n): payload is boolean | null | undefined | number | string | symbol =>\n  isBoolean(payload) ||\n  isNull(payload) ||\n  isUndefined(payload) ||\n  isNumber(payload) ||\n  isString(payload) ||\n  isSymbol(payload);\n\nexport const isBigint = (payload: any): payload is bigint =>\n  typeof payload === 'bigint';\n\nexport const isInfinite = (payload: any): payload is number =>\n  payload === Infinity || payload === -Infinity;\n\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nexport type TypedArray = InstanceType<TypedArrayConstructor>;\n\nexport const isTypedArray = (payload: any): payload is TypedArray =>\n  ArrayBuffer.isView(payload) && !(payload instanceof DataView);\n\nexport const isURL = (payload: any): payload is URL => payload instanceof URL;\n", "export type StringifiedPath = string;\ntype Path = string[];\n\nexport const escapeKey = (key: string) => key.replace(/\\./g, '\\\\.');\n\nexport const stringifyPath = (path: Path): StringifiedPath =>\n  path\n    .map(String)\n    .map(escapeKey)\n    .join('.');\n\nexport const parsePath = (string: StringifiedPath) => {\n  const result: string[] = [];\n\n  let segment = '';\n  for (let i = 0; i < string.length; i++) {\n    let char = string.charAt(i);\n\n    const isEscapedDot = char === '\\\\' && string.charAt(i + 1) === '.';\n    if (isEscapedDot) {\n      segment += '.';\n      i++;\n      continue;\n    }\n\n    const isEndOfSegment = char === '.';\n    if (isEndOfSegment) {\n      result.push(segment);\n      segment = '';\n      continue;\n    }\n\n    segment += char;\n  }\n\n  const lastSegment = segment;\n  result.push(lastSegment);\n\n  return result;\n};\n", "import {\n  isBigint,\n  isDate,\n  isInfinite,\n  isMap,\n  isNaNValue,\n  isRegExp,\n  isSet,\n  isUndefined,\n  isSymbol,\n  isArray,\n  isError,\n  isTypedArray,\n  TypedArrayConstructor,\n  isURL,\n} from './is';\nimport { findArr } from './util';\nimport SuperJSON from '.';\n\nexport type PrimitiveTypeAnnotation = 'number' | 'undefined' | 'bigint';\n\ntype LeafTypeAnnotation =\n  | PrimitiveTypeAnnotation\n  | 'regexp'\n  | 'Date'\n  | 'Error'\n  | 'URL';\n\ntype TypedArrayAnnotation = ['typed-array', string];\ntype ClassTypeAnnotation = ['class', string];\ntype SymbolTypeAnnotation = ['symbol', string];\ntype CustomTypeAnnotation = ['custom', string];\n\ntype SimpleTypeAnnotation = LeafTypeAnnotation | 'map' | 'set';\n\ntype CompositeTypeAnnotation =\n  | TypedArrayAnnotation\n  | ClassTypeAnnotation\n  | SymbolTypeAnnotation\n  | CustomTypeAnnotation;\n\nexport type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;\n\nfunction simpleTransformation<I, O, A extends SimpleTypeAnnotation>(\n  isApplicable: (v: any, superJson: SuperJSON) => v is I,\n  annotation: A,\n  transform: (v: I, superJson: SuperJSON) => O,\n  untransform: (v: O, superJson: SuperJSON) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst simpleRules = [\n  simpleTransformation(\n    isUndefined,\n    'undefined',\n    () => null,\n    () => undefined\n  ),\n  simpleTransformation(\n    isBigint,\n    'bigint',\n    v => v.toString(),\n    v => {\n      if (typeof BigInt !== 'undefined') {\n        return BigInt(v);\n      }\n\n      console.error('Please add a BigInt polyfill.');\n\n      return v as any;\n    }\n  ),\n  simpleTransformation(\n    isDate,\n    'Date',\n    v => v.toISOString(),\n    v => new Date(v)\n  ),\n\n  simpleTransformation(\n    isError,\n    'Error',\n    (v, superJson) => {\n      const baseError: any = {\n        name: v.name,\n        message: v.message,\n      };\n\n      superJson.allowedErrorProps.forEach(prop => {\n        baseError[prop] = (v as any)[prop];\n      });\n\n      return baseError;\n    },\n    (v, superJson) => {\n      const e = new Error(v.message);\n      e.name = v.name;\n      e.stack = v.stack;\n\n      superJson.allowedErrorProps.forEach(prop => {\n        (e as any)[prop] = v[prop];\n      });\n\n      return e;\n    }\n  ),\n\n  simpleTransformation(\n    isRegExp,\n    'regexp',\n    v => '' + v,\n    regex => {\n      const body = regex.slice(1, regex.lastIndexOf('/'));\n      const flags = regex.slice(regex.lastIndexOf('/') + 1);\n      return new RegExp(body, flags);\n    }\n  ),\n\n  simpleTransformation(\n    isSet,\n    'set',\n    // (sets only exist in es6+)\n    // eslint-disable-next-line es5/no-es6-methods\n    v => [...v.values()],\n    v => new Set(v)\n  ),\n  simpleTransformation(\n    isMap,\n    'map',\n    v => [...v.entries()],\n    v => new Map(v)\n  ),\n\n  simpleTransformation<number, 'NaN' | 'Infinity' | '-Infinity', 'number'>(\n    (v): v is number => isNaNValue(v) || isInfinite(v),\n    'number',\n    v => {\n      if (isNaNValue(v)) {\n        return 'NaN';\n      }\n\n      if (v > 0) {\n        return 'Infinity';\n      } else {\n        return '-Infinity';\n      }\n    },\n    Number\n  ),\n\n  simpleTransformation<number, '-0', 'number'>(\n    (v): v is number => v === 0 && 1 / v === -Infinity,\n    'number',\n    () => {\n      return '-0';\n    },\n    Number\n  ),\n\n  simpleTransformation(\n    isURL,\n    'URL',\n    v => v.toString(),\n    v => new URL(v)\n  ),\n];\n\nfunction compositeTransformation<I, O, A extends CompositeTypeAnnotation>(\n  isApplicable: (v: any, superJson: SuperJSON) => v is I,\n  annotation: (v: I, superJson: SuperJSON) => A,\n  transform: (v: I, superJson: SuperJSON) => O,\n  untransform: (v: O, a: A, superJson: SuperJSON) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst symbolRule = compositeTransformation(\n  (s, superJson): s is Symbol => {\n    if (isSymbol(s)) {\n      const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\n      return isRegistered;\n    }\n    return false;\n  },\n  (s, superJson) => {\n    const identifier = superJson.symbolRegistry.getIdentifier(s);\n    return ['symbol', identifier!];\n  },\n  v => v.description,\n  (_, a, superJson) => {\n    const value = superJson.symbolRegistry.getValue(a[1]);\n    if (!value) {\n      throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n  }\n);\n\nconst constructorToName = [\n  Int8Array,\n  Uint8Array,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  Uint8ClampedArray,\n].reduce<Record<string, TypedArrayConstructor>>((obj, ctor) => {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\n\nconst typedArrayRule = compositeTransformation(\n  isTypedArray,\n  v => ['typed-array', v.constructor.name],\n  v => [...v],\n  (v, a) => {\n    const ctor = constructorToName[a[1]];\n\n    if (!ctor) {\n      throw new Error('Trying to deserialize unknown typed array');\n    }\n\n    return new ctor(v);\n  }\n);\n\nexport function isInstanceOfRegisteredClass(\n  potentialClass: any,\n  superJson: SuperJSON\n): potentialClass is any {\n  if (potentialClass?.constructor) {\n    const isRegistered = !!superJson.classRegistry.getIdentifier(\n      potentialClass.constructor\n    );\n    return isRegistered;\n  }\n  return false;\n}\n\nconst classRule = compositeTransformation(\n  isInstanceOfRegisteredClass,\n  (clazz, superJson) => {\n    const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier!];\n  },\n  (clazz, superJson) => {\n    const allowedProps = superJson.classRegistry.getAllowedProps(\n      clazz.constructor\n    );\n    if (!allowedProps) {\n      return { ...clazz };\n    }\n\n    const result: any = {};\n    allowedProps.forEach(prop => {\n      result[prop] = clazz[prop];\n    });\n    return result;\n  },\n  (v, a, superJson) => {\n    const clazz = superJson.classRegistry.getValue(a[1]);\n\n    if (!clazz) {\n      throw new Error(\n        'Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564'\n      );\n    }\n\n    return Object.assign(Object.create(clazz.prototype), v);\n  }\n);\n\nconst customRule = compositeTransformation(\n  (value, superJson): value is any => {\n    return !!superJson.customTransformerRegistry.findApplicable(value);\n  },\n  (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(\n      value\n    )!;\n    return ['custom', transformer.name];\n  },\n  (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(\n      value\n    )!;\n    return transformer.serialize(value);\n  },\n  (v, a, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findByName(a[1]);\n    if (!transformer) {\n      throw new Error('Trying to deserialize unknown custom value');\n    }\n    return transformer.deserialize(v);\n  }\n);\n\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\n\nexport const transformValue = (\n  value: any,\n  superJson: SuperJSON\n): { value: any; type: TypeAnnotation } | undefined => {\n  const applicableCompositeRule = findArr(compositeRules, rule =>\n    rule.isApplicable(value, superJson)\n  );\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value as never, superJson),\n      type: applicableCompositeRule.annotation(value, superJson),\n    };\n  }\n\n  const applicableSimpleRule = findArr(simpleRules, rule =>\n    rule.isApplicable(value, superJson)\n  );\n\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value as never, superJson),\n      type: applicableSimpleRule.annotation,\n    };\n  }\n\n  return undefined;\n};\n\nconst simpleRulesByAnnotation: Record<string, typeof simpleRules[0]> = {};\nsimpleRules.forEach(rule => {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\n\nexport const untransformValue = (\n  json: any,\n  type: TypeAnnotation,\n  superJson: SuperJSON\n) => {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type, superJson);\n      case 'class':\n        return classRule.untransform(json, type, superJson);\n      case 'custom':\n        return customRule.untransform(json, type, superJson);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type, superJson);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n\n    return transformation.untransform(json as never, superJson);\n  }\n};\n", "import { isMap, isArray, isPlainObject, isSet } from './is';\nimport { includes } from './util';\n\nconst getNthKey = (value: Map<any, any> | Set<any>, n: number): any => {\n  const keys = value.keys();\n  while (n > 0) {\n    keys.next();\n    n--;\n  }\n\n  return keys.next().value;\n};\n\nfunction validatePath(path: (string | number)[]) {\n  if (includes(path, '__proto__')) {\n    throw new Error('__proto__ is not allowed as a property');\n  }\n  if (includes(path, 'prototype')) {\n    throw new Error('prototype is not allowed as a property');\n  }\n  if (includes(path, 'constructor')) {\n    throw new Error('constructor is not allowed as a property');\n  }\n}\n\nexport const getDeep = (object: object, path: (string | number)[]): object => {\n  validatePath(path);\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    if (isSet(object)) {\n      object = getNthKey(object, +key);\n    } else if (isMap(object)) {\n      const row = +key;\n      const type = +path[++i] === 0 ? 'key' : 'value';\n\n      const keyOfRow = getNthKey(object, row);\n      switch (type) {\n        case 'key':\n          object = keyOfRow;\n          break;\n        case 'value':\n          object = object.get(keyOfRow);\n          break;\n      }\n    } else {\n      object = (object as any)[key];\n    }\n  }\n\n  return object;\n};\n\nexport const setDeep = (\n  object: any,\n  path: (string | number)[],\n  mapper: (v: any) => any\n): any => {\n  validatePath(path);\n\n  if (path.length === 0) {\n    return mapper(object);\n  }\n\n  let parent = object;\n\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n\n    if (isArray(parent)) {\n      const index = +key;\n      parent = parent[index];\n    } else if (isPlainObject(parent)) {\n      parent = parent[key];\n    } else if (isSet(parent)) {\n      const row = +key;\n      parent = getNthKey(parent, row);\n    } else if (isMap(parent)) {\n      const isEnd = i === path.length - 2;\n      if (isEnd) {\n        break;\n      }\n\n      const row = +key;\n      const type = +path[++i] === 0 ? 'key' : 'value';\n\n      const keyOfRow = getNthKey(parent, row);\n      switch (type) {\n        case 'key':\n          parent = keyOfRow;\n          break;\n        case 'value':\n          parent = parent.get(keyOfRow);\n          break;\n      }\n    }\n  }\n\n  const lastKey = path[path.length - 1];\n\n  if (isArray(parent)) {\n    parent[+lastKey] = mapper(parent[+lastKey]);\n  } else if (isPlainObject(parent)) {\n    parent[lastKey] = mapper(parent[lastKey]);\n  }\n\n  if (isSet(parent)) {\n    const oldValue = getNthKey(parent, +lastKey);\n    const newValue = mapper(oldValue);\n    if (oldValue !== newValue) {\n      parent.delete(oldValue);\n      parent.add(newValue);\n    }\n  }\n\n  if (isMap(parent)) {\n    const row = +path[path.length - 2];\n    const keyToRow = getNthKey(parent, row);\n\n    const type = +lastKey === 0 ? 'key' : 'value';\n    switch (type) {\n      case 'key': {\n        const newKey = mapper(keyToRow);\n        parent.set(newKey, parent.get(keyToRow));\n\n        if (newKey !== keyToRow) {\n          parent.delete(keyToRow);\n        }\n        break;\n      }\n\n      case 'value': {\n        parent.set(keyToRow, mapper(parent.get(keyToRow)));\n        break;\n      }\n    }\n  }\n\n  return object;\n};\n", "import {\n  isArray,\n  isEmptyObject,\n  isMap,\n  isPlainObject,\n  isPrimitive,\n  isSet,\n} from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport {\n  isInstanceOfRegisteredClass,\n  transformValue,\n  TypeAnnotation,\n  untransformValue,\n} from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\nimport SuperJSON from '.';\n\ntype Tree<T> = InnerNode<T> | Leaf<T>;\ntype Leaf<T> = [T];\ntype InnerNode<T> = [T, Record<string, Tree<T>>];\n\nexport type MinimisedTree<T> = Tree<T> | Record<string, Tree<T>> | undefined;\n\nfunction traverse<T>(\n  tree: MinimisedTree<T>,\n  walker: (v: T, path: string[]) => void,\n  origin: string[] = []\n): void {\n  if (!tree) {\n    return;\n  }\n\n  if (!isArray(tree)) {\n    forEach(tree, (subtree, key) =>\n      traverse(subtree, walker, [...origin, ...parsePath(key)])\n    );\n    return;\n  }\n\n  const [nodeValue, children] = tree;\n  if (children) {\n    forEach(children, (child, key) => {\n      traverse(child, walker, [...origin, ...parsePath(key)]);\n    });\n  }\n\n  walker(nodeValue, origin);\n}\n\nexport function applyValueAnnotations(\n  plain: any,\n  annotations: MinimisedTree<TypeAnnotation>,\n  superJson: SuperJSON\n) {\n  traverse(annotations, (type, path) => {\n    plain = setDeep(plain, path, v => untransformValue(v, type, superJson));\n  });\n\n  return plain;\n}\n\nexport function applyReferentialEqualityAnnotations(\n  plain: any,\n  annotations: ReferentialEqualityAnnotations\n) {\n  function apply(identicalPaths: string[], path: string) {\n    const object = getDeep(plain, parsePath(path));\n\n    identicalPaths.map(parsePath).forEach(identicalObjectPath => {\n      plain = setDeep(plain, identicalObjectPath, () => object);\n    });\n  }\n\n  if (isArray(annotations)) {\n    const [root, other] = annotations;\n    root.forEach(identicalPath => {\n      plain = setDeep(plain, parsePath(identicalPath), () => plain);\n    });\n\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n\n  return plain;\n}\n\nconst isDeep = (object: any, superJson: SuperJSON): boolean =>\n  isPlainObject(object) ||\n  isArray(object) ||\n  isMap(object) ||\n  isSet(object) ||\n  isInstanceOfRegisteredClass(object, superJson);\n\nfunction addIdentity(object: any, path: any[], identities: Map<any, any[][]>) {\n  const existingSet = identities.get(object);\n\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\n\ninterface Result {\n  transformedValue: any;\n  annotations?: MinimisedTree<TypeAnnotation>;\n}\n\nexport type ReferentialEqualityAnnotations =\n  | Record<string, string[]>\n  | [string[]]\n  | [string[], Record<string, string[]>];\n\nexport function generateReferentialEqualityAnnotations(\n  identitites: Map<any, any[][]>,\n  dedupe: boolean\n): ReferentialEqualityAnnotations | undefined {\n  const result: Record<string, string[]> = {};\n  let rootEqualityPaths: string[] | undefined = undefined;\n\n  identitites.forEach(paths => {\n    if (paths.length <= 1) {\n      return;\n    }\n\n    // if we're not deduping, all of these objects continue existing.\n    // putting the shortest path first makes it easier to parse for humans\n    // if we're deduping though, only the first entry will still exist, so we can't do this optimisation.\n    if (!dedupe) {\n      paths = paths\n        .map(path => path.map(String))\n        .sort((a, b) => a.length - b.length);\n    }\n\n    const [representativePath, ...identicalPaths] = paths;\n\n    if (representativePath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(representativePath)] = identicalPaths.map(\n        stringifyPath\n      );\n    }\n  });\n\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\n\nexport const walker = (\n  object: any,\n  identities: Map<any, any[][]>,\n  superJson: SuperJSON,\n  dedupe: boolean,\n  path: any[] = [],\n  objectsInThisPath: any[] = [],\n  seenObjects = new Map<unknown, Result>()\n): Result => {\n  const primitive = isPrimitive(object);\n\n  if (!primitive) {\n    addIdentity(object, path, identities);\n\n    const seen = seenObjects.get(object);\n    if (seen) {\n      // short-circuit result if we've seen this object before\n      return dedupe\n        ? {\n            transformedValue: null,\n          }\n        : seen;\n    }\n  }\n\n  if (!isDeep(object, superJson)) {\n    const transformed = transformValue(object, superJson);\n\n    const result: Result = transformed\n      ? {\n          transformedValue: transformed.value,\n          annotations: [transformed.type],\n        }\n      : {\n          transformedValue: object,\n        };\n    if (!primitive) {\n      seenObjects.set(object, result);\n    }\n    return result;\n  }\n\n  if (includes(objectsInThisPath, object)) {\n    // prevent circular references\n    return {\n      transformedValue: null,\n    };\n  }\n\n  const transformationResult = transformValue(object, superJson);\n  const transformed = transformationResult?.value ?? object;\n\n  const transformedValue: any = isArray(transformed) ? [] : {};\n  const innerAnnotations: Record<string, Tree<TypeAnnotation>> = {};\n\n  forEach(transformed, (value, index) => {\n    const recursiveResult = walker(\n      value,\n      identities,\n      superJson,\n      dedupe,\n      [...path, index],\n      [...objectsInThisPath, object],\n      seenObjects\n    );\n\n    transformedValue[index] = recursiveResult.transformedValue;\n\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, (tree, key) => {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n\n  const result: Result = isEmptyObject(innerAnnotations)\n    ? {\n        transformedValue,\n        annotations: !!transformationResult\n          ? [transformationResult.type]\n          : undefined,\n      }\n    : {\n        transformedValue,\n        annotations: !!transformationResult\n          ? [transformationResult.type, innerAnnotations]\n          : innerAnnotations,\n      };\n  if (!primitive) {\n    seenObjects.set(object, result);\n  }\n\n  return result;\n};\n", "function getType(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\n\nfunction isAnyObject(payload) {\n  return getType(payload) === \"Object\";\n}\n\nfunction isArray(payload) {\n  return getType(payload) === \"Array\";\n}\n\nfunction isBlob(payload) {\n  return getType(payload) === \"Blob\";\n}\n\nfunction isBoolean(payload) {\n  return getType(payload) === \"Boolean\";\n}\n\nfunction isDate(payload) {\n  return getType(payload) === \"Date\" && !isNaN(payload);\n}\n\nfunction isEmptyArray(payload) {\n  return isArray(payload) && payload.length === 0;\n}\n\nfunction isPlainObject(payload) {\n  if (getType(payload) !== \"Object\")\n    return false;\n  const prototype = Object.getPrototypeOf(payload);\n  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;\n}\n\nfunction isEmptyObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length === 0;\n}\n\nfunction isEmptyString(payload) {\n  return payload === \"\";\n}\n\nfunction isError(payload) {\n  return getType(payload) === \"Error\" || payload instanceof Error;\n}\n\nfunction isFile(payload) {\n  return getType(payload) === \"File\";\n}\n\nfunction isFullArray(payload) {\n  return isArray(payload) && payload.length > 0;\n}\n\nfunction isFullObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length > 0;\n}\n\nfunction isString(payload) {\n  return getType(payload) === \"String\";\n}\n\nfunction isFullString(payload) {\n  return isString(payload) && payload !== \"\";\n}\n\nfunction isFunction(payload) {\n  return typeof payload === \"function\";\n}\n\nfunction isType(payload, type) {\n  if (!(type instanceof Function)) {\n    throw new TypeError(\"Type must be a function\");\n  }\n  if (!Object.prototype.hasOwnProperty.call(type, \"prototype\")) {\n    throw new TypeError(\"Type is not a class\");\n  }\n  const name = type.name;\n  return getType(payload) === name || Boolean(payload && payload.constructor === type);\n}\n\nfunction isInstanceOf(value, classOrClassName) {\n  if (typeof classOrClassName === \"function\") {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (isType(p, classOrClassName)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (getType(p) === classOrClassName) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nfunction isMap(payload) {\n  return getType(payload) === \"Map\";\n}\n\nfunction isNaNValue(payload) {\n  return getType(payload) === \"Number\" && isNaN(payload);\n}\n\nfunction isNumber(payload) {\n  return getType(payload) === \"Number\" && !isNaN(payload);\n}\n\nfunction isNegativeNumber(payload) {\n  return isNumber(payload) && payload < 0;\n}\n\nfunction isNull(payload) {\n  return getType(payload) === \"Null\";\n}\n\nfunction isOneOf(a, b, c, d, e) {\n  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);\n}\n\nfunction isUndefined(payload) {\n  return getType(payload) === \"Undefined\";\n}\n\nconst isNullOrUndefined = isOneOf(isNull, isUndefined);\n\nfunction isObject(payload) {\n  return isPlainObject(payload);\n}\n\nfunction isObjectLike(payload) {\n  return isAnyObject(payload);\n}\n\nfunction isPositiveNumber(payload) {\n  return isNumber(payload) && payload > 0;\n}\n\nfunction isSymbol(payload) {\n  return getType(payload) === \"Symbol\";\n}\n\nfunction isPrimitive(payload) {\n  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);\n}\n\nfunction isPromise(payload) {\n  return getType(payload) === \"Promise\";\n}\n\nfunction isRegExp(payload) {\n  return getType(payload) === \"RegExp\";\n}\n\nfunction isSet(payload) {\n  return getType(payload) === \"Set\";\n}\n\nfunction isWeakMap(payload) {\n  return getType(payload) === \"WeakMap\";\n}\n\nfunction isWeakSet(payload) {\n  return getType(payload) === \"WeakSet\";\n}\n\nexport { getType, isAnyObject, isArray, isBlob, isBoolean, isDate, isEmptyArray, isEmptyObject, isEmptyString, isError, isFile, isFullArray, isFullObject, isFullString, isFunction, isInstanceOf, isMap, isNaNValue, isNegativeNumber, isNull, isNullOrUndefined, isNumber, isObject, isObjectLike, isOneOf, isPlainObject, isPositiveNumber, isPrimitive, isPromise, isRegExp, isSet, isString, isSymbol, isType, isUndefined, isWeakMap, isWeakSet };\n", "import { isArray, isPlainObject } from 'is-what';\n\nfunction assignProp(carry, key, newVal, originalObject, includeNonenumerable) {\n  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? \"enumerable\" : \"nonenumerable\";\n  if (propType === \"enumerable\")\n    carry[key] = newVal;\n  if (includeNonenumerable && propType === \"nonenumerable\") {\n    Object.defineProperty(carry, key, {\n      value: newVal,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nfunction copy(target, options = {}) {\n  if (isArray(target)) {\n    return target.map((item) => copy(item, options));\n  }\n  if (!isPlainObject(target)) {\n    return target;\n  }\n  const props = Object.getOwnPropertyNames(target);\n  const symbols = Object.getOwnPropertySymbols(target);\n  return [...props, ...symbols].reduce((carry, key) => {\n    if (isArray(options.props) && !options.props.includes(key)) {\n      return carry;\n    }\n    const val = target[key];\n    const newVal = copy(val, options);\n    assignProp(carry, key, newVal, target, options.nonenumerable);\n    return carry;\n  }, {});\n}\n\nexport { copy };\n", "import { Class, JSONValue, SuperJSONResult, SuperJSONValue } from './types';\nimport { ClassRegistry, RegisterOptions } from './class-registry';\nimport { Registry } from './registry';\nimport {\n  CustomTransfomer,\n  CustomTransformerRegistry,\n} from './custom-transformer-registry';\nimport {\n  applyReferentialEqualityAnnotations,\n  applyValueAnnotations,\n  generateReferentialEqualityAnnotations,\n  walker,\n} from './plainer';\nimport { copy } from 'copy-anything';\n\nexport default class SuperJSON {\n  /**\n   * If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.\n   */\n  private readonly dedupe: boolean;\n\n  /**\n   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.\n   */\n  constructor({\n    dedupe = false,\n  }: {\n    dedupe?: boolean;\n  } = {}) {\n    this.dedupe = dedupe;\n  }\n\n  serialize(object: SuperJSONValue): SuperJSONResult {\n    const identities = new Map<any, any[][]>();\n    const output = walker(object, identities, this, this.dedupe);\n    const res: SuperJSONResult = {\n      json: output.transformedValue,\n    };\n\n    if (output.annotations) {\n      res.meta = {\n        ...res.meta,\n        values: output.annotations,\n      };\n    }\n\n    const equalityAnnotations = generateReferentialEqualityAnnotations(\n      identities,\n      this.dedupe\n    );\n    if (equalityAnnotations) {\n      res.meta = {\n        ...res.meta,\n        referentialEqualities: equalityAnnotations,\n      };\n    }\n\n    return res;\n  }\n\n  deserialize<T = unknown>(payload: SuperJSONResult): T {\n    const { json, meta } = payload;\n\n    let result: T = copy(json) as any;\n\n    if (meta?.values) {\n      result = applyValueAnnotations(result, meta.values, this);\n    }\n\n    if (meta?.referentialEqualities) {\n      result = applyReferentialEqualityAnnotations(\n        result,\n        meta.referentialEqualities\n      );\n    }\n\n    return result;\n  }\n\n  stringify(object: SuperJSONValue): string {\n    return JSON.stringify(this.serialize(object));\n  }\n\n  parse<T = unknown>(string: string): T {\n    return this.deserialize(JSON.parse(string));\n  }\n\n  readonly classRegistry = new ClassRegistry();\n  registerClass(v: Class, options?: RegisterOptions | string) {\n    this.classRegistry.register(v, options);\n  }\n\n  readonly symbolRegistry = new Registry<Symbol>(s => s.description ?? '');\n  registerSymbol(v: Symbol, identifier?: string) {\n    this.symbolRegistry.register(v, identifier);\n  }\n\n  readonly customTransformerRegistry = new CustomTransformerRegistry();\n  registerCustom<I, O extends JSONValue>(\n    transformer: Omit<CustomTransfomer<I, O>, 'name'>,\n    name: string\n  ) {\n    this.customTransformerRegistry.register({\n      name,\n      ...transformer,\n    });\n  }\n\n  readonly allowedErrorProps: string[] = [];\n  allowErrorProps(...props: string[]) {\n    this.allowedErrorProps.push(...props);\n  }\n\n  private static defaultInstance = new SuperJSON();\n  static serialize = SuperJSON.defaultInstance.serialize.bind(\n    SuperJSON.defaultInstance\n  );\n  static deserialize = SuperJSON.defaultInstance.deserialize.bind(\n    SuperJSON.defaultInstance\n  );\n  static stringify = SuperJSON.defaultInstance.stringify.bind(\n    SuperJSON.defaultInstance\n  );\n  static parse = SuperJSON.defaultInstance.parse.bind(\n    SuperJSON.defaultInstance\n  );\n  static registerClass = SuperJSON.defaultInstance.registerClass.bind(\n    SuperJSON.defaultInstance\n  );\n  static registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(\n    SuperJSON.defaultInstance\n  );\n  static registerCustom = SuperJSON.defaultInstance.registerCustom.bind(\n    SuperJSON.defaultInstance\n  );\n  static allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(\n    SuperJSON.defaultInstance\n  );\n}\n\nexport { SuperJSON };\n\nexport const serialize = SuperJSON.serialize;\nexport const deserialize = SuperJSON.deserialize;\n\nexport const stringify = SuperJSON.stringify;\nexport const parse = SuperJSON.parse;\n\nexport const registerClass = SuperJSON.registerClass;\nexport const registerCustom = SuperJSON.registerCustom;\nexport const registerSymbol = SuperJSON.registerSymbol;\nexport const allowErrorProps = SuperJSON.allowErrorProps;\n", "function identity(x) {\n    return x;\n}\n\n/** @internal */ function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce((prev, fn)=>fn(prev), input);\n    };\n}\n\nfunction isObservable(x) {\n    return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\nfunction observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) {\n                    return;\n                }\n                unsubscribed = true;\n                if (typeof teardownRef === 'function') {\n                    teardownRef();\n                } else if (teardownRef) {\n                    teardownRef.unsubscribe();\n                }\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    if (isDone) {\n                        return;\n                    }\n                    observer.next?.(value);\n                },\n                error (err) {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.error?.(err);\n                    unsubscribe();\n                },\n                complete () {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.complete?.();\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) {\n                unsubscribe();\n            }\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return pipeFromArray(operations)(self);\n        }\n    };\n    return self;\n}\n\nexport { isObservable as i, observable as o };\n", "export { i as isObservable, o as observable } from '../observable-ade1bad8.mjs';\n\nfunction share(_opts) {\n    return (originalObserver)=>{\n        let refCount = 0;\n        let subscription = null;\n        const observers = [];\n        function startIfNeeded() {\n            if (subscription) {\n                return;\n            }\n            subscription = originalObserver.subscribe({\n                next (value) {\n                    for (const observer of observers){\n                        observer.next?.(value);\n                    }\n                },\n                error (error) {\n                    for (const observer of observers){\n                        observer.error?.(error);\n                    }\n                },\n                complete () {\n                    for (const observer of observers){\n                        observer.complete?.();\n                    }\n                }\n            });\n        }\n        function resetIfNeeded() {\n            // \"resetOnRefCountZero\"\n            if (refCount === 0 && subscription) {\n                const _sub = subscription;\n                subscription = null;\n                _sub.unsubscribe();\n            }\n        }\n        return {\n            subscribe (observer) {\n                refCount++;\n                observers.push(observer);\n                startIfNeeded();\n                return {\n                    unsubscribe () {\n                        refCount--;\n                        resetIfNeeded();\n                        const index = observers.findIndex((v)=>v === observer);\n                        if (index > -1) {\n                            observers.splice(index, 1);\n                        }\n                    }\n                };\n            }\n        };\n    };\n}\n\nfunction map(project) {\n    return (originalObserver)=>{\n        return {\n            subscribe (observer) {\n                let index = 0;\n                const subscription = originalObserver.subscribe({\n                    next (value) {\n                        observer.next?.(project(value, index++));\n                    },\n                    error (error) {\n                        observer.error?.(error);\n                    },\n                    complete () {\n                        observer.complete?.();\n                    }\n                });\n                return subscription;\n            }\n        };\n    };\n}\n\nfunction tap(observer) {\n    return (originalObserver)=>{\n        return {\n            subscribe (observer2) {\n                return originalObserver.subscribe({\n                    next (v) {\n                        observer.next?.(v);\n                        observer2.next?.(v);\n                    },\n                    error (v) {\n                        observer.error?.(v);\n                        observer2.error?.(v);\n                    },\n                    complete () {\n                        observer.complete?.();\n                        observer2.complete?.();\n                    }\n                });\n            }\n        };\n    };\n}\n\nclass ObservableAbortError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'ObservableAbortError';\n        Object.setPrototypeOf(this, ObservableAbortError.prototype);\n    }\n}\n/** @internal */ function observableToPromise(observable) {\n    let abort;\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) {\n                return;\n            }\n            isDone = true;\n            reject(new ObservableAbortError('This operation was aborted.'));\n            obs$.unsubscribe();\n        }\n        const obs$ = observable.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                isDone = true;\n                reject(data);\n                onDone();\n            },\n            complete () {\n                isDone = true;\n                onDone();\n            }\n        });\n        abort = onDone;\n    });\n    return {\n        promise,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        abort: abort\n    };\n}\n\nexport { map, observableToPromise, share, tap };\n", "import { observable } from '@trpc/server/observable';\n\n/** @internal */ function createChain(opts) {\n    return observable((observer)=>{\n        function execute(index = 0, op = opts.op) {\n            const next = opts.links[index];\n            if (!next) {\n                throw new Error('No more links to execute - did you forget to add an ending link?');\n            }\n            const subscription = next({\n                op,\n                next (nextOp) {\n                    const nextObserver = execute(index + 1, nextOp);\n                    return nextObserver;\n                }\n            });\n            return subscription;\n        }\n        const obs$ = execute();\n        return obs$.subscribe(observer);\n    });\n}\n\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [\n        value\n    ];\n}\nfunction splitLink(opts) {\n    return (runtime)=>{\n        const yes = asArray(opts.true).map((link)=>link(runtime));\n        const no = asArray(opts.false).map((link)=>link(runtime));\n        return (props)=>{\n            return observable((observer)=>{\n                const links = opts.condition(props.op) ? yes : no;\n                return createChain({\n                    op: props.op,\n                    links\n                }).subscribe(observer);\n            });\n        };\n    };\n}\n\nexport { createChain as c, splitLink as s };\n", "function isTRPCClientError(cause) {\n    return cause instanceof TRPCClientError || /**\n     * @deprecated\n     * Delete in next major\n     */ cause.name === 'TRPCClientError';\n}\nclass TRPCClientError extends Error {\n    static from(cause, opts = {}) {\n        if (!(cause instanceof Error)) {\n            return new TRPCClientError(cause.error.message ?? '', {\n                ...opts,\n                cause: undefined,\n                result: cause\n            });\n        }\n        if (isTRPCClientError(cause)) {\n            if (opts.meta) {\n                // Decorate with meta error data\n                cause.meta = {\n                    ...cause.meta,\n                    ...opts.meta\n                };\n            }\n            return cause;\n        }\n        return new TRPCClientError(cause.message, {\n            ...opts,\n            cause,\n            result: null\n        });\n    }\n    constructor(message, opts){\n        const cause = opts?.cause;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        });\n        this.meta = opts?.meta;\n        this.cause = cause;\n        this.shape = opts?.result?.error;\n        this.data = opts?.result?.error.data;\n        this.name = 'TRPCClientError';\n        Object.setPrototypeOf(this, TRPCClientError.prototype);\n    }\n}\n\nexport { TRPCClientError as T };\n", "import { T as TRPCClientError } from './TRPCClientError-fef6cf44.mjs';\n\nconst isFunction = (fn)=>typeof fn === 'function';\nfunction getFetch(customFetchImpl) {\n    if (customFetchImpl) {\n        return customFetchImpl;\n    }\n    if (typeof window !== 'undefined' && isFunction(window.fetch)) {\n        return window.fetch;\n    }\n    if (typeof globalThis !== 'undefined' && isFunction(globalThis.fetch)) {\n        return globalThis.fetch;\n    }\n    throw new Error('No fetch implementation found');\n}\n\nfunction getAbortController(customAbortControllerImpl) {\n    if (customAbortControllerImpl) {\n        return customAbortControllerImpl;\n    }\n    if (typeof window !== 'undefined' && window.AbortController) {\n        return window.AbortController;\n    }\n    if (typeof globalThis !== 'undefined' && globalThis.AbortController) {\n        return globalThis.AbortController;\n    }\n    return null;\n}\n\nfunction resolveHTTPLinkOptions(opts) {\n    return {\n        url: opts.url,\n        fetch: opts.fetch,\n        AbortController: getAbortController(opts.AbortController)\n    };\n}\n// https://github.com/trpc/trpc/pull/669\nfunction arrayToDict(array) {\n    const dict = {};\n    for(let index = 0; index < array.length; index++){\n        const element = array[index];\n        dict[index] = element;\n    }\n    return dict;\n}\nconst METHOD = {\n    query: 'GET',\n    mutation: 'POST'\n};\nfunction getInput(opts) {\n    return 'input' in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input)=>opts.runtime.transformer.serialize(_input)));\n}\nconst getUrl = (opts)=>{\n    let url = opts.url + '/' + opts.path;\n    const queryParts = [];\n    if ('inputs' in opts) {\n        queryParts.push('batch=1');\n    }\n    if (opts.type === 'query') {\n        const input = getInput(opts);\n        if (input !== undefined) {\n            queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);\n        }\n    }\n    if (queryParts.length) {\n        url += '?' + queryParts.join('&');\n    }\n    return url;\n};\nconst getBody = (opts)=>{\n    if (opts.type === 'query') {\n        return undefined;\n    }\n    const input = getInput(opts);\n    return input !== undefined ? JSON.stringify(input) : undefined;\n};\nconst jsonHttpRequester = (opts)=>{\n    return httpRequest({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        getUrl,\n        getBody\n    });\n};\nasync function fetchHTTPResponse(opts, ac) {\n    const url = opts.getUrl(opts);\n    const body = opts.getBody(opts);\n    const { type  } = opts;\n    const resolvedHeaders = await opts.headers();\n    /* istanbul ignore if -- @preserve */ if (type === 'subscription') {\n        throw new Error('Subscriptions should use wsLink');\n    }\n    const headers = {\n        ...opts.contentTypeHeader ? {\n            'content-type': opts.contentTypeHeader\n        } : {},\n        ...opts.batchModeHeader ? {\n            'trpc-batch-mode': opts.batchModeHeader\n        } : {},\n        ...resolvedHeaders\n    };\n    return getFetch(opts.fetch)(url, {\n        method: METHOD[type],\n        signal: ac?.signal,\n        body: body,\n        headers\n    });\n}\nfunction httpRequest(opts) {\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const meta = {};\n    const promise = new Promise((resolve, reject)=>{\n        fetchHTTPResponse(opts, ac).then((_res)=>{\n            meta.response = _res;\n            return _res.json();\n        }).then((json)=>{\n            meta.responseJSON = json;\n            resolve({\n                json: json,\n                meta\n            });\n        }).catch((err)=>{\n            reject(TRPCClientError.from(err, {\n                meta\n            }));\n        });\n    });\n    const cancel = ()=>{\n        ac?.abort();\n    };\n    return {\n        promise,\n        cancel\n    };\n}\n\nexport { getBody as a, getFetch as b, fetchHTTPResponse as f, getUrl as g, httpRequest as h, jsonHttpRequester as j, resolveHTTPLinkOptions as r };\n", "function isObject(value) {\n    // check that value is object\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\n\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */ function transformResultInner(response, runtime) {\n    if ('error' in response) {\n        const error = runtime.transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: {\n                ...response,\n                error\n            }\n        };\n    }\n    const result = {\n        ...response.result,\n        ...(!response.result.type || response.result.type === 'data') && {\n            type: 'data',\n            data: runtime.transformer.deserialize(response.result.data)\n        }\n    };\n    return {\n        ok: true,\n        result\n    };\n}\nclass TransformResultError extends Error {\n    constructor(){\n        super('Unable to transform response from server');\n    }\n}\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */ function transformResult(response, runtime) {\n    let result;\n    try {\n        // Use the data transformers on the JSON-response\n        result = transformResultInner(response, runtime);\n    } catch (err) {\n        throw new TransformResultError();\n    }\n    // check that output of the transformers is a valid TRPCResponse\n    if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== 'number')) {\n        throw new TransformResultError();\n    }\n    if (result.ok && !isObject(result.result)) {\n        throw new TransformResultError();\n    }\n    return result;\n}\n\nexport { transformResult as t };\n", "import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from './transformResult-7ab522e6.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-fef6cf44.mjs';\nimport { r as resolveHTTPLinkOptions, g as getUrl, j as jsonHttpRequester } from './httpUtils-1efcb902.mjs';\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */ /**\n * A function that should never be called unless we messed something up.\n */ const throwFatalError = ()=>{\n    throw new Error('Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new');\n};\n/**\n * Dataloader that's very inspired by https://github.com/graphql/dataloader\n * Less configuration, no caching, and allows you to cancel requests\n * When cancelling a single fetch the whole batch will be cancelled only when _all_ items are cancelled\n */ function dataLoader(batchLoader) {\n    let pendingItems = null;\n    let dispatchTimer = null;\n    const destroyTimerAndPendingItems = ()=>{\n        clearTimeout(dispatchTimer);\n        dispatchTimer = null;\n        pendingItems = null;\n    };\n    /**\n   * Iterate through the items and split them into groups based on the `batchLoader`'s validate function\n   */ function groupItems(items) {\n        const groupedItems = [\n            []\n        ];\n        let index = 0;\n        while(true){\n            const item = items[index];\n            if (!item) {\n                break;\n            }\n            const lastGroup = groupedItems[groupedItems.length - 1];\n            if (item.aborted) {\n                // Item was aborted before it was dispatched\n                item.reject?.(new Error('Aborted'));\n                index++;\n                continue;\n            }\n            const isValid = batchLoader.validate(lastGroup.concat(item).map((it)=>it.key));\n            if (isValid) {\n                lastGroup.push(item);\n                index++;\n                continue;\n            }\n            if (lastGroup.length === 0) {\n                item.reject?.(new Error('Input is too big for a single dispatch'));\n                index++;\n                continue;\n            }\n            // Create new group, next iteration will try to add the item to that\n            groupedItems.push([]);\n        }\n        return groupedItems;\n    }\n    function dispatch() {\n        const groupedItems = groupItems(pendingItems);\n        destroyTimerAndPendingItems();\n        // Create batches for each group of items\n        for (const items of groupedItems){\n            if (!items.length) {\n                continue;\n            }\n            const batch = {\n                items,\n                cancel: throwFatalError\n            };\n            for (const item of items){\n                item.batch = batch;\n            }\n            const unitResolver = (index, value)=>{\n                const item = batch.items[index];\n                item.resolve?.(value);\n                item.batch = null;\n                item.reject = null;\n                item.resolve = null;\n            };\n            const { promise , cancel  } = batchLoader.fetch(batch.items.map((_item)=>_item.key), unitResolver);\n            batch.cancel = cancel;\n            promise.then((result)=>{\n                for(let i = 0; i < result.length; i++){\n                    const value = result[i];\n                    unitResolver(i, value);\n                }\n                for (const item of batch.items){\n                    item.reject?.(new Error('Missing result'));\n                    item.batch = null;\n                }\n            }).catch((cause)=>{\n                for (const item of batch.items){\n                    item.reject?.(cause);\n                    item.batch = null;\n                }\n            });\n        }\n    }\n    function load(key) {\n        const item = {\n            aborted: false,\n            key,\n            batch: null,\n            resolve: throwFatalError,\n            reject: throwFatalError\n        };\n        const promise = new Promise((resolve, reject)=>{\n            item.reject = reject;\n            item.resolve = resolve;\n            if (!pendingItems) {\n                pendingItems = [];\n            }\n            pendingItems.push(item);\n        });\n        if (!dispatchTimer) {\n            dispatchTimer = setTimeout(dispatch);\n        }\n        const cancel = ()=>{\n            item.aborted = true;\n            if (item.batch?.items.every((item)=>item.aborted)) {\n                // All items in the batch have been cancelled\n                item.batch.cancel();\n                item.batch = null;\n            }\n        };\n        return {\n            promise,\n            cancel\n        };\n    }\n    return {\n        load\n    };\n}\n\n/**\n * @internal\n */ function createHTTPBatchLink(requester) {\n    return function httpBatchLink(opts) {\n        const resolvedOpts = resolveHTTPLinkOptions(opts);\n        const maxURLLength = opts.maxURLLength ?? Infinity;\n        // initialized config\n        return (runtime)=>{\n            const batchLoader = (type)=>{\n                const validate = (batchOps)=>{\n                    if (maxURLLength === Infinity) {\n                        // escape hatch for quick calcs\n                        return true;\n                    }\n                    const path = batchOps.map((op)=>op.path).join(',');\n                    const inputs = batchOps.map((op)=>op.input);\n                    const url = getUrl({\n                        ...resolvedOpts,\n                        runtime,\n                        type,\n                        path,\n                        inputs\n                    });\n                    return url.length <= maxURLLength;\n                };\n                const fetch = requester({\n                    ...resolvedOpts,\n                    runtime,\n                    type,\n                    opts\n                });\n                return {\n                    validate,\n                    fetch\n                };\n            };\n            const query = dataLoader(batchLoader('query'));\n            const mutation = dataLoader(batchLoader('mutation'));\n            const subscription = dataLoader(batchLoader('subscription'));\n            const loaders = {\n                query,\n                subscription,\n                mutation\n            };\n            return ({ op  })=>{\n                return observable((observer)=>{\n                    const loader = loaders[op.type];\n                    const { promise , cancel  } = loader.load(op);\n                    let _res = undefined;\n                    promise.then((res)=>{\n                        _res = res;\n                        const transformed = transformResult(res.json, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error, {\n                                meta: res.meta\n                            }));\n                            return;\n                        }\n                        observer.next({\n                            context: res.meta,\n                            result: transformed.result\n                        });\n                        observer.complete();\n                    }).catch((err)=>{\n                        observer.error(TRPCClientError.from(err, {\n                            meta: _res?.meta\n                        }));\n                    });\n                    return ()=>{\n                        cancel();\n                    };\n                });\n            };\n        };\n    };\n}\n\nconst batchRequester = (requesterOpts)=>{\n    return (batchOps)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { promise , cancel  } = jsonHttpRequester({\n            ...requesterOpts,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        });\n        return {\n            promise: promise.then((res)=>{\n                const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(()=>res.json);\n                const result = resJSON.map((item)=>({\n                        meta: res.meta,\n                        json: item\n                    }));\n                return result;\n            }),\n            cancel\n        };\n    };\n};\nconst httpBatchLink = createHTTPBatchLink(batchRequester);\n\nexport { createHTTPBatchLink as c, httpBatchLink as h };\n", "import { observable } from '@trpc/server/observable';\nimport { t as transformResult } from '../transformResult-7ab522e6.mjs';\nimport { T as TRPCClientError } from '../TRPCClientError-fef6cf44.mjs';\nimport { r as resolveHTTPLinkOptions, j as jsonHttpRequester } from '../httpUtils-1efcb902.mjs';\n\nfunction httpLinkFactory(factoryOpts) {\n    return (opts)=>{\n        const resolvedOpts = resolveHTTPLinkOptions(opts);\n        return (runtime)=>({ op  })=>observable((observer)=>{\n                    const { path , input , type  } = op;\n                    const { promise , cancel  } = factoryOpts.requester({\n                        ...resolvedOpts,\n                        runtime,\n                        type,\n                        path,\n                        input,\n                        headers () {\n                            if (!opts.headers) {\n                                return {};\n                            }\n                            if (typeof opts.headers === 'function') {\n                                return opts.headers({\n                                    op\n                                });\n                            }\n                            return opts.headers;\n                        }\n                    });\n                    let meta = undefined;\n                    promise.then((res)=>{\n                        meta = res.meta;\n                        const transformed = transformResult(res.json, runtime);\n                        if (!transformed.ok) {\n                            observer.error(TRPCClientError.from(transformed.error, {\n                                meta\n                            }));\n                            return;\n                        }\n                        observer.next({\n                            context: res.meta,\n                            result: transformed.result\n                        });\n                        observer.complete();\n                    }).catch((cause)=>{\n                        observer.error(TRPCClientError.from(cause, {\n                            meta\n                        }));\n                    });\n                    return ()=>{\n                        cancel();\n                    };\n                });\n    };\n}\nconst httpLink = httpLinkFactory({\n    requester: jsonHttpRequester\n});\n\nexport { httpLink, httpLinkFactory };\n", "import { share, observableToPromise } from '@trpc/server/observable';\nimport { c as createChain } from './splitLink-4c75f7be.mjs';\nexport { s as splitLink } from './splitLink-4c75f7be.mjs';\nimport { T as TRPCClientError } from './TRPCClientError-fef6cf44.mjs';\nexport { T as TRPCClientError } from './TRPCClientError-fef6cf44.mjs';\nimport { createFlatProxy, createRecursiveProxy } from '@trpc/server/shared';\nimport { f as fetchHTTPResponse, g as getUrl, a as getBody$1, h as httpRequest } from './httpUtils-1efcb902.mjs';\nexport { b as getFetch } from './httpUtils-1efcb902.mjs';\nimport { c as createHTTPBatchLink } from './httpBatchLink-fbd7b43c.mjs';\nexport { h as httpBatchLink } from './httpBatchLink-fbd7b43c.mjs';\nimport { httpLinkFactory } from './links/httpLink.mjs';\nexport { httpLink, httpLinkFactory } from './links/httpLink.mjs';\nexport { loggerLink } from './links/loggerLink.mjs';\nexport { createWSClient, wsLink } from './links/wsLink.mjs';\nimport './transformResult-7ab522e6.mjs';\n\nclass TRPCUntypedClient {\n    $request({ type , input , path , context ={}  }) {\n        const chain$ = createChain({\n            links: this.links,\n            op: {\n                id: ++this.requestId,\n                type,\n                path,\n                input,\n                context\n            }\n        });\n        return chain$.pipe(share());\n    }\n    requestAsPromise(opts) {\n        const req$ = this.$request(opts);\n        const { promise , abort  } = observableToPromise(req$);\n        const abortablePromise = new Promise((resolve, reject)=>{\n            opts.signal?.addEventListener('abort', abort);\n            promise.then((envelope)=>{\n                resolve(envelope.result.data);\n            }).catch((err)=>{\n                reject(TRPCClientError.from(err));\n            });\n        });\n        return abortablePromise;\n    }\n    query(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'query',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    mutation(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'mutation',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    subscription(path, input, opts) {\n        const observable$ = this.$request({\n            type: 'subscription',\n            path,\n            input,\n            context: opts?.context\n        });\n        return observable$.subscribe({\n            next (envelope) {\n                if (envelope.result.type === 'started') {\n                    opts.onStarted?.();\n                } else if (envelope.result.type === 'stopped') {\n                    opts.onStopped?.();\n                } else {\n                    opts.onData?.(envelope.result.data);\n                }\n            },\n            error (err) {\n                opts.onError?.(err);\n            },\n            complete () {\n                opts.onComplete?.();\n            }\n        });\n    }\n    constructor(opts){\n        this.requestId = 0;\n        const combinedTransformer = (()=>{\n            const transformer = opts.transformer;\n            if (!transformer) {\n                return {\n                    input: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    },\n                    output: {\n                        serialize: (data)=>data,\n                        deserialize: (data)=>data\n                    }\n                };\n            }\n            if ('input' in transformer) {\n                return opts.transformer;\n            }\n            return {\n                input: transformer,\n                output: transformer\n            };\n        })();\n        this.runtime = {\n            transformer: {\n                serialize: (data)=>combinedTransformer.input.serialize(data),\n                deserialize: (data)=>combinedTransformer.output.deserialize(data)\n            },\n            combinedTransformer\n        };\n        // Initialize the links\n        this.links = opts.links.map((link)=>link(this.runtime));\n    }\n}\n\nfunction createTRPCUntypedClient(opts) {\n    return new TRPCUntypedClient(opts);\n}\n\n/**\n * @deprecated use `createTRPCProxyClient` instead\n */ function createTRPCClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    return client;\n}\n\nconst clientCallTypeMap = {\n    query: 'query',\n    mutate: 'mutation',\n    subscribe: 'subscription'\n};\n/** @internal */ const clientCallTypeToProcedureType = (clientCallType)=>{\n    return clientCallTypeMap[clientCallType];\n};\n/**\n * @deprecated use `createTRPCProxyClient` instead\n * @internal\n */ function createTRPCClientProxy(client) {\n    return createFlatProxy((key)=>{\n        if (client.hasOwnProperty(key)) {\n            return client[key];\n        }\n        if (key === '__untypedClient') {\n            return client;\n        }\n        return createRecursiveProxy(({ path , args  })=>{\n            const pathCopy = [\n                key,\n                ...path\n            ];\n            const procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n            const fullPath = pathCopy.join('.');\n            return client[procedureType](fullPath, ...args);\n        });\n    });\n}\nfunction createTRPCProxyClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    const proxy = createTRPCClientProxy(client);\n    return proxy;\n}\n/**\n * Get an untyped client from a proxy client\n * @internal\n */ function getUntypedClient(client) {\n    return client.__untypedClient;\n}\n\nfunction getTextDecoder(customTextDecoder) {\n    if (customTextDecoder) {\n        return customTextDecoder;\n    }\n    if (typeof window !== 'undefined' && window.TextDecoder) {\n        return new window.TextDecoder();\n    }\n    if (typeof globalThis !== 'undefined' && globalThis.TextDecoder) {\n        return new globalThis.TextDecoder();\n    }\n    throw new Error('No TextDecoder implementation found');\n}\n\n// Stream parsing adapted from https://www.loginradius.com/blog/engineering/guest-post/http-streaming-with-nodejs-and-fetch-api/\n/**\n * @internal\n * @description Take a stream of bytes and call `onLine` with\n * a JSON object for each line in the stream. Expected stream\n * format is:\n * ```json\n * {\"1\": {...}\n * ,\"0\": {...}\n * }\n * ```\n */ async function parseJSONStream(opts) {\n    const parse = opts.parse ?? JSON.parse;\n    const onLine = (line)=>{\n        if (opts.signal?.aborted) return;\n        if (!line || line === '}') {\n            return;\n        }\n        /**\n     * At this point, `line` can be one of two things:\n     * - The first line of the stream `{\"2\":{...}`\n     * - A line in the middle of the stream `,\"2\":{...}`\n     */ const indexOfColon = line.indexOf(':');\n        const indexAsStr = line.substring(2, indexOfColon - 1);\n        const text = line.substring(indexOfColon + 1);\n        opts.onSingle(Number(indexAsStr), parse(text));\n    };\n    await readLines(opts.readableStream, onLine, opts.textDecoder);\n}\n/**\n * Handle transforming a stream of bytes into lines of text.\n * To avoid using AsyncIterators / AsyncGenerators,\n * we use a callback for each line.\n *\n * @param readableStream can be a NodeJS stream or a WebAPI stream\n * @param onLine will be called for every line ('\\n' delimited) in the stream\n */ async function readLines(readableStream, onLine, textDecoder) {\n    let partOfLine = '';\n    const onChunk = (chunk)=>{\n        const chunkText = textDecoder.decode(chunk);\n        const chunkLines = chunkText.split('\\n');\n        if (chunkLines.length === 1) {\n            partOfLine += chunkLines[0];\n        } else if (chunkLines.length > 1) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n            onLine(partOfLine + chunkLines[0]);\n            for(let i = 1; i < chunkLines.length - 1; i++){\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length checked on line above\n                onLine(chunkLines[i]);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion -- length doesn't change, so is necessarily > 1\n            partOfLine = chunkLines[chunkLines.length - 1];\n        }\n    };\n    // we handle 2 different types of streams, this if where we figure out which one we have\n    if ('getReader' in readableStream) {\n        await readStandardChunks(readableStream, onChunk);\n    } else {\n        await readNodeChunks(readableStream, onChunk);\n    }\n    onLine(partOfLine);\n}\n/**\n * Handle NodeJS stream\n */ function readNodeChunks(stream, onChunk) {\n    return new Promise((resolve)=>{\n        stream.on('data', onChunk);\n        stream.on('end', resolve);\n    });\n}\n/**\n * Handle WebAPI stream\n */ async function readStandardChunks(stream, onChunk) {\n    const reader = stream.getReader();\n    let readResult = await reader.read();\n    while(!readResult.done){\n        onChunk(readResult.value);\n        readResult = await reader.read();\n    }\n}\nconst streamingJsonHttpRequester = (opts, onSingle)=>{\n    const ac = opts.AbortController ? new opts.AbortController() : null;\n    const responsePromise = fetchHTTPResponse({\n        ...opts,\n        contentTypeHeader: 'application/json',\n        batchModeHeader: 'stream',\n        getUrl,\n        getBody: getBody$1\n    }, ac);\n    const cancel = ()=>ac?.abort();\n    const promise = responsePromise.then(async (res)=>{\n        if (!res.body) throw new Error('Received response without body');\n        const meta = {\n            response: res\n        };\n        return parseJSONStream({\n            readableStream: res.body,\n            onSingle,\n            parse: (string)=>({\n                    json: JSON.parse(string),\n                    meta\n                }),\n            signal: ac?.signal,\n            textDecoder: opts.textDecoder\n        });\n    });\n    return {\n        cancel,\n        promise\n    };\n};\n\nconst streamRequester = (requesterOpts)=>{\n    const textDecoder = getTextDecoder(requesterOpts.opts.textDecoder);\n    return (batchOps, unitResolver)=>{\n        const path = batchOps.map((op)=>op.path).join(',');\n        const inputs = batchOps.map((op)=>op.input);\n        const { cancel , promise  } = streamingJsonHttpRequester({\n            ...requesterOpts,\n            textDecoder,\n            path,\n            inputs,\n            headers () {\n                if (!requesterOpts.opts.headers) {\n                    return {};\n                }\n                if (typeof requesterOpts.opts.headers === 'function') {\n                    return requesterOpts.opts.headers({\n                        opList: batchOps\n                    });\n                }\n                return requesterOpts.opts.headers;\n            }\n        }, (index, res)=>{\n            unitResolver(index, res);\n        });\n        return {\n            /**\n       * return an empty array because the batchLoader expects an array of results\n       * but we've already called the `unitResolver` for each of them, there's\n       * nothing left to do here.\n       */ promise: promise.then(()=>[]),\n            cancel\n        };\n    };\n};\nconst unstable_httpBatchStreamLink = createHTTPBatchLink(streamRequester);\n\nconst getBody = (opts)=>{\n    if (!('input' in opts)) {\n        return undefined;\n    }\n    if (!(opts.input instanceof FormData)) {\n        throw new Error('Input is not FormData');\n    }\n    return opts.input;\n};\nconst formDataRequester = (opts)=>{\n    if (opts.type !== 'mutation') {\n        // TODO(?) handle formdata queries\n        throw new Error('We only handle mutations with formdata');\n    }\n    return httpRequest({\n        ...opts,\n        getUrl () {\n            return `${opts.url}/${opts.path}`;\n        },\n        getBody\n    });\n};\nconst experimental_formDataLink = httpLinkFactory({\n    requester: formDataRequester\n});\n\nexport { clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, createTRPCProxyClient, createTRPCUntypedClient, experimental_formDataLink, getUntypedClient, unstable_httpBatchStreamLink };\n", "import { z } from \"zod\";\nimport { QueryAdapter } from \"./common\";\nimport { isHex } from \"viem\";\nimport { initTRPC } from \"@trpc/server\";\nimport superjson from \"superjson\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function createAppRouter() {\n  const t = initTRPC.context<{ queryAdapter: QueryAdapter }>().create({\n    transformer: superjson,\n  });\n\n  return t.router({\n    findAll: t.procedure\n      .input(\n        z.object({\n          chainId: z.number(),\n          address: z.string().refine(isHex).optional(),\n          filters: z\n            .array(\n              z.object({\n                tableId: z.string().refine(isHex),\n                key0: z.string().refine(isHex).optional(),\n                key1: z.string().refine(isHex).optional(),\n              })\n            )\n            .optional(),\n        })\n      )\n      .query(async (opts): ReturnType<QueryAdapter[\"findAll\"]> => {\n        const { queryAdapter } = opts.ctx;\n        const { chainId, address, filters } = opts.input;\n        return queryAdapter.findAll({ chainId, address, filters });\n      }),\n  });\n}\n\nexport type AppRouter = ReturnType<typeof createAppRouter>;\n", "import { createTRPCProxyClient, httpBatchLink, CreateTRPCProxyClient } from \"@trpc/client\";\nimport superjson from \"superjson\";\nimport type { AppRouter } from \"./createAppRouter\";\n\ntype CreateIndexerClientOptions = {\n  /**\n   * tRPC endpoint URL like `https://indexer.dev.linfra.xyz/trpc`.\n   */\n  url: string;\n};\n\n/**\n * Creates a tRPC client to talk to a MUD indexer.\n *\n * @param {CreateIndexerClientOptions} options See `CreateIndexerClientOptions`.\n * @returns {CreateTRPCProxyClient<AppRouter>} A typed tRPC client.\n */\nexport function createIndexerClient({ url }: CreateIndexerClientOptions): CreateTRPCProxyClient<AppRouter> {\n  return createTRPCProxyClient<AppRouter>({\n    transformer: superjson,\n    links: [httpBatchLink({ url })],\n  });\n}\n", "export const helloStoreEvent = \"event HelloStore(bytes32 indexed storeVersion)\";\n\nexport const storeSetRecordEvent =\n  \"event Store_SetRecord(bytes32 indexed tableId, bytes32[] keyTuple, bytes staticData, bytes32 encodedLengths, bytes dynamicData)\";\n\nexport const storeSpliceStaticDataEvent =\n  \"event Store_SpliceStaticData(bytes32 indexed tableId, bytes32[] keyTuple, uint48 start, bytes data)\";\n\nexport const storeSpliceDynamicDataEvent =\n  \"event Store_SpliceDynamicData(bytes32 indexed tableId, bytes32[] keyTuple, uint48 start, uint40 deleteCount, bytes32 encodedLengths, bytes data)\";\n\nexport const storeDeleteRecordEvent = \"event Store_DeleteRecord(bytes32 indexed tableId, bytes32[] keyTuple)\";\n\n// Store protocol events\nexport const storeEvents = [\n  storeSetRecordEvent,\n  storeSpliceStaticDataEvent,\n  storeSpliceDynamicDataEvent,\n  storeDeleteRecordEvent,\n] as const;\n", "import { parseAbi, AbiEvent } from \"abitype\";\nimport { storeEvents } from \"./storeEvents\";\n\nexport const storeEventsAbi = parseAbi(storeEvents) satisfies readonly AbiEvent[];\n\nexport type StoreEventsAbi = typeof storeEventsAbi;\nexport type StoreEventsAbiItem = (typeof storeEventsAbi)[number];\n", "import { mudConfig } from \"./ts/register\";\n\nexport default mudConfig({\n  storeImportPath: \"../../\",\n  namespace: \"store\" as const,\n  userTypes: {\n    ResourceId: { filePath: \"./src/ResourceId.sol\", internalType: \"bytes32\" },\n    FieldLayout: { filePath: \"./src/FieldLayout.sol\", internalType: \"bytes32\" },\n    Schema: { filePath: \"./src/Schema.sol\", internalType: \"bytes32\" },\n  },\n  tables: {\n    StoreHooks: {\n      keySchema: {\n        tableId: \"ResourceId\",\n      },\n      valueSchema: {\n        hooks: \"bytes21[]\",\n      },\n    },\n    Tables: {\n      keySchema: {\n        tableId: \"ResourceId\",\n      },\n      valueSchema: {\n        fieldLayout: \"FieldLayout\",\n        keySchema: \"Schema\",\n        valueSchema: \"Schema\",\n        abiEncodedKeyNames: \"bytes\",\n        abiEncodedFieldNames: \"bytes\",\n      },\n    },\n    ResourceIds: {\n      keySchema: {\n        resourceId: \"ResourceId\",\n      },\n      valueSchema: {\n        exists: \"bool\",\n      },\n    },\n    // The Hooks table is a generic table used by the `filterFromList` util in `Hook.sol`\n    Hooks: {\n      keySchema: {\n        resourceId: \"ResourceId\",\n      },\n      valueSchema: {\n        hooks: \"bytes21[]\",\n      },\n      tableIdArgument: true,\n    },\n  },\n});\n", "import { mudConfig } from \"./ts/register\";\n\nexport default mudConfig({\n  worldImportPath: \"../../\",\n  worldgenDirectory: \"interfaces\",\n  worldInterfaceName: \"IBaseWorld\",\n  namespace: \"world\" as const, // NOTE: this namespace is only used for tables, the core system is deployed in the root namespace.\n  userTypes: {\n    ResourceId: { filePath: \"@latticexyz/store/src/ResourceId.sol\", internalType: \"bytes32\" },\n  },\n  tables: {\n    NamespaceOwner: {\n      keySchema: {\n        namespaceId: \"ResourceId\",\n      },\n      valueSchema: {\n        owner: \"address\",\n      },\n    },\n    ResourceAccess: {\n      keySchema: {\n        resourceId: \"ResourceId\",\n        caller: \"address\",\n      },\n      valueSchema: {\n        access: \"bool\",\n      },\n    },\n    InstalledModules: {\n      keySchema: {\n        moduleName: \"bytes16\",\n        argumentsHash: \"bytes32\", // Hash of the params passed to the `install` function\n      },\n      valueSchema: {\n        moduleAddress: \"address\",\n      },\n    },\n    UserDelegationControl: {\n      keySchema: {\n        delegator: \"address\",\n        delegatee: \"address\",\n      },\n      valueSchema: {\n        delegationControlId: \"ResourceId\",\n      },\n    },\n    NamespaceDelegationControl: {\n      keySchema: {\n        namespaceId: \"ResourceId\",\n      },\n      valueSchema: {\n        delegationControlId: \"ResourceId\",\n      },\n    },\n    Balances: {\n      keySchema: {\n        namespaceId: \"ResourceId\",\n      },\n      valueSchema: {\n        balance: \"uint256\",\n      },\n    },\n    Systems: {\n      keySchema: {\n        systemId: \"ResourceId\",\n      },\n      valueSchema: {\n        system: \"address\",\n        publicAccess: \"bool\",\n      },\n      dataStruct: false,\n    },\n    SystemRegistry: {\n      keySchema: {\n        system: \"address\",\n      },\n      valueSchema: {\n        systemId: \"ResourceId\",\n      },\n    },\n    SystemHooks: {\n      keySchema: {\n        systemId: \"ResourceId\",\n      },\n      valueSchema: \"bytes21[]\",\n    },\n    FunctionSelectors: {\n      keySchema: {\n        functionSelector: \"bytes4\",\n      },\n      valueSchema: {\n        systemId: \"ResourceId\",\n        systemFunctionSelector: \"bytes4\",\n      },\n      dataStruct: false,\n    },\n    FunctionSignatures: {\n      keySchema: {\n        functionSelector: \"bytes4\",\n      },\n      valueSchema: {\n        functionSignature: \"string\",\n      },\n      offchainOnly: true,\n    },\n  },\n  excludeSystems: [\n    // Worldgen currently does not support systems inheriting logic\n    // from other contracts, so all parts of CoreSystem are named\n    // System too to be included in the IBaseWorld interface.\n    // However, IStoreRegistrationSystem overlaps with IStore if\n    // included in IBaseWorld, so it needs to be excluded from worldgen.\n    // TODO: add support for inheritance to worldgen\n    // (see: https://github.com/latticexyz/mud/issues/631)\n    \"StoreRegistrationSystem\",\n  ],\n});\n", "import { EMPTY, OperatorFunction, concatMap, from, pipe, tap } from \"rxjs\";\nimport { FetchLogsResult, fetchLogs } from \"./fetchLogs\";\nimport { AbiEvent } from \"abitype\";\nimport { Address, BlockNumber, PublicClient } from \"viem\";\nimport { debug } from \"./debug\";\n\nexport type BlockRangeToLogsOptions<TAbiEvents extends readonly AbiEvent[]> = {\n  /**\n   * [viem `PublicClient`][0] used for fetching logs from the RPC.\n   *\n   * [0]: https://viem.sh/docs/clients/public.html\n   */\n  publicClient: PublicClient;\n  /**\n   * Optional contract address(es) to fetch logs for.\n   */\n  address?: Address | Address[];\n  /**\n   * Events to fetch logs for.\n   */\n  events: TAbiEvents;\n  /**\n   * Optional maximum block range, if your RPC limits the amount of blocks fetched at a time.\n   */\n  maxBlockRange?: bigint;\n};\n\nexport type BlockRangeToLogsResult<TAbiEvents extends readonly AbiEvent[]> = OperatorFunction<\n  { startBlock: BlockNumber; endBlock: BlockNumber },\n  FetchLogsResult<TAbiEvents>\n>;\n\n/**\n * Takes in an observable of `Observable<{ startBlock: bigint, endBlock: bigint }>`\n * and uses a viem `publicClient` to get logs for the contract `address` and\n * matching `events` and emits the logs as they are fetched.\n *\n * @param {BlockRangeToLogsOptions<AbiEvent[]>} options See `BlockRangeToLogsOptions`.\n * @returns {BlockRangeToLogsResult<AbiEvent[]>} An operator function that transforms a stream of block ranges into a stream of fetched logs.\n */\nexport function blockRangeToLogs<TAbiEvents extends readonly AbiEvent[]>({\n  publicClient,\n  address,\n  events,\n  maxBlockRange,\n}: BlockRangeToLogsOptions<TAbiEvents>): BlockRangeToLogsResult<TAbiEvents> {\n  let fromBlock: bigint;\n  let toBlock: bigint;\n\n  return pipe(\n    tap(({ endBlock, startBlock }) => {\n      fromBlock ??= startBlock;\n      toBlock = endBlock;\n    }),\n    // concatMap only processes the next emission once the inner observable completes,\n    // so it always uses the latest `toBlock` value.\n    concatMap(() => {\n      if (fromBlock > toBlock) return EMPTY;\n      debug(\"fetching logs for block range\", { fromBlock, toBlock });\n      return from(\n        fetchLogs({\n          publicClient,\n          address,\n          events,\n          fromBlock,\n          toBlock,\n          maxBlockRange,\n        })\n      ).pipe(\n        tap(({ toBlock }) => {\n          fromBlock = toBlock + 1n;\n        })\n      );\n    })\n  );\n}\n", "import { AbiEvent } from \"abitype\";\nimport { Address, PublicClient, BlockNumber, GetLogsReturnType } from \"viem\";\nimport { bigIntMin, wait } from \"@latticexyz/common/utils\";\nimport { debug } from \"./debug\";\n\nexport type FetchLogsOptions<TAbiEvents extends readonly AbiEvent[]> = {\n  /**\n   * [viem `PublicClient`][0] used for fetching logs from the RPC.\n   *\n   * [0]: https://viem.sh/docs/clients/public.html\n   */\n  publicClient: PublicClient;\n  /**\n   * Optional contract address(es) to fetch logs for.\n   */\n  address?: Address | Address[];\n  /**\n   * Events to fetch logs for.\n   */\n  events: TAbiEvents;\n  /**\n   * The block number to start fetching logs from (inclusive).\n   */\n  fromBlock: BlockNumber;\n  /**\n   * The block number to stop fetching logs at (inclusive).\n   */\n  toBlock: BlockNumber;\n  /**\n   * Optional maximum block range, if your RPC limits the amount of blocks fetched at a time. Defaults to 1000n.\n   */\n  maxBlockRange?: bigint;\n  /**\n   * Optional maximum amount of retries if the RPC returns a rate limit error. Defaults to 3.\n   */\n  maxRetryCount?: number;\n};\n\nexport type FetchLogsResult<TAbiEvents extends readonly AbiEvent[]> = {\n  fromBlock: BlockNumber;\n  toBlock: BlockNumber;\n  logs: GetLogsReturnType<undefined, TAbiEvents, true, BlockNumber, BlockNumber>;\n};\n\n/**\n * An asynchronous generator function that fetches logs from the blockchain in a range of blocks.\n *\n * @remarks\n * The function will fetch logs according to the given options.\n * It will iteratively move forward in the block range, yielding fetched logs as they become available.\n * If the function encounters rate limits, it will retry until `maxRetryCount` is reached.\n * If the function encounters a block range that is too large, it will half the block range and retry, until the block range can't be halved anymore.\n *\n * @param {FetchLogsOptions<AbiEvent[]>} options See `FetchLogsOptions`.\n *\n * @yields The result of the fetched logs for each block range in the given range.\n *\n * @throws Will throw an error if the block range can't be reduced any further.\n */\nexport async function* fetchLogs<TAbiEvents extends readonly AbiEvent[]>({\n  maxBlockRange = 1000n,\n  maxRetryCount = 3,\n  publicClient,\n  ...getLogsOpts\n}: FetchLogsOptions<TAbiEvents>): AsyncGenerator<FetchLogsResult<TAbiEvents>> {\n  let fromBlock = getLogsOpts.fromBlock;\n  let blockRange = bigIntMin(maxBlockRange, getLogsOpts.toBlock - fromBlock);\n  let retryCount = 0;\n\n  while (fromBlock <= getLogsOpts.toBlock) {\n    try {\n      const toBlock = fromBlock + blockRange;\n      debug(\"getting logs\", { fromBlock, toBlock });\n      const logs = await publicClient.getLogs({ ...getLogsOpts, fromBlock, toBlock, strict: true });\n      yield { fromBlock, toBlock, logs };\n      fromBlock = toBlock + 1n;\n      blockRange = bigIntMin(maxBlockRange, getLogsOpts.toBlock - fromBlock);\n    } catch (error: unknown) {\n      debug(\"error getting logs:\", String(error));\n      if (!(error instanceof Error)) throw error;\n\n      // TODO: figure out actual rate limit message for RPCs\n      if (error.message.includes(\"rate limit exceeded\") && retryCount < maxRetryCount) {\n        const seconds = 2 * retryCount;\n        debug(`too many requests, retrying in ${seconds}s`, error);\n        await wait(1000 * seconds);\n        retryCount += 1;\n        continue;\n      }\n\n      // TODO: figure out actual block range exceeded message for RPCs\n      if (error.message.includes(\"block range exceeded\")) {\n        blockRange /= 2n;\n        if (blockRange <= 0n) {\n          throw new Error(\"can't reduce block range any further\");\n        }\n        debug(\"block range exceeded, trying a smaller block range\", error);\n        // TODO: adjust maxBlockRange down if we consistently hit this for a given block range size\n        continue;\n      }\n\n      throw error;\n    }\n  }\n}\n", "import createDebug from \"debug\";\n\nexport const debug = createDebug(\"mud:block-events-stream\");\n", "import { Observable } from \"rxjs\";\nimport type { Block, BlockTag, PublicClient } from \"viem\";\n\nexport type CreateBlockStreamOptions<TBlockTag extends BlockTag> = {\n  publicClient: PublicClient;\n  blockTag: TBlockTag;\n};\n\nexport type CreateBlockStreamResult<TBlockTag extends BlockTag> = Observable<Block<bigint, false, TBlockTag>>;\n\nexport function createBlockStream<TBlockTag extends BlockTag>({\n  publicClient,\n  blockTag,\n}: CreateBlockStreamOptions<TBlockTag>): CreateBlockStreamResult<TBlockTag> {\n  return new Observable(function subscribe(subscriber) {\n    return publicClient.watchBlocks({\n      blockTag,\n      emitOnBegin: true,\n      onBlock: (block) => subscriber.next(block),\n      onError: (error) => subscriber.error(error),\n    });\n  });\n}\n", "import { BlockNumber } from \"viem\";\nimport { bigIntSort, isDefined } from \"@latticexyz/common/utils\";\n\ntype PartialLog = { blockNumber: bigint; logIndex: number };\n\nexport type GroupLogsByBlockNumberResult<TLog extends PartialLog> = {\n  blockNumber: TLog[\"blockNumber\"];\n  logs: TLog[];\n}[];\n\n/**\n * Groups logs by their block number.\n *\n * @remarks\n * This function takes an array of logs and returns a new array where each item corresponds to a distinct block number.\n * Each item in the output array includes the block number, the block hash, and an array of all logs for that block.\n * Pending logs are filtered out before processing, as they don't have block numbers.\n *\n * @param logs The logs to group by block number.\n * @param toBlock If specified, always include this block number at the end, even if there are no logs.\n *\n * @returns An array of objects where each object represents a distinct block and includes the block number,\n * the block hash, and an array of logs for that block.\n */\nexport function groupLogsByBlockNumber<TLog extends PartialLog>(\n  logs: readonly TLog[],\n  toBlock?: BlockNumber\n): GroupLogsByBlockNumberResult<TLog> {\n  const blockNumbers = Array.from(new Set(logs.map((log) => log.blockNumber)));\n  blockNumbers.sort(bigIntSort);\n\n  const groupedBlocks = blockNumbers\n    .map((blockNumber) => {\n      const blockLogs = logs.filter((log) => log.blockNumber === blockNumber);\n      if (!blockLogs.length) return;\n      blockLogs.sort((a, b) => (a.logIndex < b.logIndex ? -1 : a.logIndex > b.logIndex ? 1 : 0));\n\n      if (!blockLogs.length) return;\n\n      return {\n        blockNumber,\n        logs: blockLogs,\n      };\n    })\n    .filter(isDefined);\n\n  const lastBlockNumber = blockNumbers.length > 0 ? blockNumbers[blockNumbers.length - 1] : null;\n\n  if (toBlock != null && (lastBlockNumber == null || toBlock > lastBlockNumber)) {\n    groupedBlocks.push({\n      blockNumber: toBlock,\n      logs: [],\n    });\n  }\n\n  return groupedBlocks;\n}\n", "import { Address, Block, Hex, Log, PublicClient } from \"viem\";\nimport { StoreConfig, StoreEventsAbiItem, StoreEventsAbi, resolveConfig } from \"@latticexyz/store\";\nimport { Observable } from \"rxjs\";\nimport { UnionPick } from \"@latticexyz/common/type-utils\";\nimport { KeySchema, TableRecord, ValueSchema } from \"@latticexyz/protocol-parser\";\nimport storeConfig from \"@latticexyz/store/mud.config\";\nimport worldConfig from \"@latticexyz/world/mud.config\";\nimport { flattenSchema } from \"./flattenSchema\";\n\n/** @internal Temporary workaround until we redo our config parsing and can pull this directly from the config (https://github.com/latticexyz/mud/issues/1668) */\nexport const storeTables = resolveConfig(storeConfig).tables;\n/** @internal Temporary workaround until we redo our config parsing and can pull this directly from the config (https://github.com/latticexyz/mud/issues/1668) */\nexport const worldTables = resolveConfig(worldConfig).tables;\n\nexport type ChainId = number;\nexport type WorldId = `${ChainId}:${Address}`;\n\nexport type TableNamespace = string;\nexport type TableName = string;\n\nexport type Table = {\n  address: Address;\n  tableId: Hex;\n  namespace: TableNamespace;\n  name: TableName;\n  keySchema: KeySchema;\n  valueSchema: ValueSchema;\n};\n\nexport type TableWithRecords = Table & { records: TableRecord[] };\n\nexport type StoreEventsLog = Log<bigint, number, false, StoreEventsAbiItem, true, StoreEventsAbi>;\nexport type BlockLogs = { blockNumber: StoreEventsLog[\"blockNumber\"]; logs: StoreEventsLog[] };\n\n// only two keys for now, to reduce complexity of creating indexes on SQL tables\n// TODO: make tableId optional to enable filtering just on keys (any table)\n//       this is blocked on reworking data storage so we can more easily query data across tables\nexport type SyncFilter = {\n  /**\n   * Filter by the `bytes32` table ID.\n   */\n  tableId: Hex;\n  /**\n   * Optionally filter by the `bytes32` value of the key in the first position (index zero of the record's key tuple).\n   */\n  key0?: Hex;\n  /**\n   * Optionally filter by the `bytes32` value of the key in the second position (index one of the record's key tuple).\n   */\n  key1?: Hex;\n};\n\nexport type SyncOptions<TConfig extends StoreConfig = StoreConfig> = {\n  /**\n   * MUD config\n   */\n  config?: TConfig;\n  /**\n   * [viem `PublicClient`][0] used for fetching logs from the RPC.\n   *\n   * [0]: https://viem.sh/docs/clients/public.html\n   */\n  publicClient: PublicClient;\n  /**\n   * MUD Store/World contract address\n   */\n  address?: Address;\n  /**\n   * Optional filters for indexer and RPC state. Useful to narrow down the data received by the client for large worlds.\n   */\n  filters?: SyncFilter[];\n  /**\n   * @deprecated Use `filters` option instead.\n   * */\n  tableIds?: Hex[];\n  /**\n   * Optional block number to start indexing from. Useful for resuming the indexer from a particular point in time or starting after a particular contract deployment.\n   */\n  startBlock?: bigint;\n  /**\n   * Optional maximum block range, if your RPC limits the amount of blocks fetched at a time.\n   */\n  maxBlockRange?: bigint;\n  /**\n   * Optional MUD tRPC indexer URL to fetch initial state from.\n   */\n  indexerUrl?: string;\n  /**\n   * Optional initial state to hydrate from. Useful if you're hydrating from your own indexer or cache.\n   */\n  initialState?: {\n    blockNumber: bigint | null;\n    tables: TableWithRecords[];\n  };\n};\n\nexport type SyncResult = {\n  latestBlock$: Observable<Block>;\n  latestBlockNumber$: Observable<bigint>;\n  blockLogs$: Observable<BlockLogs>;\n  storedBlockLogs$: Observable<StorageAdapterBlock>;\n  waitForTransaction: (tx: Hex) => Promise<void>;\n};\n\n// TODO: add optional, original log to this?\nexport type StorageAdapterLog = Partial<StoreEventsLog> & UnionPick<StoreEventsLog, \"address\" | \"eventName\" | \"args\">;\nexport type StorageAdapterBlock = { blockNumber: BlockLogs[\"blockNumber\"]; logs: StorageAdapterLog[] };\nexport type StorageAdapter = (block: StorageAdapterBlock) => Promise<void>;\n\nexport const schemasTableId = storeTables.Tables.tableId;\nexport const schemasTable = {\n  ...storeTables.Tables,\n  // TODO: remove once we've got everything using the new Table shape\n  keySchema: flattenSchema(storeTables.Tables.keySchema),\n  valueSchema: flattenSchema(storeTables.Tables.valueSchema),\n};\n", "import { mapObject } from \"@latticexyz/common/utils\";\nimport { ValueSchema } from \"@latticexyz/store\";\n\nexport function flattenSchema<schema extends ValueSchema>(\n  schema: schema\n): { readonly [k in keyof schema]: schema[k][\"type\"] } {\n  return mapObject(schema, (value) => value.type);\n}\n", "export enum SyncStep {\n  INITIALIZE = \"initialize\",\n  SNAPSHOT = \"snapshot\",\n  RPC = \"rpc\",\n  LIVE = \"live\",\n}\n", "import { resourceToHex } from \"@latticexyz/common\";\nimport storeConfig from \"@latticexyz/store/mud.config\";\nimport worldConfig from \"@latticexyz/world/mud.config\";\n\n// TODO: refactor config to include table IDs (https://github.com/latticexyz/mud/pull/1561)\n\nexport const storeTableIds = Object.keys(storeConfig.tables).map((name) =>\n  resourceToHex({\n    type: storeConfig.tables[name as keyof typeof storeConfig.tables].offchainOnly ? \"offchainTable\" : \"table\",\n    namespace: storeConfig.namespace,\n    name,\n  })\n);\n\nconst worldTableIds = Object.keys(worldConfig.tables).map((name) =>\n  resourceToHex({\n    type: worldConfig.tables[name as keyof typeof worldConfig.tables].offchainOnly ? \"offchainTable\" : \"table\",\n    namespace: worldConfig.namespace,\n    name,\n  })\n);\n\nexport const internalTableIds = [...storeTableIds, ...worldTableIds];\n", "import { StoreConfig, storeEventsAbi } from \"@latticexyz/store\";\nimport { Hex, TransactionReceiptNotFoundError } from \"viem\";\nimport {\n  StorageAdapter,\n  StorageAdapterBlock,\n  StorageAdapterLog,\n  SyncFilter,\n  SyncOptions,\n  SyncResult,\n  TableWithRecords,\n} from \"./common\";\nimport { createBlockStream, blockRangeToLogs, groupLogsByBlockNumber } from \"@latticexyz/block-logs-stream\";\nimport {\n  filter,\n  map,\n  tap,\n  mergeMap,\n  from,\n  concat,\n  concatMap,\n  share,\n  firstValueFrom,\n  defer,\n  of,\n  catchError,\n  shareReplay,\n  combineLatest,\n  scan,\n  identity,\n} from \"rxjs\";\nimport { debug as parentDebug } from \"./debug\";\nimport { createIndexerClient } from \"./trpc-indexer\";\nimport { SyncStep } from \"./SyncStep\";\nimport { chunk, isDefined } from \"@latticexyz/common/utils\";\nimport { encodeKey, encodeValueArgs } from \"@latticexyz/protocol-parser\";\nimport { internalTableIds } from \"./internalTableIds\";\n\nconst debug = parentDebug.extend(\"createStoreSync\");\n\nconst defaultFilters: SyncFilter[] = internalTableIds.map((tableId) => ({ tableId }));\n\ntype CreateStoreSyncOptions<TConfig extends StoreConfig = StoreConfig> = SyncOptions<TConfig> & {\n  storageAdapter: StorageAdapter;\n  onProgress?: (opts: {\n    step: SyncStep;\n    percentage: number;\n    latestBlockNumber: bigint;\n    lastBlockNumberProcessed: bigint;\n    message: string;\n  }) => void;\n};\n\nexport async function createStoreSync<TConfig extends StoreConfig = StoreConfig>({\n  storageAdapter,\n  onProgress,\n  publicClient,\n  address,\n  filters: initialFilters = [],\n  tableIds = [],\n  startBlock: initialStartBlock = 0n,\n  maxBlockRange,\n  initialState,\n  indexerUrl,\n}: CreateStoreSyncOptions<TConfig>): Promise<SyncResult> {\n  const filters: SyncFilter[] =\n    initialFilters.length || tableIds.length\n      ? [...initialFilters, ...tableIds.map((tableId) => ({ tableId })), ...defaultFilters]\n      : [];\n  const initialState$ = defer(\n    async (): Promise<\n      | {\n          blockNumber: bigint | null;\n          tables: TableWithRecords[];\n        }\n      | undefined\n    > => {\n      if (initialState) return initialState;\n      if (!indexerUrl) return;\n\n      debug(\"fetching initial state from indexer\", indexerUrl);\n\n      onProgress?.({\n        step: SyncStep.SNAPSHOT,\n        percentage: 0,\n        latestBlockNumber: 0n,\n        lastBlockNumberProcessed: 0n,\n        message: \"Fetching snapshot from indexer\",\n      });\n\n      const indexer = createIndexerClient({ url: indexerUrl });\n      const chainId = publicClient.chain?.id ?? (await publicClient.getChainId());\n      const result = await indexer.findAll.query({ chainId, address, filters });\n\n      onProgress?.({\n        step: SyncStep.SNAPSHOT,\n        percentage: 100,\n        latestBlockNumber: 0n,\n        lastBlockNumberProcessed: 0n,\n        message: \"Fetched snapshot from indexer\",\n      });\n\n      return result;\n    }\n  ).pipe(\n    catchError((error) => {\n      debug(\"error fetching initial state from indexer\", error);\n\n      onProgress?.({\n        step: SyncStep.SNAPSHOT,\n        percentage: 100,\n        latestBlockNumber: 0n,\n        lastBlockNumberProcessed: initialStartBlock,\n        message: \"Failed to fetch snapshot from indexer\",\n      });\n\n      return of(undefined);\n    }),\n    shareReplay(1)\n  );\n\n  const startBlock$ = initialState$.pipe(\n    map((initialState) => initialState?.blockNumber ?? initialStartBlock),\n    // TODO: if start block is still 0, find via deploy event\n    tap((startBlock) => debug(\"starting sync from block\", startBlock))\n  );\n\n  const initialLogs$ = initialState$.pipe(\n    filter(\n      (initialState): initialState is { blockNumber: bigint; tables: TableWithRecords[] } =>\n        initialState != null && initialState.blockNumber != null && initialState.tables.length > 0\n    ),\n    concatMap(async ({ blockNumber, tables }) => {\n      debug(\"hydrating from initial state to block\", blockNumber);\n\n      onProgress?.({\n        step: SyncStep.SNAPSHOT,\n        percentage: 0,\n        latestBlockNumber: 0n,\n        lastBlockNumberProcessed: blockNumber,\n        message: \"Hydrating from snapshot\",\n      });\n\n      const logs: StorageAdapterLog[] = tables.flatMap((table) =>\n        table.records.map(\n          (record): StorageAdapterLog => ({\n            eventName: \"Store_SetRecord\",\n            address: table.address,\n            args: {\n              tableId: table.tableId,\n              keyTuple: encodeKey(table.keySchema, record.key),\n              ...encodeValueArgs(table.valueSchema, record.value),\n            },\n          })\n        )\n      );\n\n      // Split snapshot operations into chunks so we can update the progress callback (and ultimately render visual progress for the user).\n      // This isn't ideal if we want to e.g. batch load these into a DB in a single DB tx, but we'll take it.\n      //\n      // Split into 50 equal chunks (for better `onProgress` updates) but only if we have 100+ items per chunk\n      const chunkSize = Math.max(100, Math.floor(logs.length / 50));\n      const chunks = Array.from(chunk(logs, chunkSize));\n      for (const [i, chunk] of chunks.entries()) {\n        await storageAdapter({ blockNumber, logs: chunk });\n        onProgress?.({\n          step: SyncStep.SNAPSHOT,\n          percentage: ((i + chunk.length) / chunks.length) * 100,\n          latestBlockNumber: 0n,\n          lastBlockNumberProcessed: blockNumber,\n          message: \"Hydrating from snapshot\",\n        });\n      }\n\n      onProgress?.({\n        step: SyncStep.SNAPSHOT,\n        percentage: 100,\n        latestBlockNumber: 0n,\n        lastBlockNumberProcessed: blockNumber,\n        message: \"Hydrated from snapshot\",\n      });\n\n      return { blockNumber, logs };\n    }),\n    shareReplay(1)\n  );\n\n  const latestBlock$ = createBlockStream({ publicClient, blockTag: \"latest\" }).pipe(shareReplay(1));\n  const latestBlockNumber$ = latestBlock$.pipe(\n    map((block) => block.number),\n    tap((blockNumber) => {\n      debug(\"latest block number\", blockNumber);\n    }),\n    shareReplay(1)\n  );\n\n  let startBlock: bigint | null = null;\n  let endBlock: bigint | null = null;\n  const blockLogs$ = combineLatest([startBlock$, latestBlockNumber$]).pipe(\n    map(([startBlock, endBlock]) => ({ startBlock, endBlock })),\n    tap((range) => {\n      startBlock = range.startBlock;\n      endBlock = range.endBlock;\n    }),\n    blockRangeToLogs({\n      publicClient,\n      address,\n      events: storeEventsAbi,\n      // TODO: pass filters in here so we can filter at RPC level\n      maxBlockRange,\n    }),\n    map(({ toBlock, logs }) => {\n      if (!filters.length) return { toBlock, logs };\n      const filteredLogs = logs.filter((log) =>\n        filters.some(\n          (filter) =>\n            filter.tableId === log.args.tableId &&\n            (filter.key0 == null || filter.key0 === log.args.keyTuple[0]) &&\n            (filter.key1 == null || filter.key1 === log.args.keyTuple[1])\n        )\n      );\n      return { toBlock, logs: filteredLogs };\n    }),\n    mergeMap(({ toBlock, logs }) => from(groupLogsByBlockNumber(logs, toBlock))),\n    share()\n  );\n\n  let lastBlockNumberProcessed: bigint | null = null;\n  const storedBlockLogs$ = concat(\n    initialLogs$,\n    blockLogs$.pipe(\n      concatMap(async (block) => {\n        await storageAdapter(block);\n        return block;\n      }),\n      tap(({ blockNumber, logs }) => {\n        debug(\"stored\", logs.length, \"logs for block\", blockNumber);\n        lastBlockNumberProcessed = blockNumber;\n\n        if (startBlock != null && endBlock != null) {\n          if (blockNumber < endBlock) {\n            const totalBlocks = endBlock - startBlock;\n            const processedBlocks = lastBlockNumberProcessed - startBlock;\n            onProgress?.({\n              step: SyncStep.RPC,\n              percentage: Number((processedBlocks * 1000n) / totalBlocks) / 10,\n              latestBlockNumber: endBlock,\n              lastBlockNumberProcessed,\n              message: \"Hydrating from RPC\",\n            });\n          } else {\n            onProgress?.({\n              step: SyncStep.LIVE,\n              percentage: 100,\n              latestBlockNumber: endBlock,\n              lastBlockNumberProcessed,\n              message: \"All caught up!\",\n            });\n          }\n        }\n      })\n    )\n  ).pipe(share());\n\n  // keep 10 blocks worth processed transactions in memory\n  const recentBlocksWindow = 10;\n  // most recent block first, for ease of pulling the first one off the array\n  const recentBlocks$ = storedBlockLogs$.pipe(\n    scan<StorageAdapterBlock, StorageAdapterBlock[]>(\n      (recentBlocks, block) => [block, ...recentBlocks].slice(0, recentBlocksWindow),\n      []\n    ),\n    filter((recentBlocks) => recentBlocks.length > 0),\n    shareReplay(1)\n  );\n\n  // TODO: move to its own file so we can test it, have its own debug instance, etc.\n  async function waitForTransaction(tx: Hex): Promise<void> {\n    debug(\"waiting for tx\", tx);\n\n    // This currently blocks for async call on each block processed\n    // We could potentially speed this up a tiny bit by racing to see if 1) tx exists in processed block or 2) fetch tx receipt for latest block processed\n    const hasTransaction$ = recentBlocks$.pipe(\n      concatMap(async (blocks) => {\n        const txs = blocks.flatMap((block) => block.logs.map((op) => op.transactionHash).filter(isDefined));\n        if (txs.includes(tx)) return true;\n\n        try {\n          const lastBlock = blocks[0];\n          debug(\"fetching tx receipt for block\", lastBlock.blockNumber);\n          const receipt = await publicClient.getTransactionReceipt({ hash: tx });\n          return lastBlock.blockNumber >= receipt.blockNumber;\n        } catch (error) {\n          if (error instanceof TransactionReceiptNotFoundError) {\n            return false;\n          }\n          throw error;\n        }\n      }),\n      tap((result) => debug(\"has tx?\", tx, result))\n    );\n\n    await firstValueFrom(hasTransaction$.pipe(filter(identity)));\n  }\n\n  return {\n    latestBlock$,\n    latestBlockNumber$,\n    blockLogs$,\n    storedBlockLogs$,\n    waitForTransaction,\n  };\n}\n", "import createDebug from \"debug\";\n\nexport const debug = createDebug(\"mud:store-sync\");\n", "import { DynamicAbiType, SchemaAbiType, StaticAbiType, isDynamicAbiType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\nexport function abiTypesToSchema(abiTypes: SchemaAbiType[]): Schema {\n  const staticFields: StaticAbiType[] = [];\n  const dynamicFields: DynamicAbiType[] = [];\n  for (const abiType of abiTypes) {\n    if (isDynamicAbiType(abiType)) dynamicFields.push(abiType);\n    else staticFields.push(abiType);\n  }\n  return { staticFields, dynamicFields };\n}\n", "import { Hex, hexToString, sliceHex } from \"viem\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport {\n  DynamicAbiType,\n  DynamicAbiTypeToPrimitiveType,\n  arrayAbiTypeToStaticAbiType,\n  staticAbiTypeToByteLength,\n} from \"@latticexyz/schema-type\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { InvalidHexLengthError, InvalidHexLengthForArrayFieldError } from \"./errors\";\n\n// TODO: require size/length for dynamic fields, because hex might be longer (sometimes we just move the length pointer of arrays without updating the value)\n//       this means the error should probably change from \"invalid length\" to \"too short\", which viem has that we could reuse?\n\nexport function decodeDynamicField<\n  TAbiType extends DynamicAbiType,\n  TPrimitiveType extends DynamicAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  if (abiType === \"bytes\") {\n    return data as TPrimitiveType;\n  }\n  if (abiType === \"string\") {\n    return hexToString(data) as TPrimitiveType;\n  }\n\n  if (data.length > 3 && data.length % 2 !== 0) {\n    throw new InvalidHexLengthError(data);\n  }\n\n  const dataSize = (data.length - 2) / 2;\n\n  switch (abiType) {\n    case \"uint8[]\":\n    case \"uint16[]\":\n    case \"uint24[]\":\n    case \"uint32[]\":\n    case \"uint40[]\":\n    case \"uint48[]\":\n    case \"uint56[]\":\n    case \"uint64[]\":\n    case \"uint72[]\":\n    case \"uint80[]\":\n    case \"uint88[]\":\n    case \"uint96[]\":\n    case \"uint104[]\":\n    case \"uint112[]\":\n    case \"uint120[]\":\n    case \"uint128[]\":\n    case \"uint136[]\":\n    case \"uint144[]\":\n    case \"uint152[]\":\n    case \"uint160[]\":\n    case \"uint168[]\":\n    case \"uint176[]\":\n    case \"uint184[]\":\n    case \"uint192[]\":\n    case \"uint200[]\":\n    case \"uint208[]\":\n    case \"uint216[]\":\n    case \"uint224[]\":\n    case \"uint232[]\":\n    case \"uint240[]\":\n    case \"uint248[]\":\n    case \"uint256[]\":\n    case \"int8[]\":\n    case \"int16[]\":\n    case \"int24[]\":\n    case \"int32[]\":\n    case \"int40[]\":\n    case \"int48[]\":\n    case \"int56[]\":\n    case \"int64[]\":\n    case \"int72[]\":\n    case \"int80[]\":\n    case \"int88[]\":\n    case \"int96[]\":\n    case \"int104[]\":\n    case \"int112[]\":\n    case \"int120[]\":\n    case \"int128[]\":\n    case \"int136[]\":\n    case \"int144[]\":\n    case \"int152[]\":\n    case \"int160[]\":\n    case \"int168[]\":\n    case \"int176[]\":\n    case \"int184[]\":\n    case \"int192[]\":\n    case \"int200[]\":\n    case \"int208[]\":\n    case \"int216[]\":\n    case \"int224[]\":\n    case \"int232[]\":\n    case \"int240[]\":\n    case \"int248[]\":\n    case \"int256[]\":\n    case \"bytes1[]\":\n    case \"bytes2[]\":\n    case \"bytes3[]\":\n    case \"bytes4[]\":\n    case \"bytes5[]\":\n    case \"bytes6[]\":\n    case \"bytes7[]\":\n    case \"bytes8[]\":\n    case \"bytes9[]\":\n    case \"bytes10[]\":\n    case \"bytes11[]\":\n    case \"bytes12[]\":\n    case \"bytes13[]\":\n    case \"bytes14[]\":\n    case \"bytes15[]\":\n    case \"bytes16[]\":\n    case \"bytes17[]\":\n    case \"bytes18[]\":\n    case \"bytes19[]\":\n    case \"bytes20[]\":\n    case \"bytes21[]\":\n    case \"bytes22[]\":\n    case \"bytes23[]\":\n    case \"bytes24[]\":\n    case \"bytes25[]\":\n    case \"bytes26[]\":\n    case \"bytes27[]\":\n    case \"bytes28[]\":\n    case \"bytes29[]\":\n    case \"bytes30[]\":\n    case \"bytes31[]\":\n    case \"bytes32[]\":\n    case \"bool[]\":\n    case \"address[]\": {\n      const staticAbiType = arrayAbiTypeToStaticAbiType(abiType);\n      const itemByteLength = staticAbiTypeToByteLength[staticAbiType];\n      if (dataSize % itemByteLength !== 0) {\n        throw new InvalidHexLengthForArrayFieldError(staticAbiType, data);\n      }\n      const items = new Array(dataSize / itemByteLength).fill(undefined).map((_, i) => {\n        const itemData = sliceHex(data, i * itemByteLength, (i + 1) * itemByteLength);\n        return decodeStaticField(staticAbiType, itemData);\n      });\n      return items as TPrimitiveType;\n    }\n  }\n\n  return assertExhaustive(abiType, `Unsupported dynamic ABI type: ${abiType}`);\n}\n", "import { Hex, getAddress, hexToBigInt, hexToBool } from \"viem\";\nimport { assertExhaustive } from \"@latticexyz/common/utils\";\nimport {\n  StaticAbiType,\n  StaticAbiTypeToPrimitiveType,\n  staticAbiTypeToByteLength,\n  staticAbiTypeToDefaultValue,\n} from \"@latticexyz/schema-type\";\nimport { InvalidHexLengthError, InvalidHexLengthForStaticFieldError } from \"./errors\";\n\nexport function decodeStaticField<\n  TAbiType extends StaticAbiType,\n  TPrimitiveType extends StaticAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  if (data.length > 3 && data.length % 2 !== 0) {\n    throw new InvalidHexLengthError(data);\n  }\n\n  const dataSize = (data.length - 2) / 2;\n  if (dataSize !== staticAbiTypeToByteLength[abiType]) {\n    throw new InvalidHexLengthForStaticFieldError(abiType, data);\n  }\n\n  switch (abiType) {\n    case \"uint8\":\n    case \"uint16\":\n    case \"uint24\":\n    case \"uint32\":\n    case \"uint40\":\n    case \"uint48\":\n    case \"uint56\":\n    case \"uint64\":\n    case \"uint72\":\n    case \"uint80\":\n    case \"uint88\":\n    case \"uint96\":\n    case \"uint104\":\n    case \"uint112\":\n    case \"uint120\":\n    case \"uint128\":\n    case \"uint136\":\n    case \"uint144\":\n    case \"uint152\":\n    case \"uint160\":\n    case \"uint168\":\n    case \"uint176\":\n    case \"uint184\":\n    case \"uint192\":\n    case \"uint200\":\n    case \"uint208\":\n    case \"uint216\":\n    case \"uint224\":\n    case \"uint232\":\n    case \"uint240\":\n    case \"uint248\":\n    case \"uint256\":\n    case \"int8\":\n    case \"int16\":\n    case \"int24\":\n    case \"int32\":\n    case \"int40\":\n    case \"int48\":\n    case \"int56\":\n    case \"int64\":\n    case \"int72\":\n    case \"int80\":\n    case \"int88\":\n    case \"int96\":\n    case \"int104\":\n    case \"int112\":\n    case \"int120\":\n    case \"int128\":\n    case \"int136\":\n    case \"int144\":\n    case \"int152\":\n    case \"int160\":\n    case \"int168\":\n    case \"int176\":\n    case \"int184\":\n    case \"int192\":\n    case \"int200\":\n    case \"int208\":\n    case \"int216\":\n    case \"int224\":\n    case \"int232\":\n    case \"int240\":\n    case \"int248\":\n    case \"int256\": {\n      const value = hexToBigInt(data, { signed: abiType.startsWith(\"int\") });\n      const defaultValueType = typeof staticAbiTypeToDefaultValue[abiType];\n      if (defaultValueType === \"number\") {\n        return Number(value) as TPrimitiveType;\n      }\n      if (defaultValueType === \"bigint\") {\n        return value as TPrimitiveType;\n      }\n      throw new Error(`Unexpected default value type (${defaultValueType}) for ABI type (${abiType})`);\n    }\n\n    case \"bytes1\":\n    case \"bytes2\":\n    case \"bytes3\":\n    case \"bytes4\":\n    case \"bytes5\":\n    case \"bytes6\":\n    case \"bytes7\":\n    case \"bytes8\":\n    case \"bytes9\":\n    case \"bytes10\":\n    case \"bytes11\":\n    case \"bytes12\":\n    case \"bytes13\":\n    case \"bytes14\":\n    case \"bytes15\":\n    case \"bytes16\":\n    case \"bytes17\":\n    case \"bytes18\":\n    case \"bytes19\":\n    case \"bytes20\":\n    case \"bytes21\":\n    case \"bytes22\":\n    case \"bytes23\":\n    case \"bytes24\":\n    case \"bytes25\":\n    case \"bytes26\":\n    case \"bytes27\":\n    case \"bytes28\":\n    case \"bytes29\":\n    case \"bytes30\":\n    case \"bytes31\":\n    case \"bytes32\": {\n      return data as TPrimitiveType;\n    }\n\n    case \"bool\": {\n      return hexToBool(data) as TPrimitiveType;\n    }\n\n    case \"address\": {\n      return getAddress(data) as TPrimitiveType;\n    }\n  }\n\n  return assertExhaustive(abiType, `Unsupported static ABI type: ${abiType}`);\n}\n", "import { Hex } from \"viem\";\nimport { MUDError } from \"@latticexyz/common/errors\";\nimport { StaticAbiType, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\n\nexport class InvalidHexLengthError extends MUDError {\n  override name = \"InvalidHexValueError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" is an odd length (${value.length - 2}). It must be an even length.`);\n  }\n}\n\nexport class InvalidHexLengthForSchemaError extends MUDError {\n  override name = \"InvalidHexLengthForSchemaError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" has length of ${value.length - 2}, but expected length of 64 for a schema.`);\n  }\n}\n\nexport class InvalidHexLengthForPackedCounterError extends MUDError {\n  override name = \"InvalidHexLengthForPackedCounterError\";\n  constructor(value: Hex) {\n    super(`Hex value \"${value}\" has length of ${value.length - 2}, but expected length of 64 for a packed counter.`);\n  }\n}\n\nexport class InvalidHexLengthForStaticFieldError extends MUDError {\n  override name = \"InvalidHexLengthForStaticFieldError\";\n  constructor(abiType: StaticAbiType, value: Hex) {\n    super(\n      `Hex value \"${value}\" has length of ${value.length - 2}, but expected length of ${\n        staticAbiTypeToByteLength[abiType] * 2\n      } for ${abiType} type.`\n    );\n  }\n}\n\nexport class InvalidHexLengthForArrayFieldError extends MUDError {\n  override name = \"InvalidHexLengthForArrayFieldError\";\n  constructor(abiType: StaticAbiType, value: Hex) {\n    super(\n      `Hex value \"${value}\" has length of ${value.length - 2}, but expected a multiple of ${\n        staticAbiTypeToByteLength[abiType] * 2\n      } for ${abiType}[] type.`\n    );\n  }\n}\n\nexport class SchemaStaticLengthMismatchError extends MUDError {\n  override name = \"SchemaStaticLengthMismatchError\";\n  constructor(schemaData: Hex, definedLength: number, summedLength: number) {\n    super(\n      `Schema \"${schemaData}\" static data length (${definedLength}) did not match the summed length of all static fields (${summedLength}). ` +\n        `Is \\`staticAbiTypeToByteLength\\` up to date with Solidity schema types?`\n    );\n  }\n}\n\nexport class PackedCounterLengthMismatchError extends MUDError {\n  override name = \"PackedCounterLengthMismatchError\";\n  constructor(packedCounterData: Hex, definedLength: bigint, summedLength: bigint) {\n    super(\n      `PackedCounter \"${packedCounterData}\" total bytes length (${definedLength}) did not match the summed length of all field byte lengths (${summedLength}).`\n    );\n  }\n}\n", "import { Hex } from \"viem\";\nimport { SchemaAbiType, SchemaAbiTypeToPrimitiveType, isDynamicAbiType } from \"@latticexyz/schema-type\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { decodeStaticField } from \"./decodeStaticField\";\n\nexport function decodeField<\n  TAbiType extends SchemaAbiType,\n  TPrimitiveType extends SchemaAbiTypeToPrimitiveType<TAbiType>\n>(abiType: TAbiType, data: Hex): TPrimitiveType {\n  return (\n    isDynamicAbiType(abiType) ? decodeDynamicField(abiType, data) : decodeStaticField(abiType, data)\n  ) as TPrimitiveType;\n}\n", "import { Hex, decodeAbiParameters } from \"viem\";\nimport { StaticPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\n// key tuples are encoded in the same way as abi.encode, so we can decode them with viem\n\n/** @deprecated use `decodeKey` instead */\nexport function decodeKeyTuple(keySchema: Schema, keyTuple: readonly Hex[]): StaticPrimitiveType[] {\n  if (keySchema.staticFields.length !== keyTuple.length) {\n    throw new Error(\n      `key tuple length ${keyTuple.length} does not match key schema length ${keySchema.staticFields.length}`\n    );\n  }\n  return keyTuple.map(\n    (key, index) => decodeAbiParameters([{ type: keySchema.staticFields[index] }], key)[0] as StaticPrimitiveType\n  );\n}\n", "import { Hex } from \"viem\";\nimport { SchemaToPrimitives, KeySchema } from \"./common\";\nimport { decodeKeyTuple } from \"./decodeKeyTuple\";\n\nexport function decodeKey<TSchema extends KeySchema>(\n  keySchema: TSchema,\n  data: readonly Hex[]\n): SchemaToPrimitives<TSchema> {\n  // TODO: refactor and move all decodeKeyTuple logic into this method so we can delete decodeKeyTuple\n  const keyValues = decodeKeyTuple({ staticFields: Object.values(keySchema), dynamicFields: [] }, data);\n\n  return Object.fromEntries(\n    Object.keys(keySchema).map((name, i) => [name, keyValues[i]])\n  ) as SchemaToPrimitives<TSchema>;\n}\n", "import {\n  StaticPrimitiveType,\n  DynamicPrimitiveType,\n  staticAbiTypeToByteLength,\n  dynamicAbiTypeToDefaultValue,\n} from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { hexToPackedCounter } from \"./hexToPackedCounter\";\nimport { staticDataLength } from \"./staticDataLength\";\nimport { readHex } from \"@latticexyz/common\";\n\n/** @deprecated use `decodeValue` instead */\nexport function decodeRecord(valueSchema: Schema, data: Hex): readonly (StaticPrimitiveType | DynamicPrimitiveType)[] {\n  const values: (StaticPrimitiveType | DynamicPrimitiveType)[] = [];\n\n  let bytesOffset = 0;\n  valueSchema.staticFields.forEach((fieldType) => {\n    const fieldByteLength = staticAbiTypeToByteLength[fieldType];\n    const value = decodeStaticField(fieldType, readHex(data, bytesOffset, bytesOffset + fieldByteLength));\n    bytesOffset += fieldByteLength;\n    values.push(value);\n  });\n\n  // Warn user if static data length doesn't match the value schema, because data corruption might be possible.\n  const schemaStaticDataLength = staticDataLength(valueSchema.staticFields);\n  const actualStaticDataLength = bytesOffset;\n  if (actualStaticDataLength !== schemaStaticDataLength) {\n    console.warn(\n      \"Decoded static data length does not match value schema's expected static data length. Data may get corrupted. Is `getStaticByteLength` outdated?\",\n      {\n        expectedLength: schemaStaticDataLength,\n        actualLength: actualStaticDataLength,\n        bytesOffset,\n      }\n    );\n  }\n\n  if (valueSchema.dynamicFields.length > 0) {\n    const dataLayout = hexToPackedCounter(readHex(data, bytesOffset, bytesOffset + 32));\n    bytesOffset += 32;\n\n    valueSchema.dynamicFields.forEach((fieldType, i) => {\n      const dataLength = dataLayout.fieldByteLengths[i];\n      if (dataLength > 0) {\n        const value = decodeDynamicField(fieldType, readHex(data, bytesOffset, bytesOffset + dataLength));\n        bytesOffset += dataLength;\n        values.push(value);\n      } else {\n        values.push(dynamicAbiTypeToDefaultValue[fieldType]);\n      }\n    });\n\n    // Warn user if dynamic data length doesn't match the dynamic data length, because data corruption might be possible.\n    const actualDynamicDataLength = bytesOffset - 32 - actualStaticDataLength;\n    // TODO: refactor this so we don't break for bytes offsets >UINT40\n    if (BigInt(actualDynamicDataLength) !== dataLayout.totalByteLength) {\n      console.warn(\n        \"Decoded dynamic data length does not match data layout's expected data length. Data may get corrupted. Did the data layout change?\",\n        {\n          expectedLength: dataLayout.totalByteLength,\n          actualLength: actualDynamicDataLength,\n          bytesOffset,\n        }\n      );\n    }\n  }\n\n  return values;\n}\n", "import { Hex } from \"viem\";\nimport { decodeStaticField } from \"./decodeStaticField\";\nimport { decodeDynamicField } from \"./decodeDynamicField\";\nimport { InvalidHexLengthForPackedCounterError, PackedCounterLengthMismatchError } from \"./errors\";\nimport { readHex } from \"@latticexyz/common\";\n\n// Keep this logic in sync with PackedCounter.sol\n\n// - Last 7 bytes (uint56) are used for the total byte length of the dynamic data\n// - The next 5 byte (uint40) sections are used for the byte length of each field, indexed from right to left\n\n// We use byte lengths rather than item counts so that, on chain, we can slice without having to get the value schema first (and thus the field lengths of each dynamic type)\n\nexport function hexToPackedCounter(data: Hex): {\n  totalByteLength: bigint;\n  fieldByteLengths: readonly number[];\n} {\n  if (data.length !== 66) {\n    throw new InvalidHexLengthForPackedCounterError(data);\n  }\n\n  const totalByteLength = decodeStaticField(\"uint56\", readHex(data, 32 - 7, 32));\n  // TODO: use value schema to make sure we only parse as many as we need (rather than zeroes at the end)?\n  const reversedFieldByteLengths = decodeDynamicField(\"uint40[]\", readHex(data, 0, 32 - 7));\n  // Reverse the lengths\n  const fieldByteLengths = Object.freeze([...reversedFieldByteLengths].reverse());\n\n  const summedLength = BigInt(fieldByteLengths.reduce((total, length) => total + length, 0));\n  if (summedLength !== totalByteLength) {\n    throw new PackedCounterLengthMismatchError(data, totalByteLength, summedLength);\n  }\n\n  return { totalByteLength, fieldByteLengths };\n}\n", "import { StaticAbiType, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\n\nexport function staticDataLength(staticFields: readonly StaticAbiType[]): number {\n  return staticFields.reduce((length, fieldType) => length + staticAbiTypeToByteLength[fieldType], 0);\n}\n", "import { isStaticAbiType, isDynamicAbiType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { SchemaToPrimitives, ValueSchema } from \"./common\";\nimport { decodeRecord } from \"./decodeRecord\";\n\nexport function decodeValue<TSchema extends ValueSchema>(valueSchema: TSchema, data: Hex): SchemaToPrimitives<TSchema> {\n  const staticFields = Object.values(valueSchema).filter(isStaticAbiType);\n  const dynamicFields = Object.values(valueSchema).filter(isDynamicAbiType);\n\n  // TODO: refactor and move all decodeRecord logic into this method so we can delete decodeRecord\n  const valueTuple = decodeRecord({ staticFields, dynamicFields }, data);\n\n  return Object.fromEntries(\n    Object.keys(valueSchema).map((name, i) => [name, valueTuple[i]])\n  ) as SchemaToPrimitives<TSchema>;\n}\n", "import { concatHex } from \"viem\";\nimport { isStaticAbiType } from \"@latticexyz/schema-type\";\nimport { SchemaToPrimitives, ValueArgs, ValueSchema } from \"./common\";\nimport { decodeValue } from \"./decodeValue\";\nimport { staticDataLength } from \"./staticDataLength\";\nimport { readHex } from \"@latticexyz/common\";\n\nexport function decodeValueArgs<TSchema extends ValueSchema>(\n  valueSchema: TSchema,\n  { staticData, encodedLengths, dynamicData }: ValueArgs\n): SchemaToPrimitives<TSchema> {\n  return decodeValue(\n    valueSchema,\n    concatHex([\n      readHex(staticData, 0, staticDataLength(Object.values(valueSchema).filter(isStaticAbiType))),\n      encodedLengths,\n      dynamicData,\n    ])\n  );\n}\n", "import { SchemaAbiType, arrayAbiTypeToStaticAbiType, isArrayAbiType } from \"@latticexyz/schema-type\";\nimport { AbiParameterToPrimitiveType } from \"abitype\";\nimport { Hex, encodePacked } from \"viem\";\n\nexport function encodeField<TSchemaAbiType extends SchemaAbiType>(\n  fieldType: TSchemaAbiType,\n  value: AbiParameterToPrimitiveType<{ type: TSchemaAbiType }>\n): Hex {\n  if (isArrayAbiType(fieldType) && Array.isArray(value)) {\n    const staticFieldType = arrayAbiTypeToStaticAbiType(fieldType);\n    // TODO: we can remove conditional once this is fixed: https://github.com/wagmi-dev/viem/pull/1147\n    return value.length === 0\n      ? \"0x\"\n      : encodePacked(\n          value.map(() => staticFieldType),\n          value\n        );\n  }\n  return encodePacked([fieldType], [value]);\n}\n", "import { isStaticAbiType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { SchemaToPrimitives, KeySchema } from \"./common\";\nimport { encodeKeyTuple } from \"./encodeKeyTuple\";\n\nexport function encodeKey<TSchema extends KeySchema>(keySchema: TSchema, key: SchemaToPrimitives<TSchema>): Hex[] {\n  const staticFields = Object.values(keySchema).filter(isStaticAbiType);\n  // TODO: refactor and move all encodeKeyTuple logic into this method so we can delete encodeKeyTuple\n  return encodeKeyTuple({ staticFields, dynamicFields: [] }, Object.values(key));\n}\n", "import { StaticPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Hex, encodeAbiParameters } from \"viem\";\nimport { Schema } from \"./common\";\n\n/** @deprecated use `encodeKey` instead */\nexport function encodeKeyTuple(keySchema: Schema, keyTuple: StaticPrimitiveType[]): Hex[] {\n  return keyTuple.map((key, index) => encodeAbiParameters([{ type: keySchema.staticFields[index] }], [key]));\n}\n", "import { StaticPrimitiveType, DynamicPrimitiveType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { encodeField } from \"./encodeField\";\nimport { Schema } from \"./common\";\n\n/** @deprecated use `encodeValue` instead */\nexport function encodeRecord(\n  valueSchema: Schema,\n  values: readonly (StaticPrimitiveType | DynamicPrimitiveType)[]\n): Hex {\n  const staticValues = values.slice(0, valueSchema.staticFields.length) as readonly StaticPrimitiveType[];\n  const dynamicValues = values.slice(valueSchema.staticFields.length) as readonly DynamicPrimitiveType[];\n\n  const staticData = staticValues\n    .map((value, i) => encodeField(valueSchema.staticFields[i], value).replace(/^0x/, \"\"))\n    .join(\"\");\n\n  if (valueSchema.dynamicFields.length === 0) return `0x${staticData}`;\n\n  const dynamicDataItems = dynamicValues.map((value, i) =>\n    encodeField(valueSchema.dynamicFields[i], value).replace(/^0x/, \"\")\n  );\n\n  const dynamicFieldByteLengths = dynamicDataItems.map((value) => value.length / 2).reverse();\n  const dynamicTotalByteLength = dynamicFieldByteLengths.reduce((total, length) => total + BigInt(length), 0n);\n\n  const dynamicData = dynamicDataItems.join(\"\");\n\n  const packedCounter = `${dynamicFieldByteLengths\n    .map((length) => encodeField(\"uint40\", length).replace(/^0x/, \"\"))\n    .join(\"\")}${encodeField(\"uint56\", dynamicTotalByteLength).replace(/^0x/, \"\")}`.padStart(64, \"0\");\n\n  return `0x${staticData}${packedCounter}${dynamicData}`;\n}\n", "import { Hex, concatHex } from \"viem\";\nimport { SchemaToPrimitives, ValueSchema } from \"./common\";\nimport { encodeValueArgs } from \"./encodeValueArgs\";\n\nexport function encodeValue<TSchema extends ValueSchema>(\n  valueSchema: TSchema,\n  value: SchemaToPrimitives<TSchema>\n): Hex {\n  const { staticData, encodedLengths, dynamicData } = encodeValueArgs(valueSchema, value);\n  return concatHex([staticData, encodedLengths, dynamicData]);\n}\n", "import {\n  StaticPrimitiveType,\n  DynamicPrimitiveType,\n  isStaticAbiType,\n  isDynamicAbiType,\n  StaticAbiType,\n  DynamicAbiType,\n} from \"@latticexyz/schema-type\";\nimport { concatHex } from \"viem\";\nimport { encodeField } from \"./encodeField\";\nimport { SchemaToPrimitives, ValueArgs, ValueSchema } from \"./common\";\nimport { encodeLengths } from \"./encodeLengths\";\n\nexport function encodeValueArgs<TSchema extends ValueSchema>(\n  valueSchema: TSchema,\n  value: SchemaToPrimitives<TSchema>\n): ValueArgs {\n  const valueSchemaEntries = Object.entries(valueSchema);\n  const staticFields = valueSchemaEntries.filter(([, type]) => isStaticAbiType(type)) as [string, StaticAbiType][];\n  const dynamicFields = valueSchemaEntries.filter(([, type]) => isDynamicAbiType(type)) as [string, DynamicAbiType][];\n  // TODO: validate <=5 dynamic fields\n  // TODO: validate <=28 total fields\n\n  const encodedStaticValues = staticFields.map(([name, type]) => encodeField(type, value[name] as StaticPrimitiveType));\n  const encodedDynamicValues = dynamicFields.map(([name, type]) =>\n    encodeField(type, value[name] as DynamicPrimitiveType)\n  );\n\n  const encodedLengths = encodeLengths(encodedDynamicValues);\n\n  return {\n    staticData: concatHex(encodedStaticValues),\n    encodedLengths,\n    dynamicData: concatHex(encodedDynamicValues),\n  };\n}\n", "import { Hex, concatHex, padHex, size } from \"viem\";\nimport { encodeField } from \"./encodeField\";\n\nexport function encodeLengths(values: Hex[]): Hex {\n  const byteLengths = values.map(size).reverse();\n  const totalByteLength = byteLengths.reduce((total, length) => total + BigInt(length), 0n);\n\n  return padHex(\n    concatHex([...byteLengths.map((length) => encodeField(\"uint40\", length)), encodeField(\"uint56\", totalByteLength)]),\n    { size: 32, dir: \"left\" }\n  );\n}\n", "import { Hex } from \"viem\";\nimport { FieldLayout } from \"./common\";\n\n/** @deprecated use `valueSchemaToFieldLayoutHex` instead */\nexport function fieldLayoutToHex(fieldLayout: FieldLayout): Hex {\n  const staticDataLength = fieldLayout.staticFieldLengths.reduce((totalLength, length) => totalLength + length, 0);\n  return `0x${[\n    staticDataLength.toString(16).padStart(4, \"0\"),\n    fieldLayout.staticFieldLengths.length.toString(16).padStart(2, \"0\"),\n    fieldLayout.numDynamicFields.toString(16).padStart(2, \"0\"),\n    ...fieldLayout.staticFieldLengths.map((schemaType) => schemaType.toString(16).padStart(2, \"0\")),\n  ]\n    .join(\"\")\n    .padEnd(64, \"0\")}`;\n}\n", "import { StaticAbiType, DynamicAbiType, schemaAbiTypes, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\nimport { Hex, hexToNumber, sliceHex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { InvalidHexLengthForSchemaError, SchemaStaticLengthMismatchError } from \"./errors\";\n\nexport function hexToSchema(data: Hex): Schema {\n  if (data.length !== 66) {\n    throw new InvalidHexLengthForSchemaError(data);\n  }\n\n  const staticDataLength = hexToNumber(sliceHex(data, 0, 2));\n  const numStaticFields = hexToNumber(sliceHex(data, 2, 3));\n  const numDynamicFields = hexToNumber(sliceHex(data, 3, 4));\n  const staticFields: StaticAbiType[] = [];\n  const dynamicFields: DynamicAbiType[] = [];\n\n  for (let i = 4; i < 4 + numStaticFields; i++) {\n    const schemaTypeIndex = hexToNumber(sliceHex(data, i, i + 1));\n    staticFields.push(schemaAbiTypes[schemaTypeIndex] as StaticAbiType);\n  }\n  for (let i = 4 + numStaticFields; i < 4 + numStaticFields + numDynamicFields; i++) {\n    const schemaTypeIndex = hexToNumber(sliceHex(data, i, i + 1));\n    dynamicFields.push(schemaAbiTypes[schemaTypeIndex] as DynamicAbiType);\n  }\n\n  // validate static data length\n  const actualStaticDataLength = staticFields.reduce((acc, fieldType) => acc + staticAbiTypeToByteLength[fieldType], 0);\n  if (actualStaticDataLength !== staticDataLength) {\n    console.warn(\n      `Schema \"${data}\" static data length (${staticDataLength}) did not match the summed length of all static fields (${actualStaticDataLength}). ` +\n        `Is \\`staticAbiTypeToByteLength\\` up to date with Solidity schema types?`\n    );\n    throw new SchemaStaticLengthMismatchError(data, staticDataLength, actualStaticDataLength);\n  }\n\n  return { staticFields, dynamicFields };\n}\n", "import { Hex, sliceHex } from \"viem\";\nimport { TableSchema } from \"./common\";\nimport { hexToSchema } from \"./hexToSchema\";\n\nexport function hexToTableSchema(data: Hex): TableSchema {\n  const valueSchema = hexToSchema(sliceHex(data, 0, 32));\n  const keySchema = hexToSchema(sliceHex(data, 32, 64));\n  return {\n    keySchema,\n    valueSchema,\n  };\n}\n", "import { isStaticAbiType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { KeySchema } from \"./common\";\nimport { schemaToHex } from \"./schemaToHex\";\n\nexport function keySchemaToHex(keySchema: KeySchema): Hex {\n  return schemaToHex({ staticFields: Object.values(keySchema).filter(isStaticAbiType), dynamicFields: [] });\n}\n", "import { schemaAbiTypes } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { Schema } from \"./common\";\nimport { staticDataLength } from \"./staticDataLength\";\n\n/** @deprecated use `keySchemaToHex` or `valueSchemaToHex` instead */\nexport function schemaToHex(schema: Schema): Hex {\n  const staticSchemaTypes = schema.staticFields.map((abiType) => schemaAbiTypes.indexOf(abiType));\n  const dynamicSchemaTypes = schema.dynamicFields.map((abiType) => schemaAbiTypes.indexOf(abiType));\n  return `0x${[\n    staticDataLength(schema.staticFields).toString(16).padStart(4, \"0\"),\n    schema.staticFields.length.toString(16).padStart(2, \"0\"),\n    schema.dynamicFields.length.toString(16).padStart(2, \"0\"),\n    ...staticSchemaTypes.map((schemaType) => schemaType.toString(16).padStart(2, \"0\")),\n    ...dynamicSchemaTypes.map((schemaType) => schemaType.toString(16).padStart(2, \"0\")),\n  ]\n    .join(\"\")\n    .padEnd(64, \"0\")}`;\n}\n", "import { SchemaAbiType } from \"@latticexyz/schema-type\";\nimport { Schema } from \"./common\";\n\nexport function schemaIndexToAbiType(schema: Schema, schemaIndex: number): SchemaAbiType {\n  if (schemaIndex < schema.staticFields.length) {\n    return schema.staticFields[schemaIndex];\n  }\n  return schema.dynamicFields[schemaIndex - schema.staticFields.length];\n}\n", "import { Hex } from \"viem\";\nimport { ValueSchema } from \"./common\";\nimport { isDynamicAbiType, isStaticAbiType, staticAbiTypeToByteLength } from \"@latticexyz/schema-type\";\n\n// TODO: add tests once we have corresponding tests for FieldLayout.sol (bytes32 -> FieldLayout and vice versa)\nexport function valueSchemaToFieldLayoutHex(valueSchema: ValueSchema): Hex {\n  const staticFields = Object.values(valueSchema).filter(isStaticAbiType);\n  const dynamicFields = Object.values(valueSchema).filter(isDynamicAbiType);\n\n  const staticFieldLengths = staticFields.map((fieldType) => staticAbiTypeToByteLength[fieldType]);\n  const staticDataLength = staticFieldLengths.reduce((dataLength, fieldLength) => dataLength + fieldLength, 0);\n\n  return `0x${[\n    staticDataLength.toString(16).padStart(4, \"0\"),\n    staticFields.length.toString(16).padStart(2, \"0\"),\n    dynamicFields.length.toString(16).padStart(2, \"0\"),\n    ...staticFieldLengths.map((fieldLength) => fieldLength.toString(16).padStart(2, \"0\")),\n  ]\n    .join(\"\")\n    .padEnd(64, \"0\")}`;\n}\n", "import { isDynamicAbiType, isStaticAbiType } from \"@latticexyz/schema-type\";\nimport { Hex } from \"viem\";\nimport { ValueSchema } from \"./common\";\nimport { schemaToHex } from \"./schemaToHex\";\n\nexport function valueSchemaToHex(valueSchema: ValueSchema): Hex {\n  return schemaToHex({\n    staticFields: Object.values(valueSchema).filter(isStaticAbiType),\n    dynamicFields: Object.values(valueSchema).filter(isDynamicAbiType),\n  });\n}\n", "import { StorageAdapterLog, storeTables } from \"./common\";\n\nexport function isTableRegistrationLog(\n  log: StorageAdapterLog\n): log is StorageAdapterLog & { eventName: \"Store_SetRecord\" } {\n  return log.eventName === \"Store_SetRecord\" && log.args.tableId === storeTables.Tables.tableId;\n}\n", "import { hexToSchema, decodeValue, ValueSchema } from \"@latticexyz/protocol-parser\";\nimport { Hex, concatHex, decodeAbiParameters, parseAbiParameters } from \"viem\";\nimport { StorageAdapterLog, Table, schemasTable } from \"./common\";\nimport { hexToResource } from \"@latticexyz/common\";\n\n// TODO: add tableToLog\n\nexport function logToTable(log: StorageAdapterLog & { eventName: \"Store_SetRecord\" }): Table {\n  const [tableId, ...otherKeys] = log.args.keyTuple;\n  if (otherKeys.length) {\n    console.warn(\"registerSchema event is expected to have only one key in key tuple, but got multiple\", log);\n  }\n\n  const table = hexToResource(tableId);\n\n  const value = decodeValue(\n    // TODO: remove cast when we have strong types for user types\n    schemasTable.valueSchema as ValueSchema,\n    concatHex([log.args.staticData, log.args.encodedLengths, log.args.dynamicData])\n  );\n\n  // TODO: remove cast when we have strong types for user types\n  const keySchema = hexToSchema(value.keySchema as Hex);\n\n  // TODO: remove cast when we have strong types for user types\n  const valueSchema = hexToSchema(value.valueSchema as Hex);\n\n  // TODO: remove cast when we have strong types for user types\n  const keyNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), value.abiEncodedKeyNames as Hex)[0];\n\n  // TODO: remove cast when we have strong types for user types\n  const fieldNames = decodeAbiParameters(parseAbiParameters(\"string[]\"), value.abiEncodedFieldNames as Hex)[0];\n\n  const valueAbiTypes = [...valueSchema.staticFields, ...valueSchema.dynamicFields];\n\n  return {\n    address: log.address,\n    tableId,\n    namespace: table.namespace,\n    name: table.name,\n    keySchema: Object.fromEntries(keySchema.staticFields.map((abiType, i) => [keyNames[i], abiType])),\n    valueSchema: Object.fromEntries(valueAbiTypes.map((abiType, i) => [fieldNames[i], abiType])),\n  };\n}\n", "import { Entity } from \"@latticexyz/recs\";\nimport { Hex, decodeAbiParameters } from \"viem\";\nimport { entityToHexKeyTuple } from \"./entityToHexKeyTuple\";\nimport { KeySchema, SchemaToPrimitives } from \"@latticexyz/protocol-parser\";\n\nexport function decodeEntity<TKeySchema extends KeySchema>(\n  keySchema: TKeySchema,\n  entity: Entity\n): SchemaToPrimitives<TKeySchema> {\n  const hexKeyTuple = entityToHexKeyTuple(entity);\n  if (hexKeyTuple.length !== Object.keys(keySchema).length) {\n    throw new Error(\n      `entity key tuple length ${hexKeyTuple.length} does not match key schema length ${Object.keys(keySchema).length}`\n    );\n  }\n  return Object.fromEntries(\n    Object.entries(keySchema).map(([key, type], index) => [\n      key,\n      decodeAbiParameters([{ type }], hexKeyTuple[index] as Hex)[0],\n    ])\n  ) as SchemaToPrimitives<TKeySchema>;\n}\n", "import { Entity } from \"@latticexyz/recs\";\nimport { Hex, sliceHex, size, isHex } from \"viem\";\n\nexport function entityToHexKeyTuple(entity: Entity): readonly Hex[] {\n  if (!isHex(entity)) {\n    throw new Error(`entity ${entity} is not a hex string`);\n  }\n  const length = size(entity);\n  if (length % 32 !== 0) {\n    throw new Error(`entity length ${length} is not a multiple of 32 bytes`);\n  }\n  return new Array(length / 32).fill(0).map((_, index) => sliceHex(entity, index * 32, (index + 1) * 32));\n}\n", "import { Entity } from \"@latticexyz/recs\";\nimport { encodeAbiParameters } from \"viem\";\nimport { hexKeyTupleToEntity } from \"./hexKeyTupleToEntity\";\nimport { KeySchema, SchemaToPrimitives } from \"@latticexyz/protocol-parser\";\n\nexport function encodeEntity<TKeySchema extends KeySchema>(\n  keySchema: TKeySchema,\n  key: SchemaToPrimitives<TKeySchema>\n): Entity {\n  if (Object.keys(keySchema).length !== Object.keys(key).length) {\n    throw new Error(\n      `key length ${Object.keys(key).length} does not match key schema length ${Object.keys(keySchema).length}`\n    );\n  }\n  return hexKeyTupleToEntity(\n    Object.entries(keySchema).map(([keyName, type]) => encodeAbiParameters([{ type }], [key[keyName]]))\n  );\n}\n", "import { Entity } from \"@latticexyz/recs\";\nimport { Hex, concatHex } from \"viem\";\n\nexport function hexKeyTupleToEntity(hexKeyTuple: readonly Hex[]): Entity {\n  return concatHex(hexKeyTuple as Hex[]) as Entity;\n}\n", "import { Component, Schema } from \"@latticexyz/recs\";\nimport { StoreComponentMetadata } from \"./common\";\n\nexport function isStoreComponent<S extends Schema = Schema>(\n  component: Component<S>\n): component is Component<S, StoreComponentMetadata> {\n  return (\n    component.metadata?.componentName != null &&\n    component.metadata?.tableName != null &&\n    component.metadata?.keySchema != null &&\n    component.metadata?.valueSchema != null\n  );\n}\n", "import { Table, resolveConfig } from \"@latticexyz/store\";\nimport { debug } from \"./debug\";\nimport { World as RecsWorld, getComponentValue, hasComponent, removeComponent, setComponent } from \"@latticexyz/recs\";\nimport { defineInternalComponents } from \"./defineInternalComponents\";\nimport { getTableEntity } from \"./getTableEntity\";\nimport { hexToResource, spliceHex } from \"@latticexyz/common\";\nimport { decodeValueArgs } from \"@latticexyz/protocol-parser\";\nimport { Hex, size } from \"viem\";\nimport { isTableRegistrationLog } from \"../isTableRegistrationLog\";\nimport { logToTable } from \"../logToTable\";\nimport { hexKeyTupleToEntity } from \"./hexKeyTupleToEntity\";\nimport { StorageAdapter, StorageAdapterBlock } from \"../common\";\nimport { singletonEntity } from \"./singletonEntity\";\nimport storeConfig from \"@latticexyz/store/mud.config\";\nimport worldConfig from \"@latticexyz/world/mud.config\";\nimport { TablesToComponents, tablesToComponents } from \"./tablesToComponents\";\n\nconst storeTables = resolveConfig(storeConfig).tables;\nconst worldTables = resolveConfig(worldConfig).tables;\n\nexport type RecsStorageOptions<tables extends Record<string, Table>> = {\n  world: RecsWorld;\n  tables: tables;\n  shouldSkipUpdateStream?: () => boolean;\n};\n\nexport type RecsStorageAdapter<tables extends Record<string, Table>> = {\n  storageAdapter: StorageAdapter;\n  components: TablesToComponents<tables> &\n    TablesToComponents<typeof storeTables> &\n    TablesToComponents<typeof worldTables> &\n    ReturnType<typeof defineInternalComponents>;\n};\n\nexport function recsStorage<tables extends Record<string, Table>>({\n  world,\n  tables,\n  shouldSkipUpdateStream,\n}: RecsStorageOptions<tables>): RecsStorageAdapter<tables> {\n  world.registerEntity({ id: singletonEntity });\n\n  const components = {\n    ...tablesToComponents(world, tables),\n    ...tablesToComponents(world, storeTables),\n    ...tablesToComponents(world, worldTables),\n    ...defineInternalComponents(world),\n  };\n\n  async function recsStorageAdapter({ logs }: StorageAdapterBlock): Promise<void> {\n    const newTables = logs.filter(isTableRegistrationLog).map(logToTable);\n    for (const newTable of newTables) {\n      const tableEntity = getTableEntity(newTable);\n      if (hasComponent(components.RegisteredTables, tableEntity)) {\n        console.warn(\"table already registered, ignoring\", {\n          newTable,\n          existingTable: getComponentValue(components.RegisteredTables, tableEntity)?.table,\n        });\n      } else {\n        setComponent(\n          components.RegisteredTables,\n          tableEntity,\n          { table: newTable },\n          { skipUpdateStream: shouldSkipUpdateStream?.() }\n        );\n      }\n    }\n\n    for (const log of logs) {\n      const { namespace, name } = hexToResource(log.args.tableId);\n      const table = getComponentValue(\n        components.RegisteredTables,\n        getTableEntity({ address: log.address, namespace, name })\n      )?.table;\n      if (!table) {\n        debug(`skipping update for unknown table: ${namespace}:${name} at ${log.address}`);\n        continue;\n      }\n\n      const component = world.components.find((c) => c.id === table.tableId);\n      if (!component) {\n        debug(\n          `skipping update for unknown component: ${table.tableId} (${table.namespace}:${\n            table.name\n          }). Available components: ${Object.keys(components)}`\n        );\n        continue;\n      }\n\n      const entity = hexKeyTupleToEntity(log.args.keyTuple);\n\n      if (log.eventName === \"Store_SetRecord\") {\n        const value = decodeValueArgs(table.valueSchema, log.args);\n        debug(\"setting component\", {\n          namespace: table.namespace,\n          name: table.name,\n          entity,\n          value,\n        });\n        setComponent(\n          component,\n          entity,\n          {\n            ...value,\n            __staticData: log.args.staticData,\n            __encodedLengths: log.args.encodedLengths,\n            __dynamicData: log.args.dynamicData,\n          },\n          { skipUpdateStream: shouldSkipUpdateStream?.() }\n        );\n      } else if (log.eventName === \"Store_SpliceStaticData\") {\n        // TODO: add tests that this works when no record had been set before\n        const previousValue = getComponentValue(component, entity);\n        const previousStaticData = (previousValue?.__staticData as Hex) ?? \"0x\";\n        const newStaticData = spliceHex(previousStaticData, log.args.start, size(log.args.data), log.args.data);\n        const newValue = decodeValueArgs(table.valueSchema, {\n          staticData: newStaticData,\n          encodedLengths: (previousValue?.__encodedLengths as Hex) ?? \"0x\",\n          dynamicData: (previousValue?.__dynamicData as Hex) ?? \"0x\",\n        });\n        debug(\"setting component via splice static\", {\n          namespace: table.namespace,\n          name: table.name,\n          entity,\n          previousStaticData,\n          newStaticData,\n          previousValue,\n          newValue,\n        });\n        setComponent(\n          component,\n          entity,\n          {\n            ...newValue,\n            __staticData: newStaticData,\n          },\n          { skipUpdateStream: shouldSkipUpdateStream?.() }\n        );\n      } else if (log.eventName === \"Store_SpliceDynamicData\") {\n        // TODO: add tests that this works when no record had been set before\n        const previousValue = getComponentValue(component, entity);\n        const previousDynamicData = (previousValue?.__dynamicData as Hex) ?? \"0x\";\n        const newDynamicData = spliceHex(previousDynamicData, log.args.start, log.args.deleteCount, log.args.data);\n        const newValue = decodeValueArgs(table.valueSchema, {\n          staticData: (previousValue?.__staticData as Hex) ?? \"0x\",\n          // TODO: handle unchanged encoded lengths\n          encodedLengths: log.args.encodedLengths,\n          dynamicData: newDynamicData,\n        });\n        debug(\"setting component via splice dynamic\", {\n          namespace: table.namespace,\n          name: table.name,\n          entity,\n          previousDynamicData,\n          newDynamicData,\n          previousValue,\n          newValue,\n        });\n        setComponent(\n          component,\n          entity,\n          {\n            ...newValue,\n            __encodedLengths: log.args.encodedLengths,\n            __dynamicData: newDynamicData,\n          },\n          { skipUpdateStream: shouldSkipUpdateStream?.() }\n        );\n      } else if (log.eventName === \"Store_DeleteRecord\") {\n        debug(\"deleting component\", {\n          namespace: table.namespace,\n          name: table.name,\n          entity,\n        });\n        removeComponent(component, entity, { skipUpdateStream: shouldSkipUpdateStream?.() });\n      }\n    }\n  }\n\n  return { storageAdapter: recsStorageAdapter, components };\n}\n", "import { debug as parentDebug } from \"../debug\";\n\nexport const debug = parentDebug.extend(\"recs\");\n", "import { World, defineComponent, Type, Component, Schema, Metadata } from \"@latticexyz/recs\";\nimport { Table } from \"../common\";\n\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function defineInternalComponents(world: World) {\n  return {\n    RegisteredTables: defineComponent<{ table: Type.T }, Metadata, Table>(\n      world,\n      { table: Type.T },\n      { metadata: { componentName: \"RegisteredTables\" } }\n    ),\n    SyncProgress: defineComponent(\n      world,\n      {\n        step: Type.String,\n        message: Type.String,\n        percentage: Type.Number,\n        latestBlockNumber: Type.BigInt,\n        lastBlockNumberProcessed: Type.BigInt,\n      },\n      { metadata: { componentName: \"SyncProgress\" } }\n    ),\n  } as const satisfies Record<string, Component<Schema, Metadata>>;\n}\n", "import { stringToHex } from \"viem\";\nimport { Table } from \"../common\";\nimport { Entity } from \"@latticexyz/recs\";\nimport { encodeEntity } from \"./encodeEntity\";\n\nexport function getTableEntity(table: Pick<Table, \"address\" | \"namespace\" | \"name\">): Entity {\n  return encodeEntity(\n    { address: \"address\", namespace: \"bytes16\", name: \"bytes16\" },\n    {\n      address: table.address,\n      namespace: stringToHex(table.namespace, { size: 16 }),\n      name: stringToHex(table.name, { size: 16 }),\n    }\n  );\n}\n", "import { hexKeyTupleToEntity } from \"./hexKeyTupleToEntity\";\n\nexport const singletonEntity = hexKeyTupleToEntity([]);\n", "import { Component, Type, World, defineComponent } from \"@latticexyz/recs\";\nimport { StoreComponentMetadata } from \"./common\";\nimport { SchemaAbiTypeToRecsType, schemaAbiTypeToRecsType } from \"./schemaAbiTypeToRecsType\";\nimport { SchemaAbiType } from \"@latticexyz/schema-type\";\nimport { Table } from \"@latticexyz/store\";\nimport { mapObject } from \"@latticexyz/common/utils\";\n\nexport type TableToComponent<table extends Table> = Component<\n  {\n    __staticData: Type.OptionalString;\n    __encodedLengths: Type.OptionalString;\n    __dynamicData: Type.OptionalString;\n  } & {\n    [fieldName in keyof table[\"valueSchema\"] & string]: Type &\n      SchemaAbiTypeToRecsType<SchemaAbiType & table[\"valueSchema\"][fieldName][\"type\"]>;\n  },\n  StoreComponentMetadata & {\n    componentName: table[\"name\"];\n    tableName: `${table[\"namespace\"]}:${table[\"name\"]}`;\n    keySchema: { [name in keyof table[\"keySchema\"] & string]: table[\"keySchema\"][name][\"type\"] };\n    valueSchema: { [name in keyof table[\"valueSchema\"] & string]: table[\"valueSchema\"][name][\"type\"] };\n  }\n>;\n\nexport function tableToComponent<table extends Table>(world: World, table: table): TableToComponent<table> {\n  return defineComponent(\n    world,\n    {\n      ...Object.fromEntries(\n        Object.entries(table.valueSchema).map(([fieldName, { type: schemaAbiType }]) => [\n          fieldName,\n          schemaAbiTypeToRecsType[schemaAbiType as SchemaAbiType],\n        ])\n      ),\n      __staticData: Type.OptionalString,\n      __encodedLengths: Type.OptionalString,\n      __dynamicData: Type.OptionalString,\n    },\n    {\n      id: table.tableId,\n      metadata: {\n        componentName: table.name,\n        tableName: `${table.namespace}:${table.name}`,\n        keySchema: mapObject(table.keySchema, ({ type }) => type),\n        valueSchema: mapObject(table.valueSchema, ({ type }) => type),\n      },\n    }\n  ) as TableToComponent<table>;\n}\n", "import { Type as RecsType } from \"@latticexyz/recs\";\nimport { SchemaAbiType } from \"@latticexyz/schema-type\";\n\nexport const schemaAbiTypeToRecsType = {\n  uint8: RecsType.Number,\n  uint16: RecsType.Number,\n  uint24: RecsType.Number,\n  uint32: RecsType.Number,\n  uint40: RecsType.Number,\n  uint48: RecsType.Number,\n  uint56: RecsType.BigInt,\n  uint64: RecsType.BigInt,\n  uint72: RecsType.BigInt,\n  uint80: RecsType.BigInt,\n  uint88: RecsType.BigInt,\n  uint96: RecsType.BigInt,\n  uint104: RecsType.BigInt,\n  uint112: RecsType.BigInt,\n  uint120: RecsType.BigInt,\n  uint128: RecsType.BigInt,\n  uint136: RecsType.BigInt,\n  uint144: RecsType.BigInt,\n  uint152: RecsType.BigInt,\n  uint160: RecsType.BigInt,\n  uint168: RecsType.BigInt,\n  uint176: RecsType.BigInt,\n  uint184: RecsType.BigInt,\n  uint192: RecsType.BigInt,\n  uint200: RecsType.BigInt,\n  uint208: RecsType.BigInt,\n  uint216: RecsType.BigInt,\n  uint224: RecsType.BigInt,\n  uint232: RecsType.BigInt,\n  uint240: RecsType.BigInt,\n  uint248: RecsType.BigInt,\n  uint256: RecsType.BigInt,\n  int8: RecsType.Number,\n  int16: RecsType.Number,\n  int24: RecsType.Number,\n  int32: RecsType.Number,\n  int40: RecsType.Number,\n  int48: RecsType.Number,\n  int56: RecsType.BigInt,\n  int64: RecsType.BigInt,\n  int72: RecsType.BigInt,\n  int80: RecsType.BigInt,\n  int88: RecsType.BigInt,\n  int96: RecsType.BigInt,\n  int104: RecsType.BigInt,\n  int112: RecsType.BigInt,\n  int120: RecsType.BigInt,\n  int128: RecsType.BigInt,\n  int136: RecsType.BigInt,\n  int144: RecsType.BigInt,\n  int152: RecsType.BigInt,\n  int160: RecsType.BigInt,\n  int168: RecsType.BigInt,\n  int176: RecsType.BigInt,\n  int184: RecsType.BigInt,\n  int192: RecsType.BigInt,\n  int200: RecsType.BigInt,\n  int208: RecsType.BigInt,\n  int216: RecsType.BigInt,\n  int224: RecsType.BigInt,\n  int232: RecsType.BigInt,\n  int240: RecsType.BigInt,\n  int248: RecsType.BigInt,\n  int256: RecsType.BigInt,\n  bytes1: RecsType.String,\n  bytes2: RecsType.String,\n  bytes3: RecsType.String,\n  bytes4: RecsType.String,\n  bytes5: RecsType.String,\n  bytes6: RecsType.String,\n  bytes7: RecsType.String,\n  bytes8: RecsType.String,\n  bytes9: RecsType.String,\n  bytes10: RecsType.String,\n  bytes11: RecsType.String,\n  bytes12: RecsType.String,\n  bytes13: RecsType.String,\n  bytes14: RecsType.String,\n  bytes15: RecsType.String,\n  bytes16: RecsType.String,\n  bytes17: RecsType.String,\n  bytes18: RecsType.String,\n  bytes19: RecsType.String,\n  bytes20: RecsType.String,\n  bytes21: RecsType.String,\n  bytes22: RecsType.String,\n  bytes23: RecsType.String,\n  bytes24: RecsType.String,\n  bytes25: RecsType.String,\n  bytes26: RecsType.String,\n  bytes27: RecsType.String,\n  bytes28: RecsType.String,\n  bytes29: RecsType.String,\n  bytes30: RecsType.String,\n  bytes31: RecsType.String,\n  bytes32: RecsType.String,\n  bool: RecsType.Boolean,\n  address: RecsType.String,\n  \"uint8[]\": RecsType.NumberArray,\n  \"uint16[]\": RecsType.NumberArray,\n  \"uint24[]\": RecsType.NumberArray,\n  \"uint32[]\": RecsType.NumberArray,\n  \"uint40[]\": RecsType.NumberArray,\n  \"uint48[]\": RecsType.NumberArray,\n  \"uint56[]\": RecsType.BigIntArray,\n  \"uint64[]\": RecsType.BigIntArray,\n  \"uint72[]\": RecsType.BigIntArray,\n  \"uint80[]\": RecsType.BigIntArray,\n  \"uint88[]\": RecsType.BigIntArray,\n  \"uint96[]\": RecsType.BigIntArray,\n  \"uint104[]\": RecsType.BigIntArray,\n  \"uint112[]\": RecsType.BigIntArray,\n  \"uint120[]\": RecsType.BigIntArray,\n  \"uint128[]\": RecsType.BigIntArray,\n  \"uint136[]\": RecsType.BigIntArray,\n  \"uint144[]\": RecsType.BigIntArray,\n  \"uint152[]\": RecsType.BigIntArray,\n  \"uint160[]\": RecsType.BigIntArray,\n  \"uint168[]\": RecsType.BigIntArray,\n  \"uint176[]\": RecsType.BigIntArray,\n  \"uint184[]\": RecsType.BigIntArray,\n  \"uint192[]\": RecsType.BigIntArray,\n  \"uint200[]\": RecsType.BigIntArray,\n  \"uint208[]\": RecsType.BigIntArray,\n  \"uint216[]\": RecsType.BigIntArray,\n  \"uint224[]\": RecsType.BigIntArray,\n  \"uint232[]\": RecsType.BigIntArray,\n  \"uint240[]\": RecsType.BigIntArray,\n  \"uint248[]\": RecsType.BigIntArray,\n  \"uint256[]\": RecsType.BigIntArray,\n  \"int8[]\": RecsType.NumberArray,\n  \"int16[]\": RecsType.NumberArray,\n  \"int24[]\": RecsType.NumberArray,\n  \"int32[]\": RecsType.NumberArray,\n  \"int40[]\": RecsType.NumberArray,\n  \"int48[]\": RecsType.NumberArray,\n  \"int56[]\": RecsType.BigIntArray,\n  \"int64[]\": RecsType.BigIntArray,\n  \"int72[]\": RecsType.BigIntArray,\n  \"int80[]\": RecsType.BigIntArray,\n  \"int88[]\": RecsType.BigIntArray,\n  \"int96[]\": RecsType.BigIntArray,\n  \"int104[]\": RecsType.BigIntArray,\n  \"int112[]\": RecsType.BigIntArray,\n  \"int120[]\": RecsType.BigIntArray,\n  \"int128[]\": RecsType.BigIntArray,\n  \"int136[]\": RecsType.BigIntArray,\n  \"int144[]\": RecsType.BigIntArray,\n  \"int152[]\": RecsType.BigIntArray,\n  \"int160[]\": RecsType.BigIntArray,\n  \"int168[]\": RecsType.BigIntArray,\n  \"int176[]\": RecsType.BigIntArray,\n  \"int184[]\": RecsType.BigIntArray,\n  \"int192[]\": RecsType.BigIntArray,\n  \"int200[]\": RecsType.BigIntArray,\n  \"int208[]\": RecsType.BigIntArray,\n  \"int216[]\": RecsType.BigIntArray,\n  \"int224[]\": RecsType.BigIntArray,\n  \"int232[]\": RecsType.BigIntArray,\n  \"int240[]\": RecsType.BigIntArray,\n  \"int248[]\": RecsType.BigIntArray,\n  \"int256[]\": RecsType.BigIntArray,\n  \"bytes1[]\": RecsType.StringArray,\n  \"bytes2[]\": RecsType.StringArray,\n  \"bytes3[]\": RecsType.StringArray,\n  \"bytes4[]\": RecsType.StringArray,\n  \"bytes5[]\": RecsType.StringArray,\n  \"bytes6[]\": RecsType.StringArray,\n  \"bytes7[]\": RecsType.StringArray,\n  \"bytes8[]\": RecsType.StringArray,\n  \"bytes9[]\": RecsType.StringArray,\n  \"bytes10[]\": RecsType.StringArray,\n  \"bytes11[]\": RecsType.StringArray,\n  \"bytes12[]\": RecsType.StringArray,\n  \"bytes13[]\": RecsType.StringArray,\n  \"bytes14[]\": RecsType.StringArray,\n  \"bytes15[]\": RecsType.StringArray,\n  \"bytes16[]\": RecsType.StringArray,\n  \"bytes17[]\": RecsType.StringArray,\n  \"bytes18[]\": RecsType.StringArray,\n  \"bytes19[]\": RecsType.StringArray,\n  \"bytes20[]\": RecsType.StringArray,\n  \"bytes21[]\": RecsType.StringArray,\n  \"bytes22[]\": RecsType.StringArray,\n  \"bytes23[]\": RecsType.StringArray,\n  \"bytes24[]\": RecsType.StringArray,\n  \"bytes25[]\": RecsType.StringArray,\n  \"bytes26[]\": RecsType.StringArray,\n  \"bytes27[]\": RecsType.StringArray,\n  \"bytes28[]\": RecsType.StringArray,\n  \"bytes29[]\": RecsType.StringArray,\n  \"bytes30[]\": RecsType.StringArray,\n  \"bytes31[]\": RecsType.StringArray,\n  \"bytes32[]\": RecsType.StringArray,\n  \"bool[]\": RecsType.T, // no boolean arr,\n  \"address[]\": RecsType.StringArray,\n  bytes: RecsType.String,\n  string: RecsType.String,\n} as const satisfies Record<SchemaAbiType, RecsType>;\n\nexport type SchemaAbiTypeToRecsType<T extends SchemaAbiType> = (typeof schemaAbiTypeToRecsType)[T];\n", "import { Table } from \"@latticexyz/store\";\nimport { TableToComponent, tableToComponent } from \"./tableToComponent\";\nimport { mapObject } from \"@latticexyz/common/utils\";\nimport { World } from \"@latticexyz/recs\";\n\nexport type TablesToComponents<tables extends Record<string, Table>> = {\n  [tableName in keyof tables]: TableToComponent<tables[tableName]>;\n};\n\nexport function tablesToComponents<tables extends Record<string, Table>>(\n  world: World,\n  tables: tables\n): TablesToComponents<tables> {\n  return mapObject(tables, (table) => tableToComponent(world, table));\n}\n", "import { StoreConfig, Table, ResolvedStoreConfig, resolveConfig } from \"@latticexyz/store\";\nimport { Component as RecsComponent, World as RecsWorld, getComponentValue, setComponent } from \"@latticexyz/recs\";\nimport { SyncOptions, SyncResult } from \"../common\";\nimport { RecsStorageAdapter, recsStorage } from \"./recsStorage\";\nimport { createStoreSync } from \"../createStoreSync\";\nimport { singletonEntity } from \"./singletonEntity\";\nimport { SyncStep } from \"../SyncStep\";\n\ntype SyncToRecsOptions<config extends StoreConfig, extraTables extends Record<string, Table>> = SyncOptions<config> & {\n  world: RecsWorld;\n  config: config;\n  tables?: extraTables;\n  startSync?: boolean;\n};\n\ntype SyncToRecsResult<config extends StoreConfig, extraTables extends Record<string, Table>> = SyncResult & {\n  components: RecsStorageAdapter<ResolvedStoreConfig<config>[\"tables\"] & extraTables>[\"components\"];\n  stopSync: () => void;\n};\n\nexport async function syncToRecs<config extends StoreConfig, extraTables extends Record<string, Table>>({\n  world,\n  config,\n  tables: extraTables,\n  startSync = true,\n  ...syncOptions\n}: SyncToRecsOptions<config, extraTables>): Promise<SyncToRecsResult<config, extraTables>> {\n  const tables = {\n    ...resolveConfig(config).tables,\n    ...extraTables,\n  } as ResolvedStoreConfig<config>[\"tables\"] & extraTables;\n\n  const { storageAdapter, components } = recsStorage({\n    world,\n    tables,\n    shouldSkipUpdateStream: (): boolean =>\n      getComponentValue(components.SyncProgress, singletonEntity)?.step !== SyncStep.LIVE,\n  });\n\n  const storeSync = await createStoreSync({\n    storageAdapter,\n    config,\n    ...syncOptions,\n    onProgress: ({ step, percentage, latestBlockNumber, lastBlockNumberProcessed, message }) => {\n      // already live, no need for more progress updates\n      if (getComponentValue(components.SyncProgress, singletonEntity)?.step === SyncStep.LIVE) return;\n\n      setComponent(components.SyncProgress, singletonEntity, {\n        step,\n        percentage,\n        latestBlockNumber,\n        lastBlockNumberProcessed,\n        message,\n      });\n\n      // when we switch to live, trigger update for all entities in all components\n      if (step === SyncStep.LIVE) {\n        for (const _component of Object.values(components)) {\n          // downcast component for easier calling of generic methods on all components\n          const component = _component as RecsComponent;\n          for (const entity of component.entities()) {\n            const value = getComponentValue(component, entity);\n            component.update$.next({ component, entity, value: [value, value] });\n          }\n        }\n      }\n    },\n  });\n\n  const sub = startSync ? storeSync.storedBlockLogs$.subscribe() : null;\n  const stopSync = (): void => {\n    sub?.unsubscribe();\n  };\n\n  world.registerDisposer(stopSync);\n\n  return {\n    ...storeSync,\n    components,\n    stopSync,\n  };\n}\n"],
  "mappings": "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EACF,GACA,QAAQ,EACN,WAAW,EACT,SAAS,aACX,GACA,aAAa,EACX,aAAa,eACb,WAAW,UACX,aAAa,UACb,oBAAoB,SACpB,sBAAsB,QACxB,EACF,GACA,aAAa,EACX,WAAW,EACT,YAAY,aACd,GACA,aAAa,EACX,QAAQ,OACV,EACF,GAEA,OAAO,EACL,WAAW,EACT,YAAY,aACd,GACA,aAAa,EACX,OAAO,YACT,GACA,iBAAiB,KACnB,EACF,EACF,CAAC;;;AChDD,IAAOC,KAAQC,GAAU,EACvB,iBAAiB,UACjB,mBAAmB,cACnB,oBAAoB,cACpB,WAAW,SACX,WAAW,EACT,YAAY,EAAE,UAAU,wCAAwC,cAAc,UAAU,EAC1F,GACA,QAAQ,EACN,gBAAgB,EACd,WAAW,EACT,aAAa,aACf,GACA,aAAa,EACX,OAAO,UACT,EACF,GACA,gBAAgB,EACd,WAAW,EACT,YAAY,cACZ,QAAQ,UACV,GACA,aAAa,EACX,QAAQ,OACV,EACF,GACA,kBAAkB,EAChB,WAAW,EACT,YAAY,WACZ,eAAe,UACjB,GACA,aAAa,EACX,eAAe,UACjB,EACF,GACA,uBAAuB,EACrB,WAAW,EACT,WAAW,WACX,WAAW,UACb,GACA,aAAa,EACX,qBAAqB,aACvB,EACF,GACA,4BAA4B,EAC1B,WAAW,EACT,aAAa,aACf,GACA,aAAa,EACX,qBAAqB,aACvB,EACF,GACA,UAAU,EACR,WAAW,EACT,aAAa,aACf,GACA,aAAa,EACX,SAAS,UACX,EACF,GACA,SAAS,EACP,WAAW,EACT,UAAU,aACZ,GACA,aAAa,EACX,QAAQ,WACR,cAAc,OAChB,GACA,YAAY,MACd,GACA,gBAAgB,EACd,WAAW,EACT,QAAQ,UACV,GACA,aAAa,EACX,UAAU,aACZ,EACF,GACA,aAAa,EACX,WAAW,EACT,UAAU,aACZ,GACA,aAAa,YACf,GACA,mBAAmB,EACjB,WAAW,EACT,kBAAkB,SACpB,GACA,aAAa,EACX,UAAU,cACV,wBAAwB,SAC1B,GACA,YAAY,MACd,GACA,oBAAoB,EAClB,WAAW,EACT,kBAAkB,SACpB,GACA,aAAa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S,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,UAAUA,GAAS,aACnB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,WAAWA,GAAS,aACpB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,YAAYA,GAAS,aACrB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aAAaA,GAAS,aACtB,aA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",
  "names": ["v", "TRPC_ERROR_CODES_BY_NUMBER", "v", "procedures", "_a", "parse", "result", "_a", "r", "_b", "DoubleIndexedKV", "Registry", "ClassRegistry", "c", "i", "_a", "_b", "CustomTransformerRegistry", "v", "isPlainObject", "i", "v", "e", "__read", "s", "a", "i", "isPlainObject", "walker", "__spreadArray", "__read", "_a", "v", "isPlainObject", "a", "b", "getType", "isArray", "getType", "isPlainObject", "getType", "isNull", "getType", "a", "b", "c", "e", "isUndefined", "isArray", "isPlainObject", "SuperJSON", "_a", "_b", "_c", "s", "__assign", "v", "__spreadArray", "__read", "identity", "x", "_a", "share", "_a", "v", "observable", "_a", "_b", "isObject", "_a", "_b", "i", "item", "httpBatchLink", "share", "_a", "_b", "_c", "parse", "_a", "i", "getBody", "createIndexerClient", "url", "createTRPCProxyClient", "superjson", "httpBatchLink", "storeSetRecordEvent", "storeSpliceStaticDataEvent", "storeSpliceDynamicDataEvent", "storeDeleteRecordEvent", "storeEvents", "storeEventsAbi", "parseAbi", "mud_config_default", "mudConfig", "mud_config_default", "mudConfig", "debug", "createDebug", "fetchLogs", "maxBlockRange", "maxRetryCount", "publicClient", "getLogsOpts", "fromBlock", "blockRange", "bigIntMin", "retryCount", "toBlock", "logs", "error", "seconds", "wait", "blockRangeToLogs", "address", "events", "pipe", "tap", "endBlock", "startBlock", "concatMap", "EMPTY", "from", "createBlockStream", "blockTag", "Observable", "subscriber", "block", "groupLogsByBlockNumber", "blockNumbers", "log", "bigIntSort", "groupedBlocks", "blockNumber", "blockLogs", "a", "b", "isDefined", "lastBlockNumber", "import_debug", "InvalidHexLengthError", "MUDError", "value", "InvalidHexLengthForSchemaError", "InvalidHexLengthForPackedCounterError", "InvalidHexLengthForStaticFieldError", "abiType", "staticAbiTypeToByteLength", "InvalidHexLengthForArrayFieldError", "SchemaStaticLengthMismatchError", "schemaData", "definedLength", "summedLength", "PackedCounterLengthMismatchError", "packedCounterData", "decodeStaticField", "data", "hexToBigInt", "defaultValueType", "staticAbiTypeToDefaultValue", "hexToBool", "getAddress", "assertExhaustive", "decodeDynamicField", "hexToString", "dataSize", "staticAbiType", "arrayAbiTypeToStaticAbiType", "itemByteLength", "_", "i", "itemData", "sliceHex", "hexToPackedCounter", "data", "InvalidHexLengthForPackedCounterError", "totalByteLength", "decodeStaticField", "readHex", "reversedFieldByteLengths", "decodeDynamicField", "fieldByteLengths", "summedLength", "total", "length", "PackedCounterLengthMismatchError", "staticDataLength", "staticFields", "fieldType", "staticAbiTypeToByteLength", "decodeRecord", "valueSchema", "values", "bytesOffset", "fieldByteLength", "value", "schemaStaticDataLength", "actualStaticDataLength", "dataLayout", "i", "dataLength", "dynamicAbiTypeToDefaultValue", "actualDynamicDataLength", "decodeValue", "isStaticAbiType", "dynamicFields", "isDynamicAbiType", "valueTuple", "name", "decodeValueArgs", "staticData", "encodedLengths", "dynamicData", "concatHex", "encodeField", "isArrayAbiType", "staticFieldType", "arrayAbiTypeToStaticAbiType", "encodePacked", "encodeKeyTuple", "keySchema", "keyTuple", "key", "index", "encodeAbiParameters", "encodeKey", "encodeLengths", "values", "byteLengths", "size", "totalByteLength", "total", "length", "padHex", "concatHex", "encodeField", "encodeValueArgs", "valueSchema", "value", "valueSchemaEntries", "staticFields", "type", "isStaticAbiType", "dynamicFields", "isDynamicAbiType", "encodedStaticValues", "name", "encodedDynamicValues", "encodedLengths", "hexToSchema", "data", "InvalidHexLengthForSchemaError", "staticDataLength", "hexToNumber", "sliceHex", "numStaticFields", "numDynamicFields", "staticFields", "dynamicFields", "i", "schemaTypeIndex", "schemaAbiTypes", "actualStaticDataLength", "acc", "fieldType", "staticAbiTypeToByteLength", "SchemaStaticLengthMismatchError", "flattenSchema", "schema", "mapObject", "value", "storeTables", "resolveConfig", "storeConfig", "worldTables", "worldConfig", "schemasTableId", "schemasTable", "SyncStep", "storeTableIds", "name", "resourceToHex", "worldTableIds", "internalTableIds", "debug", "createDebug", "defaultFilters", "tableId", "createStoreSync", "storageAdapter", "onProgress", "publicClient", "address", "initialFilters", "tableIds", "initialStartBlock", "maxBlockRange", "initialState", "indexerUrl", "filters", "initialState$", "defer", "indexer", "createIndexerClient", "chainId", "result", "catchError", "error", "of", "shareReplay", "startBlock$", "map", "tap", "startBlock", "initialLogs$", "filter", "concatMap", "blockNumber", "tables", "logs", "table", "record", "encodeKey", "encodeValueArgs", "chunkSize", "chunks", "chunk", "i", "latestBlock$", "createBlockStream", "latestBlockNumber$", "block", "endBlock", "blockLogs$", "combineLatest", "range", "blockRangeToLogs", "storeEventsAbi", "toBlock", "filteredLogs", "log", "mergeMap", "from", "groupLogsByBlockNumber", "share", "lastBlockNumberProcessed", "storedBlockLogs$", "concat", "totalBlocks", "processedBlocks", "recentBlocksWindow", "recentBlocks$", "scan", "recentBlocks", "waitForTransaction", "tx", "hasTransaction$", "blocks", "op", "isDefined", "lastBlock", "receipt", "TransactionReceiptNotFoundError", "firstValueFrom", "identity", "isTableRegistrationLog", "log", "storeTables", "logToTable", "tableId", "otherKeys", "table", "hexToResource", "value", "decodeValue", "schemasTable", "concatHex", "keySchema", "hexToSchema", "valueSchema", "keyNames", "decodeAbiParameters", "parseAbiParameters", "fieldNames", "valueAbiTypes", "abiType", "i", "entityToHexKeyTuple", "entity", "isHex", "length", "size", "_", "index", "sliceHex", "decodeEntity", "keySchema", "hexKeyTuple", "key", "type", "decodeAbiParameters", "hexKeyTupleToEntity", "concatHex", "encodeEntity", "keyName", "encodeAbiParameters", "isStoreComponent", "component", "debug", "defineInternalComponents", "world", "defineComponent", "Type", "getTableEntity", "table", "stringToHex", "singletonEntity", "schemaAbiTypeToRecsType", "RecsType", "tableToComponent", "fieldName", "schemaAbiType", "mapObject", "tablesToComponents", "tables", "storeTables", "resolveConfig", "storeConfig", "worldTables", "worldConfig", "recsStorage", "shouldSkipUpdateStream", "components", "recsStorageAdapter", "logs", "newTables", "isTableRegistrationLog", "logToTable", "newTable", "tableEntity", "hasComponent", "getComponentValue", "setComponent", "log", "namespace", "name", "hexToResource", "c", "value", "decodeValueArgs", "previousValue", "previousStaticData", "newStaticData", "spliceHex", "newValue", "previousDynamicData", "newDynamicData", "removeComponent", "syncToRecs", "config", "extraTables", "startSync", "syncOptions", "storageAdapter", "storeSync", "createStoreSync", "step", "percentage", "latestBlockNumber", "lastBlockNumberProcessed", "message", "_component", "sub", "stopSync"]
}
